### 8.2.8 访问控制，第 1 阶段：连接验证

当您尝试连接到 MySQL 服务器时，服务器根据以下条件接受或拒绝连接：

- 您的身份以及您是否能通过提供正确的凭证来验证它。
- 您的账户是锁定还是解锁状态。

服务器首先检查凭证，然后检查账户锁定状态。任何一步失败都会导致服务器完全拒绝您的访问。否则，服务器接受连接，然后进入第 2 阶段并等待请求。

服务器使用 user 表中的列进行身份和凭证检查，仅在满足以下条件时接受连接：

- 客户端主机名和用户名与 user 表某行中的 Host 和 User 列匹配。有关允许的 Host 和 User 值的规则，请参见第 6.2.4 节，“指定账户名称”。
- 客户端提供行中指定的凭证（例如，密码），由 authentication_string 列指示。凭证的解释使用 plugin 列中命名的认证插件。
- 该行表明账户是解锁的。锁定状态记录在 account_locked 列中，该列的值必须为 'N'。账户锁定可以使用 CREATE USER 或 ALTER USER 语句设置或更改。

您的身份基于两部分信息：

- 您的 MySQL 用户名。
- 您连接的客户端主机。

如果 User 列值非空，传入连接中的用户名必须完全匹配。如果 User 值为空，它匹配任何用户名。如果匹配传入连接的 user 表行的用户名为空，该用户被视为匿名用户，没有名称，而不是客户端实际指定的用户名的用户。这意味着在连接持续期间（即在第 2 阶段）进行所有进一步的访问检查时使用空用户名。

`authentication_string` 列可以为空。这不是通配符，也不意味着任何密码都匹配。这意味着用户必须在不指定密码的情况下连接。认证插件实现的认证方法可能使用或不使用 authentication_string 列中的密码。在这种情况下，可能还使用外部密码来认证 MySQL 服务器。

user 表中 authentication_string 列的非空密码值是加密的。MySQL 不以明文存储密码供任何人查看。相反，尝试连接的用户提供的密码被加密（使用账户认证插件实现的密码哈希方法）。加密后的密码在连接过程中用于检查密码是否正确，而无需加密密码在连接上传输。请参见第 6.2.1 节，“账户用户名和密码”。

从 MySQL 服务器的角度来看，加密的密码是真正的密码，所以您绝不应该让任何人接触它。特别是，不要给非管理用户读取 mysql 系统数据库中的表的权限。

以下表格显示了 user 表中各种 User 和 Host 值组合适用于传入连接的情况。

| User 值 | Host 值          | 允许的连接                                                   |
| ------- | ---------------- | ------------------------------------------------------------ |
| 'fred'  | 'h1.example.net' | fred，从 h1.example.net 连接                                 |
| ''      | 'h1.example.net' | 任何用户，从 h1.example.net 连接                             |
| 'fred'  | '%'              | fred，从任何主机连接                                         |
| ''      | '%'              | 任何用户，从任何主机连接                                     |
| 'fred'  | '%.example.net'  | fred，从 example.net 域中的任何主机连接                      |
| 'fred'  | 'x.example.%'    | fred，从 x.example.net、x.example.com、x.example.edu 等连接；这可能不实用 |
| 'fred'  | '198.51.100.177' | fred，从 IP 地址为 198.51.100.177 的主机连接                 |
|'fred' | '198.51.100.%' | fred，从 198.51.100 类 C 子网中的任何主机连接 |
|'fred' | '198.51.100.0/255.255.255.0' | 与上例相同|

传入连接的客户端主机名和用户名可能与 user 表中的多行匹配。前面的一组示例证明了这一点：其中几个条目匹配 fred 从 h1.example.net 的连接。

当可能有多个匹配时，服务器必须确定使用哪个。它按如下方式解决这个问题：

- 服务器在将 user 表读入内存时，会对行进行排序。
- 客户端尝试连接时，服务器按排序顺序查看行。
- 服务器使用与客户端主机名和用户名匹配的第一行。

服务器使用对具有最具体 Host 值的行进行优先排序的规则：

- 字面 IP 地址和主机名最具体。
- 在 MySQL 8.0.23 之前，字面 IP 地址的具体性不受其是否具有子网掩码的影响，因此 198.51.100.13 和 198.51.100.0/255.255.255.0 被认为同样具体。从 MySQL 8.0.23 开始，主机部分为 IP 地址的账户具有以下具体性顺序：
  - 主机部分为 IP 地址的账户：
    - CREATE USER 'user_name'@'127.0.0.1';
    - CREATE USER 'user_name'@'198.51.100.44';
  - 主机部分为 IP 地址使用 CIDR 表示法的账户：
    - CREATE USER 'user_name'@'192.0.2.21/8';
    - CREATE USER 'user_name'@'198.51.100.44/16';
  - 主机部分为 IP 地址带子网掩码的账户：
    - CREATE USER 'user_name'@'192.0.2.0/255.255.255.0';
    - CREATE USER 'user_name'@'198.51.0.0/255.255.0.0';
- 模式 '%' 表示“任何主机”，是最不具体的。
- 空字符串 '' 也表示“任何主机”，但在 '%' 之后排序。

非 TCP（套接字文件、命名管道和共享内存）连接被视为本地连接，如果有任何此类账户，则匹配 localhost 的主机部分，否则匹配匹配 localhost 的带通配符的主机部分（例如，local%，l%，%）。

将 '%' 视为等同于 localhost 的处理自 MySQL 8.0.35 起已弃用，并且您应该预期将来的 MySQL 版本将删除此行为。

具有相同 Host 值的行按 User 值的具体性顺序排列。空白的 User 值意味着“任何用户”，是最不具体的，因此对于具有相同 Host 值的行，非匿名用户排在匿名用户之前。

对于具有同样具体的 Host 和 User 值的行，顺序是不确定的。

为了了解这是如何工作的，假设 user 表看起来像这样：

```
+-----------+----------+-
| Host      | User     | ...
+-----------+----------+-
| %         | root     | ...
| %         | jeffrey  | ...
| localhost | root     | ...
| localhost |          | ...
+-----------+----------+-
```

当服务器将表读入内存时，它使用刚才描述的规则对行进行排序。排序后的结果看起来像这样：

```
+-----------+----------+-
| Host      | User     | ...
+-----------+----------+-
| localhost | root     | ...
| localhost |          | ...
| %         | jeffrey  | ...
| %         | root     | ...
+-----------+----------+-
```

当客户端尝试连接时，服务器会查看排序后的行，并使用找到的第一个匹配项。对于从 localhost 由 jeffrey 发起的连接，表中有两行匹配：一行的 Host 和 User 值为 'localhost' 和 ''，另一行的值为 '%' 和 'jeffrey'。'localhost' 行在排序中首先出现，所以服务器就使用这一行。

这里是另一个例子。假设 user 表如下所示：

+----------------+----------+-
| Host           | User     | ...
+----------------+----------+-
| %              | jeffrey  | ...
| h1.example.net |          | ...
+----------------+----------+-

排序后的表格看起来是这样的：

+----------------+----------+-
| Host           | User     | ...
+----------------+----------+-
| h1.example.net |          | ...
| %              | jeffrey  | ...
+----------------+----------+-

第一行匹配来自 h1.example.net 的任何用户的连接，而第二行匹配来自任何主机的 jeffrey 的连接。

注意
人们常常误以为，对于给定的用户名，当服务器尝试为连接找到匹配项时，首先使用明确命名该用户的所有行。这是不正确的。前面的例子说明了这一点，其中来自 h1.example.net 的 jeffrey 的连接首先不是由含有 'jeffrey' 作为 User 列值的行匹配的，而是由没有用户名的行匹配的。因此，即使 jeffrey 在连接时指定了用户名，他也被认证为匿名用户。

如果您能够连接到服务器，但您的权限不是您预期的，那么您可能被认证为另一个账户。要找出服务器用来认证您的是哪个账户，请使用 CURRENT_USER() 函数。（参见第 12.15 节，“信息函数”。）它返回一个 user_name@host_name 格式的值，该值指示与之匹配的 user 表行中的 User 和 Host 值。假设 jeffrey 连接并执行以下查询：

```
mysql> SELECT CURRENT_USER();
+----------------+
| CURRENT_USER() |
+----------------+
| @localhost     |
+----------------+
```

这里显示的结果表明匹配的 user 表行的 User 列值是空的。换句话说，服务器将 jeffrey 视为匿名用户。

诊断认证问题的另一种方法是打印出 user 表并手动对其进行排序，以查看首次匹配是在哪里进行的。