#### 8.4.5.6 读取审计日志文件

审计日志插件支持提供 SQL 接口读取 JSON 格式审计日志文件的功能（此功能不适用于其他格式的日志文件）。

当审计日志插件初始化并配置为 JSON 日志记录时，它使用包含当前审计日志文件的目录作为搜索可读审计日志文件的位置。插件从 `audit_log_file` 系统变量的值中确定文件位置、基本名称和后缀，然后查找符合以下模式的文件名，其中 `[...]` 表示可选的文件名部分：

```
basename[.timestamp].suffix[.gz][[.pwd_622424198204195214].enc]
```

如果文件名以 `.enc` 结尾，则文件已加密，读取其未加密内容需要从密钥环获取解密密码。审计日志插件按以下方式确定解密密码的密钥环 ID：

- 如果 `.enc` 前有 `pwd_id`，则密钥环 ID 为 `audit_log-pwd_id`。
- 如果 `.enc` 前没有 `pwd_id`，则文件具有旧名称，来自于审计日志加密密码历史记录实现之前。密钥环 ID 为 `audit_log`。

有关加密审计日志文件的更多信息，请参见 [加密审计日志文件](#encrypting-audit-log-files)。

插件会忽略手动重命名且不符合模式的文件，以及使用密钥环中不再可用的密码加密的文件。插件打开每个剩余的候选文件，验证文件是否实际包含 JSON 审计事件，并使用每个文件第一个事件的时间戳对文件进行排序。结果是一个文件序列，可通过日志读取函数进行访问：

- `audit_log_read()` 读取审计日志中的事件或关闭读取过程。
- `audit_log_read_bookmark()` 返回最近写入的审计日志事件的书签。此书签适合传递给 `audit_log_read()` 以指示从哪里开始读取。
- `audit_log_read()` 接受一个可选的 JSON 字符串参数，成功调用任一函数返回的结果是一个 JSON 字符串。

要使用这些函数读取审计日志，请遵循以下原则：

1. 调用 `audit_log_read()` 从给定位置或当前位置开始读取事件，或关闭读取：
    - 要初始化审计日志读取序列，请传递一个指示开始位置的参数。一种方法是传递 `audit_log_read_bookmark()` 返回的书签：
      ```sql
      SELECT audit_log_read(audit_log_read_bookmark());
      ```
    - 要继续从序列中的当前位置读取，请调用 `audit_log_read()` 而不指定位置：
      ```sql
      SELECT audit_log_read();
      ```
    - 要显式关闭读取序列，请传递一个 JSON 空参数：
      ```sql
      SELECT audit_log_read('null');
      ```
      不需要显式关闭读取。当会话结束或通过调用 `audit_log_read()` 并传递一个指示开始位置的参数来初始化新读取序列时，会隐式关闭读取。

2. 成功调用 `audit_log_read()` 读取事件返回一个包含审计事件数组的 JSON 字符串：
    - 如果返回数组的最终值不是 JSON 空值，则有更多事件在刚刚读取的事件之后，您可以再次调用 `audit_log_read()` 读取更多事件。
    - 如果返回数组的最终值是 JSON 空值，则当前读取序列中没有更多事件可以读取。

每个非空数组元素是一个表示为 JSON 哈希的事件。例如：

```json
[
  {
    "timestamp": "2020-05-18 13:39:33", "id": 0,
    "class": "connection", "event": "connect",
    ...
  },
  {
    "timestamp": "2020-05-18 13:39:33", "id": 1,
    "class": "general", "event": "status",
    ...
  },
  {
    "timestamp": "2020-05-18 13:39:33", "id": 2,
    "class": "connection", "event": "disconnect",
    ...
  },
  null
]
```

有关 JSON 格式审计事件内容的更多信息，请参见 [JSON 审计日志文件格式](#json-audit-log-file-format)。

在以下任何情况下，不指定位置调用 `audit_log_read()` 读取事件会产生错误：

- 尚未通过传递位置参数给 `audit_log_read()` 初始化读取序列。
- 当前读取序列中没有更多事件可以读取；即，`audit_log_read()` 先前返回的数组以 JSON 空值结尾。
- 通过传递 JSON 空值给 `audit_log_read()` 关闭了最近的读取序列。

在这些情况下，要读取事件，必须首先通过调用 `audit_log_read()` 并传递一个指定位置的参数来初始化读取序列。

要指定 `audit_log_read()` 的位置，请包含一个指示从何处开始读取的参数。例如，传递一个书签，它是包含 `timestamp` 和 `id` 元素的 JSON 哈希，这些元素唯一标识特定事件。以下是通过调用 `audit_log_read_bookmark()` 函数获取的书签示例：

```sql
mysql> SELECT audit_log_read_bookmark();
+-------------------------------------------------+
| audit_log_read_bookmark()                       |
+-------------------------------------------------+
| { "timestamp": "2020-05-18 21:03:44", "id": 0 } |
+-------------------------------------------------+
```

将当前书签传递给 `audit_log_read()` 初始化从书签位置开始的事件读取：

```sql
mysql> SELECT audit_log_read(audit_log_read_bookmark());
+-----------------------------------------------------------------------+
| audit_log_read(audit_log_read_bookmark())                             |
+-----------------------------------------------------------------------+
| [ {"timestamp":"2020-05-18 22:41:24","id":0,"class":"connection", ... |
+-----------------------------------------------------------------------+
```

`audit_log_read()` 的参数是可选的。如果存在，可以是关闭读取序列的 JSON 空值，或一个 JSON 哈希。

在传递给 `audit_log_read()` 的哈希参数中，项目是可选的，并控制读取操作的各个方面，例如开始读取的位置或要读取的事件数量。以下项目很重要（忽略其他项目）：

- `start`: 要读取的第一个事件在审计日志中的位置。位置以时间戳表示，从该时间戳值之后的第一个事件开始读取。`start` 项的格式如下，其中 `value` 是文字时间戳值：
  ```json
  "start": { "timestamp": "value" }
  ```
  从 MySQL 8.0.22 开始允许 `start` 项。

- `timestamp`, `id`: 要读取的第一个事件在审计日志中的位置。`timestamp` 和 `id` 项共同构成一个唯一标识特定事件的书签。如果 `audit_log_read()` 参数包含任一项，则必须同时包含两项以完整指定位置，否则会发生错误。

- `max_array_length`: 从日志中读取的最大事件数。如果省略此项，默认读取到日志末尾或读取缓冲区已满，以先到者为准。

要指定 `audit_log_read()` 的起始位置，请传递包含 `start` 项或由 `timestamp` 和 `id` 项组成的书签的哈希参数。如果哈希参数同时包含 `start` 项和书签，则会发生错误。

如果哈希参数未指定起始位置，则从当前位置继续读取。

如果时间戳值不包含时间部分，则假定时间部分为 `00:00:00`。

`audit_log_read()` 接受的示例参数：

- 从给定时间戳之后的第一个事件开始读取事件：
  ```sql
  audit_log_read('{ "start": { "timestamp": "2020-05-24 12:30:00" } }')
  ```
- 类似于上一个示例，但最多读取 3 个事件：
  ```sql
  audit_log_read('{ "start": { "timestamp": "2020-05-24 12:30:00" }, "max_array_length": 3 }')
  ```
- 从 2020-05-24 00:00:00（时间戳不包含时间部分，因此假定为 `00:00:00`）之后的第一个事件开始读取事件：
  ```sql
  audit_log_read('{ "start": { "timestamp": "2020-05-24" } }')
  ```
- 从具有确切时间戳和事件 ID 的事件开始读取事件：
  ```sql
  audit_log_read('{ "timestamp": "2020-05-24 12:30:00", "id": 0 }')
  ```
- 类似于上一个示例，但最多读取 3 个事件：
  ```sql
  audit_log_read('{ "timestamp": "2020-05-24 12:30:00", "id": 0, "max_array_length": 3 }')
  ```
- 从读取序列中的当前位置读取事件：
  ```sql
  audit_log_read()
  ```
- 从读取序列中的当前位置开始最多读取 5 个事件：
  ```sql
  audit_log_read('{ "max_array_length": 5 }')
  ```
- 关闭当前读取序列：
-   ```sql
    audit_log_read('null')
    ```

  从任一日志读取函数返回的 JSON 字符串可以根据需要进行操作。假设调用获取书签产生以下值：

  ```sql
  mysql> SET @mark := audit_log_read_bookmark();
  mysql> SELECT @mark;
  +-------------------------------------------------+
  | @mark                                           |
  +-------------------------------------------------+
  | { "timestamp": "2020-05-18 16:10:28", "id": 2 } |
  +-------------------------------------------------+
  ```

  使用该参数调用 `audit_log_read()` 可以返回多个事件。要将 `audit_log_read()` 限制为最多读取 N 个事件，请在字符串中添加一个 `max_array_length` 项。例如，要读取一个事件，请按以下方式修改字符串：

  ```sql
  mysql> SET @mark := JSON_SET(@mark, '$.max_array_length', 1);
  mysql> SELECT @mark;
  +----------------------------------------------------------------------+
  | @mark                                                                |
  +----------------------------------------------------------------------+
  | {"id": 2, "timestamp": "2020-05-18 16:10:28", "max_array_length": 1} |
  +----------------------------------------------------------------------+
  ```

  传递给 `audit_log_read()` 的修改字符串会产生最多包含一个事件的结果，无论有多少可用事件。

  在 MySQL 8.0.19 之前，从审计日志函数返回的字符串值是二进制字符串。要使用需要非二进制字符串的函数（如操作 JSON 值的函数），将其转换为非二进制字符串。例如，在传递书签给 `JSON_SET()` 之前，将其转换为 `utf8mb4`：

  ```sql
  SET @mark = CONVERT(@mark USING utf8mb4);
  ```

  该语句甚至可以在 MySQL 8.0.19 及更高版本中使用；对于这些版本，它实际上是无操作且无害的。

  如果从 `mysql` 客户端调用审计日志函数，则根据 `--binary-as-hex` 选项的值，二进制字符串结果会以十六进制表示显示。有关该选项的更多信息，请参见 [6.5.1 mysql — The MySQL Command-Line Client](#6.5.1-mysql-the-mysql-command-line-client)。

  要设置 `audit_log_read()` 读取的字节数限制，请设置 `audit_log_read_buffer_size` 系统变量。从 MySQL 8.0.12 开始，该变量的默认值为 32KB，可以在运行时设置。每个客户端应适当地设置其会话的 `audit_log_read_buffer_size` 值，以便使用 `audit_log_read()`。

  每次调用 `audit_log_read()` 返回符合缓冲区大小的尽可能多的可用事件。不符合缓冲区大小的事件会被跳过并生成警告。考虑到这种行为，在评估应用程序的适当缓冲区大小时，请考虑以下因素：

  - 调用 `audit_log_read()` 的次数与每次调用返回的事件数量之间存在权衡：
    - 使用较小的缓冲区大小，调用返回的事件较少，因此需要更多的调用。
    - 使用较大的缓冲区大小，调用返回的事件较多，因此需要更少的调用。
  - 使用较小的缓冲区大小，例如默认大小 32KB，事件超出缓冲区大小并因此被跳过的可能性更大。

  在 MySQL 8.0.12 之前，`audit_log_read_buffer_size` 的默认值为 1MB，影响所有客户端，并且只能在服务器启动时更改。

  有关审计日志读取函数的更多信息，请参见 [审计日志函数](#audit-log-functions)。