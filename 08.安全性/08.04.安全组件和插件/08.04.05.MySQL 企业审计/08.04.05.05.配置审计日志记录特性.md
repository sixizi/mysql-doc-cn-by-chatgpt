#### 8.4.5.5 配置审计日志特性

本节描述如何配置审计日志特性，例如审计日志插件写入事件的文件、写入事件的格式、是否启用日志文件压缩和加密以及空间管理。

- [审计日志文件命名约定](#审计日志文件命名约定)
- [选择审计日志文件格式](#选择审计日志文件格式)
- [启用审计日志刷新任务](#启用审计日志刷新任务)
- [添加异常检测的查询统计信息](#添加异常检测的查询统计信息)
- [压缩审计日志文件](#压缩审计日志文件)
- [加密审计日志文件](#加密审计日志文件)
- [手动解压和解密审计日志文件](#手动解压和解密审计日志文件)
- [MySQL 8.0.17 之前的审计日志文件加密](#MySQL 8.0.17 之前的审计日志文件加密)
- [审计日志文件的空间管理](#审计日志文件的空间管理)
- [审计日志的写入策略](#审计日志的写入策略)

> **注意**
>
> 此处描述的加密功能适用于 MySQL 8.0.17 及更高版本，除了与之前较有限的加密功能进行比较的部分；参见[MySQL 8.0.17 之前的审计日志文件加密](#MySQL-8.0.17-之前的审计日志文件加密)。

有关影响审计日志记录的函数和系统变量的附加信息，请参见[审计日志函数](#审计日志函数)和[审计日志选项和变量](#审计日志选项和变量)。

审计日志插件还可以基于事件内容或事件来源的帐户控制哪些审计事件被写入审计日志文件。参见[8.4.5.7 审计日志过滤](#8.4.5.7-审计日志过滤)。

##### 审计日志文件命名约定

要配置审计日志文件名，请在服务器启动时设置 `audit_log_file` 系统变量。默认名称为服务器数据目录中的 `audit.log`。为了最佳安全性，应将审计日志写入只有 MySQL 服务器和有合法理由查看日志的用户才能访问的目录。

插件将 `audit_log_file` 值解释为由可选的前导目录名称、基本名称和可选的后缀组成。如果启用压缩或加密，则实际使用的文件名（用于创建日志文件的名称）与配置的文件名不同，因为它具有附加的后缀：

- 如果启用压缩，插件会添加 `.gz` 后缀。
- 如果启用加密，插件会添加 `.pwd_id.enc` 后缀，其中 `pwd_id` 指示用于日志文件操作的加密密码。审计日志插件将加密密码存储在密钥环中；参见[加密审计日志文件](#加密审计日志文件)。

有效的审计日志文件名是将适用的压缩和加密后缀添加到配置文件名后的名称。例如，如果配置的 `audit_log_file` 值为 `audit.log`，则有效文件名如下表所示。

| 启用的功能   | 有效文件名                |
| ------------ | ------------------------- |
| 无压缩或加密 | `audit.log`               |
| 压缩         | `audit.log.gz`            |
| 加密         | `audit.log.pwd_id.enc`    |
| 压缩和加密   | `audit.log.gz.pwd_id.enc` |

`pwd_id` 表示用于加密或解密文件的密码 ID。`pwd_id` 格式为 `pwd_timestamp-seq`，其中：

- `pwd_timestamp` 是一个 UTC 值，格式为 `YYYYMMDDThhmmss`，表示创建密码的时间。
- `seq` 是序列号。对于具有相同 `pwd_timestamp` 值的密码，序列号从 1 开始递增。

以下是一些示例 `pwd_id` 密码 ID 值：

- `20190403T142359-1`
- `20190403T142400-1`
- `20190403T142400-2`

要构建在密钥环中存储密码的对应密钥环 ID，审计日志插件会将前缀 `audit_log-` 添加到 `pwd_id` 值。例如，对于上面显示的密码 ID，对应的密钥环 ID 为：

- `audit_log-20190403T142359-1`
- `audit_log-20190403T142400-1`
- `audit_log-20190403T142400-2`

审计日志插件当前使用的密码 ID 是具有最大 `pwd_timestamp` 值的密码的 ID。如果多个密码具有相同的 `pwd_timestamp` 值，则当前密码 ID 是具有最大序列号的密码 ID。例如，在前面的密码 ID 集中，有两个具有最大时间戳 `20190403T142400` 的密码，因此当前密码 ID 是具有最大序列号的密码（2）。

审计日志插件在初始化和终止期间基于有效的审计日志文件名执行某些操作：

- 在初始化期间，插件检查是否已存在具有审计日志文件名的文件，如果存在，则重命名它。（在这种情况下，插件假定先前的服务器调用在运行审计日志插件时意外退出。）然后插件写入一个新的空审计日志文件。
- 在终止期间，插件重命名审计日志文件。

文件重命名（无论是在插件初始化还是终止期间）均根据常规基于大小的日志文件轮换规则进行；参见[手动审计日志文件轮换（MySQL 8.0.31 之前）](#手动审计日志文件轮换（MySQL-8.0.31-之前）)。

##### 选择审计日志文件格式

要配置审计日志文件格式，请在服务器启动时设置 `audit_log_format` 系统变量。可用的格式如下：

- `NEW`：新样式 XML 格式。这是默认设置。
- `OLD`：旧样式 XML 格式。
- `JSON`：JSON 格式。将审计日志写入为 JSON 数组。仅此格式支持可选的查询时间和大小统计数据，这些数据从 MySQL 8.0.30 开始提供。

有关每种格式的详细信息，请参见[8.4.5.4 审计日志文件格式](#8.4.5.4-审计日志文件格式)。

##### 启用审计日志刷新任务

从 MySQL 8.0.34 开始，MySQL 企业审计提供了设置刷新间隔以自动处理内存缓存的功能。使用 `audit_log_flush_interval_seconds` 系统变量配置的刷新任务默认值为 0，这意味着任务未计划运行。

当任务配置为运行（值非零）时，MySQL 企业审计在初始化时尝试调用调度程序组件并配置定期刷新其内存缓存：

- 如果审计日志找不到调度程序注册服务的实现，则不会安排刷新并继续加载。
- 审计日志实现 `dynamic_loader_services_loaded_notification` 服务并监听 `mysql_scheduler` 的新注册，以便审计日志可以将其计划任务注册到新加载的调度程序中。
- 审计日志仅注册到加载的第一个调度程序实现中。

同样，MySQL 企业审计在去初始化时调用调度程序组件并取消其计划的定期刷新。它保持对调度程序注册服务的活动引用，直到取消注册计划任务，确保在有活动计划任务时无法卸载调度程序组件。执行调度程序及其任务的所有结果均写入服务器错误日志。

要安排审计日志刷新任务：

1. 确认调度程序组件已加载并启用。默认情况下启用该组件（ON）（参见 `component_scheduler.enabled`）。

   ```sql
   SELECT * FROM mysql.components;
   +--------------+--------------------+----------------------------+
   | component_id | component_group_id | component_urn              |
   +--------------+--------------------+----------------------------+
   |            1 |                  1 | file://component_scheduler |
   +--------------+--------------------+----------------------------+
   ```

2. 安装 `audit_log` 插件（如果尚未安装）（参见[8.4.5.2 安装或卸载 MySQL 企业审计](#8.4.5.2-安装或卸载-MySQL-企业审计)）。

3. 使用 `audit_log_flush_interval_seconds` 启动服务器，并将值设置为大于 59 的数字。值的上限因平台而异。例如，要配置刷新任务每两分钟重复一次：

   ```bash
   $> mysqld --audit_log_flush_interval_seconds=120
   ```

有关更多信息，请参见 `audit_log_flush_interval_seconds` 系统变量。

##### 添加异常检测的查询统计信息

从 MySQL 8.0.30 开始，您可以扩展 JSON 格式的日志文件，添加可选的数据字段，以显示查询时间、发送和接收的字节数、返回给客户端的行数以及检查的行数。这些数据在慢查询日志中可用于合格查询，在审计日志的上下文中，它类似地有助于检测活动分析中的异常。仅当审计日志为 JSON 格式（`audit_log_format=JSON`）时，才可以添加扩展数据字段，这不是默认设置。

通过组件服务将查询统计信息传递到审计日志中，这些服务作为审计日志



过滤函数设置。服务名为 `mysql_audit_print_service_longlong_data_source` 和 `mysql_audit_print_service_double_data_source`。您可以为每个输出项选择任一数据类型。对于查询时间，`longlong` 输出值为微秒，`double` 输出值为秒。

您可以使用 `audit_log_filter_set_filter()` 审计日志函数，将查询统计信息作为 JSON 过滤语法的服务元素，按如下方式添加：

```sql
SELECT audit_log_filter_set_filter('QueryStatistics',  
                                   '{ "filter": { "class": { "name": "general", "event": { "name": "status", "print" : '
                                   '{ "service": { "implementation": "mysql_server", "tag": "query_statistics", "element": [ '
                                   '{ "name": "query_time",     "type": "double" }, '
                                   '{ "name": "bytes_sent",     "type": "longlong" }, '
                                   '{ "name": "bytes_received", "type": "longlong" }, '
                                   '{ "name": "rows_sent",      "type": "longlong" }, '
                                   '{ "name": "rows_examined",  "type": "longlong" } ] } } } } } }');
```

要填充 `bytes_sent` 和 `bytes_received` 字段，必须将系统变量 `log_slow_extra` 设置为 `ON`。如果系统变量值为 `OFF`，则为这些字段写入空值。

如果您想停止收集查询统计信息，请使用 `audit_log_filter_set_filter()` 审计日志函数删除过滤器，例如：

```sql
SELECT audit_log_filter_remove_filter('QueryStatistics');
```

#### 压缩审计日志文件

可以为任何日志记录格式启用审计日志文件压缩。

要配置审计日志文件压缩，请在服务器启动时设置 `audit_log_compression` 系统变量。允许的值有 `NONE`（无压缩；默认值）和 `GZIP`（GNU Zip 压缩）。

如果同时启用压缩和加密，则压缩发生在加密之前。要手动恢复原始文件，首先解密它，然后解压它。参见[手动解压和解密审计日志文件](#手动解压和解密审计日志文件)。

#### 加密审计日志文件

可以为任何日志记录格式启用审计日志文件加密。加密基于用户定义的密码（除了审计日志插件生成的初始密码）。要使用此功能，必须启用 MySQL 密钥环，因为审计日志记录使用它来存储密码。可以使用任何密钥环组件或插件；有关说明，请参见[8.4.4 MySQL 密钥环](#8.4.4-MySQL-密钥环)。

要配置审计日志文件加密，请在服务器启动时设置 `audit_log_encryption` 系统变量。允许的值有 `NONE`（无加密；默认值）和 `AES`（AES-256-CBC 加密）。

要在运行时设置或获取加密密码，请使用这些审计日志函数：

- 要设置当前的加密密码，请调用 `audit_log_encryption_password_set()`。此函数将新密码存储在密钥环中。如果启用了加密，它还会执行日志文件轮换操作，将当前日志文件重命名，并使用密码开始新的日志文件。文件重命名根据常规基于大小的日志文件轮换规则进行；参见[手动审计日志文件轮换（MySQL 8.0.31 之前）](#手动审计日志文件轮换（MySQL-8.0.31-之前))。
- 如果 `audit_log_password_history_keep_days` 系统变量非零，调用 `audit_log_encryption_password_set()` 还会导致过期的旧存档审计日志加密密码过期。有关审计日志密码历史的更多信息，包括密码存档和过期，请参见该变量的描述。
- 要获取当前加密密码，请调用 `audit_log_encryption_password_get()`，不带参数。要通过 ID 获取密码，请传递一个指定当前密码或存档密码的密钥环 ID 的参数。

要确定存在哪些审计日志密钥环 ID，请查询性能模式 `keyring_keys` 表：

```sql
mysql> SELECT KEY_ID FROM performance_schema.keyring_keys
       WHERE KEY_ID LIKE 'audit_log%'
       ORDER BY KEY_ID;
+-----------------------------+
| KEY_ID                      |
+-----------------------------+
| audit_log-20190415T152248-1 |
| audit_log-20190415T153507-1 |
| audit_log-20190416T125122-1 |
| audit_log-20190416T141608-1 |
+-----------------------------+
```

有关审计日志加密函数的更多信息，请参见[审计日志函数](#审计日志函数)。

当审计日志插件初始化时，如果发现启用了日志文件加密，它会检查密钥环中是否包含审计日志加密密码。如果没有，插件会自动生成一个随机的初始加密密码并将其存储在密钥环中。要获取此密码，请调用 `audit_log_encryption_password_get()`。

如果同时启用压缩和加密，则压缩发生在加密之前。要手动恢复原始文件，首先解密它，然后解压它。参见[手动解压和解密审计日志文件](#手动解压和解密审计日志文件)。

#### 手动解压和解密审计日志文件

可以使用标准工具解压和解密审计日志文件。这仅应对已关闭（存档）且不再使用的日志文件执行，而不应对审计日志插件当前正在写入的日志文件执行。可以通过文件名中的时间戳识别存档的日志文件，该时间戳位于基本名称之后。

假设 `audit_log_file` 设置为 `audit.log`。在这种情况下，存档的审计日志文件名如下表所示。

| 启用的功能   | 存档文件名                          |
| ------------ | ----------------------------------- |
| 无压缩或加密 | `audit.timestamp.log`               |
| 压缩         | `audit.timestamp.log.gz`            |
| 加密         | `audit.timestamp.log.pwd_id.enc`    |
| 压缩和加密   | `audit.timestamp.log.gz.pwd_id.enc` |

如[审计日志文件命名约定](#审计日志文件命名约定)所述，`pwd_id` 格式为 `pwd_timestamp-seq`。因此，存档的加密日志文件名实际上包含两个时间戳。第一个表示文件轮换时间，第二个表示创建加密密码的时间。

考虑以下一组存档的加密日志文件名：

- `audit.20190410T205827.log.20190403T185337-1.enc`
- `audit.20190410T210243.log.20190403T185337-1.enc`
- `audit.20190415T145309.log.20190414T223342-1.enc`
- `audit.20190415T151322.log.20190414T223342-2.enc`

每个文件名都有一个唯一的轮换时间戳。相比之下，密码时间戳不是唯一的：

- 前两个文件具有相同的密码 ID 和序列号（20190403T185337-1）。它们具有相同的加密密码。
- 后两个文件具有相同的密码 ID（20190414T223342），但序列号不同（1、2）。这些文件具有不同的加密密码。

要手动解压压缩的日志文件，请使用 `gunzip`、`gzip -d` 或等效命令。例如：

```bash
gunzip -c audit.timestamp.log.gz > audit.timestamp.log
```

要手动解密加密的日志文件，请使用 `openssl` 命令。例如：

```bash
openssl enc -d -aes-256-cbc -pass pass:password -md sha256
    -in audit.timestamp.log.pwd_id.enc
    -out audit.timestamp.log
```

要执行该命令，您必须获取 `password`，即加密密码。要获取此密码，请使用 `audit_log_encryption_password_get()`。例如，如果审计日志文件名为 `audit.20190415T151322.log.20190414T223342-2.enc`，则密码 ID 为 `20190414T223342-2`，密钥环 ID 为 `audit-log-20190414T223342-2`。按如下方式检索密钥环密码：

```sql
SELECT audit_log_encryption_password_get('audit-log-20190414T223342-2');
```

如果同时启用压缩和加密，则压缩发生在加密之前。在这种情况下，文件名具有 `.gz` 和 `.pwd_id.enc` 后缀，分别对应于这些操作的顺序。要手动恢复原始文件，请反向执行这些操作。也就是说，首先解密文件，然后解压它：

````bash
openssl enc -d -aes-256-cbc -pass pass:password -md sha256
    -in audit.timestamp.log.gz.pwd_id.enc
    -out audit.timestamp.log.gz
gunzip -c audit.timestamp.log.gz > audit.timestamp.log
```

#### MySQL 8.0.17 之前的审计日志文件加密

本节介绍 MySQL 8.0.17 之前和之后的审计日志文件加密功能的差异，以及从低于 8.0.17 的版本升级到 8.0.17 或更高版本时，审计日志插件如何处理升级。

| 特性                       | MySQL 8.0.17 之前          | MySQL 8.0.17 及之后       |
|--------------------------|--------------------------|--------------------------|
| 密码数量                  | 仅一个密码                 | 允许多个密码               |
| 加密日志文件名             | `.enc` 后缀               | `.pwd_622424198204195214.enc` 后缀 |
| 密码密钥环 ID             | `audit_log`              | `audit_log-pwd_622424198204195214` |
| 密码历史                  | 无                        | 有                        |

在 MySQL 8.0.17 之前，没有密码历史记录，因此设置新密码会使旧密码无法访问，从而使 MySQL 企业审计无法读取使用旧密码加密的日志文件。如果您预计需要手动解密这些文件，则必须保留以前的密码记录。

如果在从低于 8.0.17 的版本升级到 MySQL 8.0.17 或更高版本时启用了审计日志文件加密，审计日志插件会执行以下升级操作：

- 在插件初始化期间，插件检查是否存在密钥环 ID 为 `audit_log` 的加密密码。如果找到，它会使用 `audit_log-pwd_622424198204195214` 格式复制密码并将其用作当前加密密码。（有关 `pwd_622424198204195214` 语法的详细信息，请参见[审计日志文件命名约定](#审计日志文件命名约定)）。
- 现有的加密日志文件具有 `.enc` 后缀。插件不会将这些重命名为具有 `.pwd_id.enc` 后缀，但只要密钥环中仍然存在 ID 为 `audit_log` 的密钥，就可以读取它们。
- 当密码清理发生时，如果插件使任何具有 `audit_log-pwd_id` 格式密钥环 ID 的密码过期，它还会使具有 `audit_log` 密钥环 ID 的密码过期（如果存在）。此时，假定您不再需要这些文件，因此具有 `.enc` 后缀而不是 `.pwd_id.enc` 后缀的加密日志文件将无法被插件读取。

#### 审计日志文件的空间管理

审计日志文件有可能变得非常大并占用大量磁盘空间。如果您从 MySQL 8.0.30 开始收集可选的查询时间和大小统计信息，这会增加空间需求。查询统计信息仅在 JSON 格式下支持。

要管理使用的空间，请使用以下方法：

- 日志文件轮换。这涉及通过重命名当前日志文件来轮换它，然后使用原始名称打开一个新的当前日志文件。可以手动执行轮换，也可以配置为自动执行。
- 如果启用了自动轮换，则修剪轮换的 JSON 格式日志文件。从 MySQL 8.0.24 开始，可以基于日志文件的年龄进行修剪；从 MySQL 8.0.26 开始，可以基于组合日志文件的大小进行修剪。

要配置审计日志文件空间管理，请使用以下系统变量：

- 如果 `audit_log_rotate_on_size` 为 0（默认值），则禁用自动日志文件轮换。
  - 不会进行轮换，除非手动执行。

要轮换当前文件，请使用以下方法之一：

- 在 MySQL 8.0.31 之前，手动重命名文件，然后启用 `audit_log_flush` 以关闭它并使用原始名称打开一个新的当前日志文件。此文件轮换方法和 `audit_log_flush` 变量在 MySQL 8.0.31 中已弃用。
  - 使用此文件轮换方法，不会对轮换的 JSON 格式日志文件进行修剪；`audit_log_max_size` 和 `audit_log_prune_seconds` 无效。
- 从 MySQL 8.0.31 开始，运行 `SELECT audit_log_rotate();` 以重命名文件并使用原始名称打开一个新的审计日志文件。
  - 使用此文件轮换方法，如果 `audit_log_max_size` 或 `audit_log_prune_seconds` 的值大于 0，则会对轮换的 JSON 格式日志文件进行修剪。

参见[手动审计日志文件轮换（MySQL 8.0.31 之前）](#手动审计日志文件轮换（MySQL-8.0.31-之前）)。

- 如果 `audit_log_rotate_on_size` 大于 0，则启用自动审计日志文件轮换：
  - 当写入当前日志文件的操作导致其大小超过 `audit_log_rotate_on_size` 值时会自动轮换，还会在某些其他条件下发生；参见[自动审计日志文件轮换](#自动审计日志文件轮换)。当发生自动轮换时，审计日志插件会重命名当前日志文件并使用原始名称打开一个新的当前日志文件。
  - 如果 `audit_log_max_size` 或 `audit_log_prune_seconds` 的值大于 0，则会对轮换的 JSON 格式日志文件进行修剪。
  - `audit_log_flush` 无效。

> **注意**
> 对于 JSON 格式日志文件，当在运行时更改 `audit_log_format_unix_timestamp` 系统变量的值时也会发生轮换。然而，这不是出于空间管理的目的，而是为了确保在给定的 JSON 格式日志文件中，文件中的所有记录都包含或不包含 `time` 字段。

> **注意**
> 轮换（重命名）的日志文件不会自动删除。例如，对于基于大小的日志文件轮换，重命名的日志文件具有唯一名称，并无限期累积。它们不会从名称序列的末端轮换。为避免过度使用空间：
> - 从 MySQL 8.0.24 开始（对于 JSON 格式日志文件）：启用日志文件修剪，如[审计日志文件修剪](#审计日志文件修剪)所述。
> - 否则（对于非 JSON 文件，或 MySQL 8.0.24 之前的所有日志格式）：定期删除旧文件，必要时先备份它们。如果备份的日志文件是加密的，还请将相应的加密密码备份到安全的地方，以防以后需要解密文件。

以下部分更详细地描述了日志文件轮换和修剪。

##### 手动审计日志文件轮换（MySQL 8.0.31 之前）

> **注意**
> 从 MySQL 8.0.31 开始，`audit_log_flush` 变量和此审计日志文件轮换方法已弃用；预计将在 MySQL 的未来版本中移除支持。

如果 `audit_log_rotate_on_size` 为 0（默认值），则除非手动执行，否则不会进行日志轮换。在这种情况下，当 `audit_log_flush` 值从禁用更改为启用时，审计日志插件会关闭并重新打开日志文件。日志文件重命名必须在服务器外部进行。假设日志文件名为 `audit.log`，并且您想保留最近的三个日志文件，循环使用名称 `audit.log.1` 到 `audit.log.3`。在 Unix 上，可以这样手动进行轮换：

在命令行中，重命名当前日志文件：

```bash
mv audit.log.2 audit.log.3
mv audit.log.1 audit.log.2
mv audit.log audit.log.1
```

这种策略会覆盖当前 `audit.log.3` 的内容，对存档日志文件的数量和它们使用的空间进行限制。

此时，插件仍在写入当前日志文件，该文件已重命名为 `audit.log.1`。连接到服务器并刷新日志文件，以便插件关闭它并重新打开一个新的 `audit.log` 文件：

```sql
SET GLOBAL audit_log_flush = ON;
```

`audit_log_flush` 特殊之处在于其值保持为 `OFF`，因此您无需在再次启用之前显式禁用它以执行另一次刷新。

> **注意**
> 如果启用了压缩或加密，日志文件名会包含表示启用功能的后缀，以及如果启用了加密，还会包含密码 ID。如果文件名包含密码 ID，请确保在手动重命名的任何文件名中保留该 ID，以便可以确定用于解密操作的密码。

> **注意**
> 对于 JSON 格式日志记录，手动重命名审计日志文件会使日志读取功能无法访问这些文件，因为审计日志插件无法再确定它们是日志文件序列的一部分（参见[8.4.5.6 读取审计日志文件](#8.4.5.6-读取审计日志文件)）。考虑将 `audit_log_rotate_on_size` 设置为大于 0，以使用基于大小的轮换。

##### 手动审计日志文件轮换（MySQL 8.
````



`

#### MySQL 8.0.17 之前的审计日志文件加密

本节介绍 MySQL 8.0.17 之前和之后的审计日志文件加密功能的差异，以及从低于 8.0.17 的版本升级到 8.0.17 或更高版本时，审计日志插件如何处理升级。

| 特性           | MySQL 8.0.17 之前 | MySQL 8.0.17 及之后                |
| -------------- | ----------------- | ---------------------------------- |
| 密码数量       | 仅一个密码        | 允许多个密码                       |
| 加密日志文件名 | `.enc` 后缀       | `.pwd_622424198204195214.enc` 后缀 |
| 密码密钥环 ID  | `audit_log`       | `audit_log-pwd_622424198204195214` |
| 密码历史       | 无                | 有                                 |

在 MySQL 8.0.17 之前，没有密码历史记录，因此设置新密码会使旧密码无法访问，从而使 MySQL 企业审计无法读取使用旧密码加密的日志文件。如果您预计需要手动解密这些文件，则必须保留以前的密码记录。

如果在从低于 8.0.17 的版本升级到 MySQL 8.0.17 或更高版本时启用了审计日志文件加密，审计日志插件会执行以下升级操作：

- 在插件初始化期间，插件检查是否存在密钥环 ID 为 `audit_log` 的加密密码。如果找到，它会使用 `audit_log-pwd_622424198204195214` 格式复制密码并将其用作当前加密密码。（有关 `pwd_622424198204195214` 语法的详细信息，请参见[审计日志文件命名约定](#审计日志文件命名约定)）。
- 现有的加密日志文件具有 `.enc` 后缀。插件不会将这些重命名为具有 `.pwd_id.enc` 后缀，但只要密钥环中仍然存在 ID 为 `audit_log` 的密钥，就可以读取它们。
- 当密码清理发生时，如果插件使任何具有 `audit_log-pwd_id` 格式密钥环 ID 的密码过期，它还会使具有 `audit_log` 密钥环 ID 的密码过期（如果存在）。此时，假定您不再需要这些文件，因此具有 `.enc` 后缀而不是 `.pwd_id.enc` 后缀的加密日志文件将无法被插件读取。

#### 审计日志文件的空间管理

审计日志文件有可能变得非常大并占用大量磁盘空间。如果您从 MySQL 8.0.30 开始收集可选的查询时间和大小统计信息，这会增加空间需求。查询统计信息仅在 JSON 格式下支持。

要管理使用的空间，请使用以下方法：

- 日志文件轮换。这涉及通过重命名当前日志文件来轮换它，然后使用原始名称打开一个新的当前日志文件。可以手动执行轮换，也可以配置为自动执行。
- 如果启用了自动轮换，则修剪轮换的 JSON 格式日志文件。从 MySQL 8.0.24 开始，可以基于日志文件的年龄进行修剪；从 MySQL 8.0.26 开始，可以基于组合日志文件的大小进行修剪。

要配置审计日志文件空间管理，请使用以下系统变量：

- 如果 `audit_log_rotate_on_size` 为 0（默认值），则禁用自动日志文件轮换。
  - 不会进行轮换，除非手动执行。

要轮换当前文件，请使用以下方法之一：

- 在 MySQL 8.0.31 之前，手动重命名文件，然后启用 `audit_log_flush` 以关闭它并使用原始名称打开一个新的当前日志文件。此文件轮换方法和 `audit_log_flush` 变量在 MySQL 8.0.31 中已弃用。
  - 使用此文件轮换方法，不会对轮换的 JSON 格式日志文件进行修剪；`audit_log_max_size` 和 `audit_log_prune_seconds` 无效。
- 从 MySQL 8.0.31 开始，运行 `SELECT audit_log_rotate();` 以重命名文件并使用原始名称打开一个新的审计日志文件。
  - 使用此文件轮换方法，如果 `audit_log_max_size` 或 `audit_log_prune_seconds` 的值大于 0，则会对轮换的 JSON 格式日志文件进行修剪。

参见[手动审计日志文件轮换（MySQL 8.0.31 之前）](#手动审计日志文件轮换（MySQL-8.0.31-之前）)。

- 如果 `audit_log_rotate_on_size` 大于 0，则启用自动审计日志文件轮换：
  - 当写入当前日志文件的操作导致其大小超过 `audit_log_rotate_on_size` 值时会自动轮换，还会在某些其他条件下发生；参见[自动审计日志文件轮换](#自动审计日志文件轮换)。当发生自动轮换时，审计日志插件会重命名当前日志文件并使用原始名称打开一个新的当前日志文件。
  - 如果 `audit_log_max_size` 或 `audit_log_prune_seconds` 的值大于 0，则会对轮换的 JSON 格式日志文件进行修剪。
  - `audit_log_flush` 无效。

> **注意**
> 对于 JSON 格式日志文件，当在运行时更改 `audit_log_format_unix_timestamp` 系统变量的值时也会发生轮换。然而，这不是出于空间管理的目的，而是为了确保在给定的 JSON 格式日志文件中，文件中的所有记录都包含或不包含 `time` 字段。

> **注意**
> 轮换（重命名）的日志文件不会自动删除。例如，对于基于大小的日志文件轮换，重命名的日志文件具有唯一名称，并无限期累积。它们不会从名称序列的末端轮换。为避免过度使用空间：
> - 从 MySQL 8.0.24 开始（对于 JSON 格式日志文件）：启用日志文件修剪，如[审计日志文件修剪](#审计日志文件修剪)所述。
> - 否则（对于非 JSON 文件，或 MySQL 8.0.24 之前的所有日志格式）：定期删除旧文件，必要时先备份它们。如果备份的日志文件是加密的，还请将相应的加密密码备份到安全的地方，以防以后需要解密文件。

以下部分更详细地描述了日志文件轮换和修剪。

##### 手动审计日志文件轮换（MySQL 8.0.31 之前）

> **注意**
> 从 MySQL 8.0.31 开始，`audit_log_flush` 变量和此审计日志文件轮换方法已弃用；预计将在 MySQL 的未来版本中移除支持。

如果 `audit_log_rotate_on_size` 为 0（默认值），则除非手动执行，否则不会进行日志轮换。在这种情况下，当 `audit_log_flush` 值从禁用更改为启用时，审计日志插件会关闭并重新打开日志文件。日志文件重命名必须在服务器外部进行。假设日志文件名为 `audit.log`，并且您想保留最近的三个日志文件，循环使用名称 `audit.log.1` 到 `audit.log.3`。在 Unix 上，可以这样手动进行轮换：

在命令行中，重命名当前日志文件：

```bash
mv audit.log.2 audit.log.3
mv audit.log.1 audit.log.2
mv audit.log audit.log.1
```

这种策略会覆盖当前 `audit.log.3` 的内容，对存档日志文件的数量和它们使用的空间进行限制。

此时，插件仍在写入当前日志文件，该文件已重命名为 `audit.log.1`。连接到服务器并刷新日志文件，以便插件关闭它并重新打开一个新的 `audit.log` 文件：

```sql
SET GLOBAL audit_log_flush = ON;
```

`audit_log_flush` 特殊之处在于其值保持为 `OFF`，因此您无需在再次启用之前显式禁用它以执行另一次刷新。

> **注意**
> 如果启用了压缩或加密，日志文件名会包含表示启用功能的后缀，以及如果启用了加密，还会包含密码 ID。如果文件名包含密码 ID，请确保在手动重命名的任何文件名中保留该 ID，以便可以确定用于解密操作的密码。

> **注意**
> 对于 JSON 格式日志记录，手动重命名审计日志文件会使日志读取功能无法访问这些文件，因为审计日志插件无法再确定它们是日志文件序列的一部分（参见[8.4.5.6 读取审计日志文件](#8.4.5.6-读取审计日志文件)）。考虑将 `audit_log_rotate_on_size` 设置为大于 0，以使用基于大小的轮换。

##### 手动审计日志文件轮换（MySQL 8.

0.31 及之后）

如果 `audit_log_rotate_on_size` 为 0（默认值），则除非手动执行，否则不会进行日志轮换。

要手动轮换审计日志文件，请运行 `SELECT audit_log_rotate();` 以重命名当前审计日志文件并打开一个新的审计日志文件。文件重命名根据[审计日志文件命名约定](#审计日志文件命名约定)中的约定进行。

使用 `audit_log_rotate()` 函数需要 `AUDIT_ADMIN` 权限。

管理存档日志文件的数量（已重命名的文件）及其使用的空间是手动任务，涉及从文件系统中删除不再需要的存档审计日志文件。

使用 `audit_log_rotate()` 函数重命名的审计日志文件的内容可以通过 `audit_log_read()` 函数读取。

##### 自动审计日志文件轮换

如果 `audit_log_rotate_on_size` 大于 0，则设置 `audit_log_flush` 无效。相反，每当对当前日志文件的写入操作导致其大小超过 `audit_log_rotate_on_size` 值时，审计日志插件会自动重命名当前日志文件并使用原始名称打开一个新的当前日志文件。

基于大小的自动轮换还会在以下条件下发生：

- 插件初始化期间，如果已经存在具有审计日志文件名的文件（参见[审计日志文件命名约定](#审计日志文件命名约定)）。
- 插件终止期间。
- 调用 `audit_log_encryption_password_set()` 函数设置加密密码时（如果启用了加密）。如果未启用加密，则不会发生轮换。

插件通过在基本名称之后插入时间戳来重命名原始文件。例如，如果文件名为 `audit.log`，则插件将其重命名为 `audit.20210115T140633.log`。时间戳为 UTC 值，格式为 `YYYYMMDDThhmmss`。对于 XML 日志记录，时间戳表示轮换时间。对于 JSON 日志记录，时间戳为写入文件的最后一个事件的时间。

如果日志文件是加密的，则原始文件名已经包含一个时间戳，表示加密密码的创建时间（参见[审计日志文件命名约定](#审计日志文件命名约定)）。在这种情况下，轮换后的文件名包含两个时间戳。例如，一个名为 `audit.log.20210110T130749-1.enc` 的加密日志文件被重命名为 `audit.20210115T140633.log.20210110T130749-1.enc`。

##### 审计日志文件修剪

如果启用了自动日志文件轮换，审计日志插件支持修剪轮换的 JSON 格式审计日志文件。要使用此功能：

- 将 `audit_log_format` 设置为 `JSON`。（此外，考虑也更改 `audit_log_file`；参见[选择审计日志文件格式](#选择审计日志文件格式)）。
- 将 `audit_log_rotate_on_size` 设置为大于 0，以指定自动日志文件轮换时的大小（以字节为单位）。

默认情况下，不会对自动轮换的 JSON 格式日志文件进行修剪。要启用修剪，请将以下系统变量之一设置为大于 0 的值：

- 将 `audit_log_max_size` 设置为大于 0，以指定轮换日志文件的组合大小限制，超过该限制的文件将成为修剪对象。`audit_log_max_size` 从 MySQL 8.0.26 开始可用。
- 将 `audit_log_prune_seconds` 设置为大于 0，以指定轮换日志文件成为修剪对象的秒数。`audit_log_prune_seconds` 从 MySQL 8.0.24 开始可用。

`audit_log_max_size` 的非零值优先于 `audit_log_prune_seconds` 的非零值。如果在插件初始化时两者都设置为大于 0，则会向服务器错误日志写入警告。如果客户端在运行时将两者都设置为大于 0，则会向客户端返回警告。

> **注意**
> 向错误日志写入的警告是信息消息。为了确保此类消息出现在错误日志中而不被丢弃，请确保错误日志记录的详细程度足够包含信息消息。例如，如果您使用基于优先级的日志过滤，如[7.4.2.5 基于优先级的错误日志过滤（log_filter_internal）](#7.4.2.5-基于优先级的错误日志过滤（log_filter_internal）)所述，请将 `log_error_verbosity` 系统变量设置为 3。

如果启用了修剪功能，则 JSON 格式日志文件的修剪在以下情况下发生：

- 当发生自动轮换时；有关轮换发生的条件，请参见[自动审计日志文件轮换](#自动审计日志文件轮换)。
- 当在运行时设置全局 `audit_log_max_size` 或 `audit_log_prune_seconds` 系统变量时。

对于基于组合轮换日志文件大小的修剪，如果组合大小超过 `audit_log_max_size` 指定的限制，审计日志插件会删除最旧的文件，直到它们的组合大小不超过限制。

对于基于轮换日志文件年龄的修剪，修剪点为当前时间减去 `audit_log_prune_seconds` 的值。在轮换的 JSON 格式日志文件中，文件名的时间戳部分表示写入文件的最后一个事件的时间戳。审计日志插件使用文件名时间戳来确定哪些文件仅包含早于修剪点的事件，并删除这些文件。

#### 审计日志的写入策略

审计日志插件可以使用多种策略进行日志写入。无论采用何种策略，日志记录都是尽力而为，没有一致性保证。

要指定写入策略，请在服务器启动时设置 `audit_log_strategy` 系统变量。默认情况下，策略值为 `ASYNCHRONOUS`，插件异步记录到缓冲区，当缓冲区已满时等待。可以设置插件不等待（`PERFORMANCE`），或使用文件系统缓存同步记录（`SEMISYNCHRONOUS`），或在每个写请求后调用 `sync()` 强制输出（`SYNCHRONOUS`）。

对于异步写入策略，`audit_log_buffer_size` 系统变量是缓冲区大小（以字节为单位）。在服务器启动时设置此变量以更改缓冲区大小。插件使用单个缓冲区，在初始化时分配，在终止时移除。对于非异步写入策略，插件不分配此缓冲区。

异步日志记录策略具有以下特征：

- 对服务器性能和可扩展性的影响最小。
- 生成审计事件的线程被阻塞的时间最短；即分配缓冲区的时间加上将事件复制到缓冲区的时间。
- 输出到缓冲区。一个单独的线程处理从缓冲区到日志文件的写入。

对于异步日志记录，如果在写入文件期间发生问题或插件未正常关闭（例如，在服务器主机意外退出的情况下），日志文件的完整性可能会受到损害。为了降低这种风险，请将 `audit_log_strategy` 设置为使用同步日志记录。

`PERFORMANCE` 策略的缺点是当缓冲区已满时会丢弃事件。对于负载较重的服务器，审计日志可能会缺少事件。