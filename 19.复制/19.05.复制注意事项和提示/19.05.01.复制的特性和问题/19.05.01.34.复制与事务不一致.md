#### 19.5.1.34 复制与事务不一致性

从中继日志执行的事务序列中出现的不一致可能取决于您的复制配置。本节解释了如何避免不一致性和解决它们造成的任何问题。

可能存在以下类型的不一致：

- **半应用事务**：更新非事务性表的事务已应用了一些但不是全部更改。

- **间隙**：当按事务顺序给出时，序列中后来的事务在先于该序列中的其他事务之前被应用时，外部化事务集中会出现间隙。当使用多线程副本时，才会出现间隙。

  为了避免多线程副本上出现间隙，请设置 `replica_preserve_commit_order=ON`（从 MySQL 8.0.26 开始）或 `slave_preserve_commit_order=ON`（在 MySQL 8.0.26 之前）。从 MySQL 8.0.27 开始，此设置为默认值，因为从该版本开始所有副本默认为多线程。

  直到 MySQL 8.0.18 为止，保留提交顺序要求启用二进制日志 (`log_bin`) 和副本更新日志 (`log_replica_updates` 或 `log_slave_updates`），这是从 MySQL 8.0 开始的默认设置。从 MySQL 8.0.19 开始，在副本上设置 `replica_preserve_commit_order=ON` 或 `slave_preserve_commit_order=ON` 时，不需要在副本上启用二进制日志和副本更新日志，并且如果需要，可以禁用它们。

  在所有版本中，设置 `replica_preserve_commit_order=ON` 或 `slave_preserve_commit_order=ON` 要求将 `replica_parallel_type`（从 MySQL 8.0.26 开始）或 `slave_parallel_type`（在 MySQL 8.0.26 之前）设置为 `LOGICAL_CLOCK`。从 MySQL 8.0.27 开始（但不适用于更早的版本），这是默认设置。

  在一些特定情况下，如 `replica_preserve_commit_order` 和 `slave_preserve_commit_order` 的描述中所列，设置 `replica_preserve_commit_order=ON` 或 `slave_preserve_commit_order=ON` 无法在副本上保留提交顺序，因此在这些情况下，副本的中继日志中执行的事务序列仍可能出现间隙。

  设置 `replica_preserve_commit_order=ON` 或 `slave_preserve_commit_order=ON` 并不防止源二进制日志位置滞后。

- **源二进制日志位置滞后**：即使没有间隙，也有可能在 `Exec_master_log_pos` 之后的事务已被应用。也就是说，直到点 N 的所有事务都已被应用，且在 N 之后没有事务被应用，但 `Exec_master_log_pos` 的值小于 N。在这种情况下，`Exec_master_log_pos` 是应用事务的“低水位标记”，且落后于最近应用事务的位置。这只会在多线程副本上发生。启用 `replica_preserve_commit_order` 或 `slave_preserve_commit_order` 并不防止源二进制日志位置滞后。

相关的场景包括半应用事务、间隙和源二进制日志位置滞后：

1. 当复制线程正在运行时，可能会有间隙和半应用事务。
2. mysqld 关闭。无论是干净关闭还是非干净关闭，都会中止正在进行的事务，并可能留下间隙和半应用事务。
3. 杀死复制线程（使用单线程副本时的 SQL 线程，使用多线程副本时的协调器线程）。这将中止正在进行的事务，并可能留下间隙和半应用事务。

4. 应用程序线程中的错误。这可能会留下间隙。如果错误发生在混合事务中，那么该事务是半应用的。使用多线程副本时，未收到错误的工作线程完成其队列，因此可能需要时间停止所有线程。
5. 使用 `STOP REPLICA` 时使用多线程副本。发出 `STOP REPLICA` 后，副本会等待填补任何间隙，然后更新 `Exec_master_log_pos`。这确保它永远不会留下间隙或源二进制日志位置滞后，除非上述情况之一适用，换句话说，在 `STOP REPLICA` 完成之前，发生错误，或另一个线程发出 KILL，或服务器重新启动。在这些情况下，`STOP REPLICA` 成功返回。
