19.5.1.25 复制与 REPAIR TABLE

源和副本的表不必完全相同。源表可以比副本表多或少一些列。此外，源表和副本表中相应的列可以使用不同的数据类型，但需要满足一定条件。

注意：不支持在分区方式不同的表之间进行复制。有关详细信息，请参见第19.5.1.24节，“复制与分区”。

在所有源表和目标表定义不完全相同的情况下，数据库和表名在源和副本上必须相同。以下两节将讨论其他条件并提供示例。

19.5.1.9.1 在源或副本上具有更多列的复制

您可以复制表从源到副本，使得源和副本的表拥有不同数量的列，但需遵守以下条件：

- 两个版本的表中共有的列必须在源和副本上以相同的顺序定义。（即使两个表的列数相同，也是如此。）

- 两个版本的表中共有的列必须在任何额外列之前定义。

这意味着，在副本上执行一个 `ALTER TABLE` 语句，在两个表共有的列范围内插入新列会导致复制失败，如下例所示：

假设在源和副本上存在一个表 t，由以下 `CREATE TABLE` 语句定义：

```sql
CREATE TABLE t (
    c1 INT,
    c2 INT,
    c3 INT
);
```

假设在副本上执行以下 `ALTER TABLE` 语句：

```sql
ALTER TABLE t ADD COLUMN cnew1 INT AFTER c3;
```

上述 `ALTER TABLE` 在副本上是允许的，因为 c1、c2 和 c3 这些在两个版本的表 t 中共有的列保持在一起，在两个版本的表中都在任何不同列之前。

然而，以下 `ALTER TABLE` 语句不能在副本上执行而不导致复制中断：

```sql
ALTER TABLE t ADD COLUMN cnew2 INT AFTER c2;
```

在副本上执行上述 `ALTER TABLE` 语句后，复制失败，因为新列 cnew2 出现在两个版本的 t 中共有的列之间。

拥有更多列的表版本中的每个“额外”列都必须有一个默认值。

列的默认值由多个因素确定，包括其类型、是否用 DEFAULT 选项定义、是否声明为 NULL，以及创建时生效的服务器 SQL 模式；有关更多信息，请参见第 13.6 节，“数据类型默认值”。

此外，当副本的表比源的表多列时，表中共有的每列在两个表中都必须使用相同的数据类型。

示例。以下示例说明了一些有效和无效的表定义：

源上的更多列。以下表定义有效且可正确复制：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
replica> CREATE TABLE t1 (c1 INT, c2 INT);
```

以下表定义会引发错误，因为两个版本的表中共有的列在副本上的定义顺序与源上不同：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
replica> CREATE TABLE t1 (c2 INT, c1 INT);
```

以下表定义也会引发错误，因为源上额外列的定义出现在两个版本的表中共有的列定义之前：

```sql
source> CREATE TABLE t1 (c3 INT, c1 INT, c2 INT);
replica> CREATE TABLE t1 (c1 INT, c2 INT);
```

副本上的更多列。以下表定义有效且可正确复制：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT);
replica> CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
```

以下定义引发错误，因为两

个版本的表中共有的列在源和副本上的定义顺序不同：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT);
replica> CREATE TABLE t1 (c2 INT, c1 INT, c3 INT);
```

以下表定义也会引发错误，因为副本版本的表中额外列的定义出现在两个版本的表中共有的列定义之前：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT);
replica> CREATE TABLE t1 (c3 INT, c1 INT, c2 INT);
```

以下表定义失败，因为副本的版本的表比源的版本多出列，并且两个版本的表对于共有的列 c2 使用了不同的数据类型：

```sql
source> CREATE TABLE t1 (c1 INT, c2 BIGINT);
replica> CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
```

19.5.1.9.2 复制具有不同数据类型的列

源的副本和副本的相同表的对应列理想情况下应具有相同的数据类型。然而，这并不总是严格执行的，只要满足某些条件即可。

通常可以从给定数据类型的列复制到同一类型和相同或更大尺寸的另一列。例如，您可以从 `CHAR(10)` 列复制到另一个 `CHAR(10)` 列，或从 `CHAR(10)` 列复制到 `CHAR(25)` 列而没有任何问题。在某些情况下，也可以从源的一种数据类型的列复制到副本的另一种数据类型的列；当源的列的数据类型在副本上提升至相同大小或更大时，这被称为属性提升。

属性提升可以在基于语句的复制和基于行的复制中使用，并且不依赖于源或副本使用的存储引擎。然而，日志记录格式的选择确实会影响允许的类型转换；具体细节将在本节后面讨论。

重要
无论您使用基于语句的复制还是基于行的复制，如果您希望使用属性提升，则副本的表副本不能包含比源的表副本更多的列。

基于语句的复制。使用基于语句的复制时，一个简单的经验规则是：“如果在源上运行的语句也能在副本上成功执行，那么它也应该能成功复制”。换句话说，如果语句使用的值与副本上某列的类型兼容，则可以复制该语句。例如，任何适合 `TINYINT` 列的值也可以插入到 `BIGINT` 列中；这意味着，即使您在副本的表副本中将 `TINYINT` 列的类型更改为 `BIGINT`，在源上成功插入该列的任何插入也应在副本上成功，因为不可能有一个合法的 `TINYINT` 值大到超过 `BIGINT` 列。

基于行的复制：属性提升和降级。基于行的复制支持在较小和较大数据类型之间进行属性提升和降级。还可以指定是否允许对降级列值进行有损（截断）或无损转换，这将在本节后面解释。

有损和无损转换。在目标类型无法表示要插入的值的情况下，必须决定如何处理转换。如果我们允许转换但截断（或以其他方式修改）源值以适应目标列，则进行的是所谓的有损转换。不需要截断或类似修改以使源列值适应目标列的转换是无

损转换。

类型转换模式。系统变量 `replica_type_conversions`（从 MySQL 8.0.26 开始）或 `slave_type_conversions`（在 MySQL 8.0.26 之前）的全球值控制副本上使用的类型转换模式。