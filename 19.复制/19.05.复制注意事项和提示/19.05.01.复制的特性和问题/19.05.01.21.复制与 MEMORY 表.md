### 19.5.1.21 复制与 `MEMORY` 表

当复制源服务器关闭并重启时，其 `MEMORY` 表会变为空。为了将这种效果复制到副本，源在启动后首次使用给定的 `MEMORY` 表时，它会记录一个事件，通知副本必须通过写入该表的 `DELETE` 或（从 MySQL 8.0.22 开始）`TRUNCATE TABLE` 语句到二进制日志来清空表。这个生成的事件可以通过二进制日志中的注释来识别，如果服务器上使用了 GTID，它将被分配一个 GTID。该语句始终以语句格式记录，即使二进制日志格式设置为 `ROW`，并且即使服务器设置为 `read_only` 或 `super_read_only` 模式也会写入。请注意，在源重启与其首次使用表之间的时间间隔内，副本中的 `MEMORY` 表仍包含过时数据。为避免直接查询副本可能返回陈旧数据的间隔，您可以设置 `init_file` 系统变量来指定一个包含在启动时填充源上 `MEMORY` 表的语句的文件。

当副本服务器关闭并重启时，其 `MEMORY` 表会变为空。这会导致副本与源不同步，可能导致其他故障或使副本停止：

- 从源接收的基于行格式的更新和删除可能会因为找不到 'memory_table' 中的记录而失败。
- 诸如 `INSERT INTO ... SELECT FROM memory_table` 的语句可能在源和副本上插入不同的行集。

副本还会将 `DELETE` 或（从 MySQL 8.0.22 开始）`TRUNCATE TABLE` 语句写入其自己的二进制日志，传递给任何下游副本，导致它们清空自己的 `MEMORY` 表。

重启正在复制 `MEMORY` 表的副本的安全方式是首先在源上删除或清空所有 `MEMORY` 表中的行，并等待这些更改复制到副本。然后重启副本是安全的。

在某些情况下，可能适用另一种重启方法。当 `binlog_format=ROW` 时，如果在再次启动副本之前设置 `replica_exec_mode=IDEMPOTENT`（从 MySQL 8.0.26 开始）或 `slave_exec_mode=IDEMPOTENT`（在 MySQL 8.0.26 之前），可以防止副本停止。这允许副本继续复制，但其 `MEMORY` 表的内容仍然与源不同。如果应用逻辑是可以安全地丢失 `MEMORY` 表的内容（例如，如果 `MEMORY` 表用于缓存），这是可以接受的。`replica_exec_mode=IDEMPOTENT` 或 `slave_exec_mode=IDEMPOTENT` 适用于所有表，因此它可能隐藏非 `MEMORY` 表中的其他复制错误。

`MEMORY` 表的大小受 `max_heap_table_size` 系统变量的限制，该变量不被复制（参见第 19.5.1.39 节，“复制与变量”）。在源上增加此变量的值而不在副本上这样做，可能会导致源上的表比副本上的对应表更大，导致在源上成功的插入在副本上失败并出现“Table is full”错误。这是一个已知问题（Bug #48666）。在这种情况下，您必须在副本上也设置 `max_heap_table_size` 的全局值，然后重启复制。还建议您重新启动源和副本的 MySQL 服务器，以确保新值在每个服务器上完全（全局）生效。

有关 `MEMORY`

 表的更多信息，请参见第 18.3 节，“MEMORY 存储引擎”。