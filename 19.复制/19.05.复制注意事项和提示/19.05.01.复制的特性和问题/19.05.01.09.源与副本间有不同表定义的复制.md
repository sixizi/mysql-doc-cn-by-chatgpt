#### 19.5.1.9 源与副本间有不同表定义的复制

源和目标表在复制过程中不必完全相同。源表可以比副本表多或少一些列。此外，源表和副本表对应的列可以使用不同的数据类型，但需满足某些条件。

> **注意**
>
> 不支持在彼此分区不同的表之间进行复制。详见第 19.5.1.24 节，“复制与分区”。

在所有源表和目标表定义不一致的情况下，数据库和表名称必须在源和副本上相同。以下两个部分将讨论额外的条件，并提供示例。

##### 19.5.1.9.1 在源或副本上具有更多列的复制

您可以从源复制到副本，使得源和副本的表拥有不同数量的列，但需遵守以下条件：

- 两个版本表中共有的列必须在源和副本上以相同的顺序定义。（即使两个表的列数相同，也是如此。）

- 两个版本表中共有的列必须在任何额外列之前定义。

  这意味着，在副本上执行 `ALTER TABLE` 语句，在两个表共有的列范围内插入新列会导致复制失败，如下例所示：

  假设在源和副本上存在表 t，由以下 `CREATE TABLE` 语句定义：

    ```sql
    CREATE TABLE t (
        c1 INT,
        c2 INT,
        c3 INT
    );
    ```

  假设在副本上执行以下 `ALTER TABLE` 语句：

  ```sql
  ALTER TABLE t ADD COLUMN cnew1 INT AFTER c3;
  ```

  因为 c1、c2 和 c3 这些在两个版本的表 t 中共有的列依然保持在一起，所以上述的 `ALTER TABLE` 在副本上是允许的，这些列在表中的顺序在两个版本中没有改变。

  然而，以下 `ALTER TABLE` 语句不能在副本上执行，否则会导致复制中断：

  ```sql
  ALTER TABLE t ADD COLUMN cnew2 INT AFTER c2;
  ```

  复制会在执行上述的 `ALTER TABLE` 后失败，因为新列 cnew2 出现在两个版本的 t 中共有的列之间。

- 表中拥有更多列的版本的每个“额外”列都必须有默认值。

  列的默认值由多个因素决定，包括其类型、是否用 DEFAULT 选项定义、是否声明为 NULL，以及创建时有效的服务器 SQL 模式；更多信息请参见第 13.6 节，“数据类型默认值”。

此外，当副本的表比源的表多列时，表中共有的每列在两个表中都必须使用相同的数据类型。

**示例。**以下示例说明了一些有效和无效的表定义：

**源上的更多列。**以下表定义有效且可正确复制：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
replica> CREATE TABLE t1 (c1 INT, c2 INT);
```

以下表定义会引发错误，因为两个版本的表中共有的列在副本上的定义顺序与源上不同：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
replica> CREATE TABLE t1 (c2 INT, c1 INT);
```

以下表定义也会引发错误，因为源上额外列的定义出现在两个版本的表中共有的列定义之前：

```sql
source> CREATE TABLE t1 (c3 INT, c1 INT, c2 INT);
replica> CREATE TABLE t1 (c1 INT, c2 INT);
```

**副本上的更多列。**以下表定义有效且可正确复制：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT);
replica> CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
```

以下定义引发错误，因为两个版本的表中共有的列在源和副本上的定义顺序不同：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT);
replica> CREATE TABLE t1 (c2 INT, c1 INT, c3 INT);
```

以下表定义也会引发错误，因为副本版本的表中额外列的定义出现在两个版本的表中共有的列定义之前：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT);
replica> CREATE TABLE t1 (c3 INT, c1 INT, c2 INT);
```

以下表定义失败，因为副本的版本的表比源的版本多出列，并且两个版本的表对于共有的列 c2 使用了不同的数据类型：

```sql
source> CREATE TABLE t1 (c1 INT, c2 BIGINT);
replica> CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
```

##### 19.5.1.9.2 复制中具有不同数据类型的列

源表与副本表中对应的列在理想情况下应具有相同的数据类型。然而，这并不总是严格执行的，只要满足某些条件即可。

通常可以将给定数据类型的列复制到同类型且相同或更大尺寸的另一列。例如，可以从 `CHAR(10)` 列复制到另一个 `CHAR(10)` 列，或从 `CHAR(10)` 列复制到 `CHAR(25)` 列，而不会有任何问题。在某些情况下，也可以从源中的一种数据类型的列复制到副本中的另一种数据类型的列；当源表中列的数据类型在副本上提升至相同大小或更大时，这称为属性提升。

属性提升可以在基于语句的复制和基于行的复制中使用，并且不依赖于源或副本使用的存储引擎。然而，日志记录格式的选择确实会影响允许的类型转换；具体细节将在本节后面讨论。

> **重要**
>
> 无论使用基于语句的复制还是基于行的复制，如果希望使用属性提升，副本的表不能包含比源表更多的列。

**基于语句的复制。**使用基于语句的复制时，一个简单的经验规则是：“如果在源上运行的语句也能在副本上成功执行，那么它应该也能成功复制”。换句话说，如果语句使用的值与副本上某列的类型兼容，该语句可以被复制。例如，任何适合 `TINYINT` 列的值也可以插入到 `BIGINT` 列中；这意味着，即使你在副本的表中将 `TINYINT` 列的类型更改为 `BIGINT`，在源上成功插入该列的任何操作也应在副本上成功，因为不可能有一个合法的 `TINYINT` 值大到超过 `BIGINT` 列。

**基于行的复制：属性提升和降级。**基于行的复制支持在较小和较大数据类型之间进行属性提升和降级。也可以指定是否允许对降级列值进行有损（截断）或无损转换，这将在本节后面解释。

**有损和无损转换。**如果目标类型无法表示被插入的值，必须决定如何处理转换。如果我们允许转换但截断（或以其他方式修改）源值以适应目标列，则进行的是所谓的有损转换。不需要截断或类似修改即可使源列值适应目标列的转换是无损转换。

**类型转换模式。**系统变量 `replica_type_conversions`（从 MySQL 8.0.26 开始）或 `slave_type_conversions`（在 MySQL 8.0.26 之前）的全局值控制副本上使用的类型转换模式。此变量从以下列表中取值，描述了每种模式对副本的类型转换行为的影响：

- **ALL_LOSSY**
  
  在此模式下，允许可能导致信息丢失的类型转换。
  
  这并不意味着允许无损转换，仅意味着允许需要有损转换或根本不需要转换的情况；例如，仅启用此模式允许将 `INT` 列转换为 `TINYINT`（有损转换），但不允许将 `TINYINT` 列转换为 `INT`（无损）。尝试后者的转换将导致副本上的复制停止并出现错误。

- **ALL_NON_LOSSY**
  
  此模式允许不需要截断或对源值进行其他特殊处理的转换；即允许目标类型比源类型有更广范围的转换。
  
  设置此模式不影响是否允许有损转换；这由 ALL_LOSSY 模式控制。如果仅设置了 ALL_NON_LOSSY 而不是 ALL_LOSSY，则尝试会导致数据丢失的转换（例如 `INT` 到 `TINYINT`，或 `CHAR(25)` 到 `VARCHAR(20)`）会使副本停止并报错。
  
- **ALL_LOSSY, ALL_NON_LOSSY**
  
  当设置此模式时，允许所有支持的类型转换，无论它们是否有损转换。
  
- **ALL_SIGNED**
  
  将提升的整数类型视为有符号值（默认行为）。
  
- **ALL_UNSIGNED**
  
  将提升的整数类型视为无符号值。
  
- **ALL_SIGNED, ALL_UNSIGNED**
  
  如果可能，将提升的整数类型视为有符号，否则视为无符号。
  
- **[empty]**
  
  当没有设置 `replica_type_conversions` 或 `slave_type_conversions` 时，不允许任何属性提升或降级；这意味着源表和目标表的所有列必须是相同类型。
  
  此模式是默认设置。

更改类型转换模式需要重启副本并使用新的 `replica_type_conversions` 或 `slave_type_conversions` 设置。

**支持的转换。**以下列表显示了不同但相似数据类型之间的支持转换：

- 任何整数类型 `TINYINT`, `SMALLINT`, `MEDIUMINT`, `INT`, 和 `BIGINT` 之间的转换。

  这包括这些类型的有符号和无符号版本之间的转换。

  有损转换是通过将源值截断为目标列允许的最大（或最小）值来完成的。为了确保从无符号类型到有符号类型的无损转换，目标列必须足够大以容纳源列中的值范围。例如，可以将 `TINYINT UNSIGNED` 无损降级到 `SMALLINT`，但不能降级到 `TINYINT`.

- 任何小数类型 `DECIMAL`, `FLOAT`, `DOUBLE`, 和 `NUMERIC` 之间的转换。

  `FLOAT` 到 `DOUBLE` 是无损转换；`DOUBLE` 到 `FLOAT` 只能是有损处理。从 `DECIMAL(M,D)` 到 `DECIMAL(M',D')` 的转换，在 `D' >= D` 和 `(M'-D') >= (M-D)` 的情况下是无损的；对于 `M' < M`, `D' < D`, 或两者都小的情况，只能进行有损转换。

  对于任何小数类型，如果无法将要存储的值适应目标类型，则根据服务器文档中定义的规则向下舍入该值。有关此操作的详细信息，请参阅第 14.24.4 节，“舍入行为”。

- 任何字符串类型 `CHAR`, `VARCHAR`, 和 `TEXT`，包括不同宽度之间的转换。

  将 `CHAR`, `VARCHAR`, 或 `TEXT` 转换为同等大小或更大的 `CHAR`, `VARCHAR`, 或 `TEXT` 列从未有损。有损转换是通过在副本上插入目标列宽度 N 的前 N 个字符来处理的。

  > **重要**
  > 不支持使用不同字符集的列之间的复制。

- 任何二进制数据类型 `BINARY`, `VARBINARY`, 和 `BLOB`，包括不同宽度之间的转换。

  将 `BINARY`, `VARBINARY`, 或 `BLOB` 转换为同等大小或更大的 `BINARY`, `VARBINARY`, 或 `BLOB` 列从未有损。有损转换是通过在副本上插入目标列宽度 N 的前 N 个字节来处理的。

- 任何两个大小的 `BIT` 列之间的转换。

  当从 `BIT(M)` 列插入值到 `BIT(M')` 列，其中 `M' > M` 时，`BIT(M')` 列的最高有效位被清除（设为零），并将 `BIT(M)` 的 M 位设为 `BIT(M')` 列的最低有效位。

  当从源 `BIT(M)` 列插入值到目标 `BIT(M')` 列，其中 `M' < M` 时，为 `BIT(M')` 列分配最大可能值；换句话说，为目标列分配“全设”值。

未在上述列表中的类型之间的转换不被允许。