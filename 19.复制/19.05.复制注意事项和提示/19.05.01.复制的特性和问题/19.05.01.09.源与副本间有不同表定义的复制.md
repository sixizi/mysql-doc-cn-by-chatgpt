### 19.5.1.9 使用不同表定义进行复制

源和目标表在复制过程中不必完全相同。源表可以比副本表多或少一些列。此外，源表和副本表对应的列可以使用不同的数据类型，但需满足某些条件。

> **注意**
> 不支持在彼此分区不同的表之间进行复制。详见第 19.5.1.24 节，“复制与分区”。

在所有源表和目标表定义不一致的情况下，数据库和表名称必须在源和副本上相同。以下两个部分将讨论额外的条件，并提供示例。

#### 19.5.1.9.1 在源或副本上具有更多列的复制

您可以从源复制到副本，使得源和副本的表拥有不同数量的列，但需遵守以下条件：

- 两个版本表中共有的列必须在源和副本上以相同的顺序定义。（即使两个表的列数相同，也是如此。）

- 两个版本表中共有的列必须在任何额外列之前定义。

这意味着，在副本上执行 `ALTER TABLE` 语句，在两个表共有的列范围内插入新列会导致复制失败，如下例所示：

假设在源和副本上存在表 t，由以下 `CREATE TABLE` 语句定义：

```sql
CREATE TABLE t (
    c1 INT,
    c2 INT,
    c3 INT
);
```

假设在副本上执行以下 `ALTER TABLE` 语句：

```sql
ALTER TABLE t ADD COLUMN cnew1 INT AFTER c3;
```

因为 c1、c2 和 c3 这些在两个版本的表 t 中共有的列依然保持在一起，所以上述的 `ALTER TABLE` 在副本上是允许的，这些列在表中的顺序在两个版本中没有改变。

然而，以下 `ALTER TABLE` 语句不能在副本上执行，否则会导致复制中断：

```sql
ALTER TABLE t ADD COLUMN cnew2 INT AFTER c2;
```

复制会在执行上述的 `ALTER TABLE` 后失败，因为新列 cnew2 出现在两个版本的 t 中共有的列之间。

表中拥有更多列的版本的每个“额外”列都必须有默认值。

列的默认值由多个因素决定，包括其类型、是否用 DEFAULT 选项定义、是否声明为 NULL，以及创建时有效的服务器 SQL 模式；更多信息请参见第 13.6 节，“数据类型默认值”。

此外，当副本的表比源的表多列时，表中共有的每列在两个表中都必须使用相同的数据类型。

示例。以下示例说明了一些有效和无效的表定义：

源上的更多列。以下表定义有效且可正确复制：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
replica> CREATE TABLE t1 (c1 INT, c2 INT);
```

以下表定义会引发错误，因为两个版本的表中共有的列在副本上的定义顺序与源上不同：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
replica> CREATE TABLE t1 (c2 INT, c1 INT);
```

以下表定义也会引发错误，因为源上额外列的定义出现在两个版本的表中共有的列定义之前：

```sql
source> CREATE TABLE t1 (c3 INT, c1 INT, c2 INT);
replica> CREATE TABLE t1 (c1 INT, c2 INT);
```

副本上的更多列。以下表定义有效且可正确复制：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT);
replica> CREATE TABLE

 t1 (c1 INT, c2 INT, c3 INT);
```

以下定义引发错误，因为两个版本的表中共有的列在源和副本上的定义顺序不同：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT);
replica> CREATE TABLE t1 (c2 INT, c1 INT, c3 INT);
```

以下表定义也会引发错误，因为副本版本的表中额外列的定义出现在两个版本的表中共有的列定义之前：

```sql
source> CREATE TABLE t1 (c1 INT, c2 INT);
replica> CREATE TABLE t1 (c3 INT, c1 INT, c2 INT);
```

以下表定义失败，因为副本的版本的表比源的版本多出列，并且两个版本的表对于共有的列 c2 使用了不同的数据类型：

```sql
source> CREATE TABLE t1 (c1 INT, c2 BIGINT);
replica> CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
```