### 19.2.3.2 监控复制应用器工作线程

在多线程副本上，性能模式表`replication_applier_status_by_coordinator`和`replication_applier_status_by_worker`分别显示副本的协调器线程和应用器工作线程的状态信息。对于有多个通道的副本，各通道的线程会被单独识别。

如果详细度设置为显示信息性消息，多线程副本的协调器线程还会定期将统计数据打印到副本的错误日志中。这些统计数据的打印取决于协调器线程分配给应用器工作线程的事件量，最大频率为每120秒一次。消息列出了相关复制通道或默认复制通道（未命名）的以下统计信息：

- **已过秒数**
  
  当前时间与上次将此信息打印到错误日志的时间之间的秒数差。
  
- **分配的事件**
  
  自协调器线程启动以来，它已将总事件数排队到所有应用器工作线程。
  
- **工作队列填充超过溢出级别**
  
  任何应用器工作线程队列中当前排队的事件数量超过了溢出级别，该级别设定为最大队列长度16384事件的90%。如果此值为零，则没有应用器工作线程在其容量上限运行。
  
- **由于工作队列满而等待**
  
  协调器线程因应用器工作线程的队列已满而不得不等待安排事件的次数。如果此值为零，则没有应用器工作线程用尽其容量。
  
- **由于总大小而等待**
  
  协调器线程因达到了`replica_pending_jobs_size_max`或`slave_pending_jobs_size_max`限制而不得不等待安排事件的次数。这个系统变量设定了应用器工作线程队列保存尚未应用的事件可用的最大内存量（以字节计）。如果一个异常大的事件超过了这个大小，事务将被保留，直到所有应用器工作线程的队列都为空，然后再处理。所有后续事务都将被保留，直到大事务完成。
  
- **时钟冲突下的等待**
  
  协调器线程因为事件所依赖的事务尚未提交而不得不等待调度事件的纳秒数。如果`replica_parallel_type`或`slave_parallel_type`设置为DATABASE（而不是LOGICAL_CLOCK），则此值始终为零。
  
- **工作线程占用时等待（计数）**
  
  协调器线程休眠的次数，这可能在两种情况下发生。第一种情况是协调器线程分配事件并发现应用器工作线程的队列已填充超过最大队列长度10%的欠载水平，在这种情况下，它最多休眠1毫秒。第二种情况是当`replica_parallel_type`或`slave_parallel_type`设置为LOGICAL_CLOCK且协调器线程需要将事务的第一个事件分配给应用器工作线程的队列时，它只分配给一个空队列的工作线程，所以如果没有队列是空的，协调器线程将休眠直到有一个变为空。
  
- **工作线程占用时等待**
  
  协调器线程在等待一个空的应用器工作线程队列时休眠的纳秒数（即上述第二种情况，当`replica_parallel_type`或`slave_parallel_type`设置为LOGICAL_CLOCK且需要分配事务的第一个事件时）。