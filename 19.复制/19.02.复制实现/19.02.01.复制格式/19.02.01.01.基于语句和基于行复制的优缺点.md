### 19.2.1.1 基于语句和基于行复制的优缺点

每种二进制日志格式都有其优点和缺点。对于大多数用户而言，混合复制格式应提供数据完整性和性能的最佳组合。然而，如果您想在执行某些任务时利用特定于基于语句或基于行复制格式的功能，您可以使用本节中提供的信息，该信息提供了它们相对优缺点的总结，以确定哪种最适合您的需求。

- [基于语句复制的优点](#基于语句复制的优点)
- [基于语句复制的缺点](#基于语句复制的缺点)
- [基于行复制的优点](#基于行复制的优点)
- [基于行复制的缺点](#基于行复制的缺点)

##### 基于语句复制的优点

- 已经证明的技术。
- 写入日志文件的数据更少。当更新或删除影响许多行时，这意味着日志文件所需的存储空间要少得多。这也意味着进行备份和从备份恢复可以更快完成。
- 日志文件包含了所有修改数据的语句，因此可以用来审计数据库。

##### 基于语句复制的缺点

- 对于 SBR 不安全的语句。并非所有修改数据的语句（如 INSERT、DELETE、UPDATE 和 REPLACE 语句）都可以使用基于语句的复制来复制。使用基于语句的复制时，任何非确定性行为都难以复制。例如，以下数据修改语言（DML）语句：
  - 依赖于可加载函数或存储程序的语句是不确定的，因为这样的函数或存储程序返回的值依赖于除了提供给它的参数之外的因素。（然而，基于行的复制仅复制函数或存储程序返回的值，因此其对表行和数据的影响在源和副本上是相同的。）更多信息，请参见第19.5.1.16节，“复制调用的功能”。

  - 使用 LIMIT 子句而没有 ORDER BY 的 DELETE 和 UPDATE 语句是不确定的。参见第19.5.1.18节，“复制和 LIMIT”。

  - 使用 NOWAIT 或 SKIP LOCKED 选项的锁定读语句（SELECT ... FOR UPDATE 和 SELECT ... FOR SHARE）。参见锁定读并发与 NOWAIT 和 SKIP LOCKED。

  - 在副本上必须应用确定性可加载函数。

  - 使用以下任何函数的语句无法使用基于语句的复制正确复制：
    - `LOAD_FILE()`
    - `UUID()`, `UUID_SHORT()`
    - `USER()`
    - `FOUND_ROWS()`
    - `SYSDATE()`（除非源和副本都以 `--sysdate-is-now` 选项启动）
    - `GET_LOCK()`
    - `IS_FREE_LOCK()`
    - `IS_USED_LOCK()`
    - `MASTER_POS_WAIT()`
    - `RAND()`
    - `RELEASE_LOCK()`
    - `SOURCE_POS_WAIT()`
    - `SLEEP()`
    - `VERSION()`
    
    然而，使用基于语句的复制，包括 `NOW()` 等所有其他函数都被正确复制。
    
    有关更多信息，请参见第19.5.1.14节，“复制与系统函数”。

  使用基于语句的复制无法正确复制的语句会记录一个类似于以下显示的警告：
  ```
  [Warning] Statement is not safe to log in statement format.
  ```
  在这种情况下，也会向客户端发出类似的警告。客户端可以使用 `SHOW WARNINGS` 显示它。

- `INSERT ... SELECT` 需要比基于行的复制更多的行级锁。

- 需要进行表扫描的 `UPDATE` 语句（因为 `WHERE` 子句中未使用索引）必须锁定比基于行的复制更多的行。

- 对于 InnoDB：使用 `AUTO_INCREMENT` 的 `INSERT` 语句会阻塞其他非冲突的 `INSERT` 语句。

  对于复杂的语句，必须在副本上评估并执行该语句，然后才能更新或插入行。使用基于行的复制时，副本只需修改受影响的行，而无需执行完整的语句。

  如果在副本上评估出现错误，特别是在执行复杂的语句时，基于语句的复制可能会随着时间的推移慢慢增加受影响行的错误幅度。有关更多信息，请参见第19.5.1.29节，“复制过程中的副本错误”。

  存储函数使用与调用语句相同的 `NOW()` 值执行。然而，存储过程则不是这样。

  确定性可加载函数必须在副本上应用。

  源和副本上的表定义必须（几乎）相同。有关更多信息，请参见第19.5.1.9节，“源和副本上具有不同表定义的复制”。

  截至 MySQL 8.0.22，从 MySQL 授权表（通过联接列表或子查询）读取数据但不修改它们的 DML 操作作为对 MySQL 授权表的非锁定读取执行，因此不适用于基于语句的复制。有关更多信息，请参见授权表并发性。

##### 基于行复制的优点

- 所有更改都可以被复制。这是最安全的复制形式。

  > **注意**
  >
  > 更新 mysql 系统模式中的信息的语句，如 GRANT、REVOKE 以及触发器、存储的例程（包括存储过程）和视图的操作，都使用基于语句的复制复制到副本。

对于以下类型的语句，源上需要的行锁更少，因此能够实现更高的并发性：

- `INSERT ... SELECT`
- 带有 `AUTO_INCREMENT` 的 `INSERT` 语句
- 带有 `WHERE` 子句的 `UPDATE` 或 `DELETE` 语句，这些子句不使用键或不更改大多数已检查的行。

对于任何 `INSERT`、`UPDATE` 或 `DELETE` 语句，在副本上需要的行锁更少。

##### 基于行复制的缺点

- RBR 可能会生成更多必须记录的数据。为了复制 DML 语句（如 UPDATE 或 DELETE 语句），基于语句的复制只将语句写入二进制日志。相比之下，基于行的复制将每个更改的行写入二进制日志。如果语句更改了许多行，基于行的复制可能会将显著更多的数据写入二进制日志；即使对于回滚的语句也是如此。这也意味着进行备份和从备份恢复可能需要更多时间。此外，为了写入数据，二进制日志被锁定更长时间，这可能会引起并发问题。使用 `binlog_row_image=minimal` 可以大大减少这种不利影响。

- 生成大型 BLOB 值的确定性可加载函数，使用基于行的复制复制所需的时间比使用基于语句的复制更长。这是因为记录的是 BLOB 列值，而不是生成数据的语句。

- 在副本上，您无法看到从源接收并执行的语句是什么。然而，您可以使用 mysqlbinlog 与选项 `--base64-output=DECODE-ROWS` 和 `--verbose` 查看哪些数据发生了变化。

  或者，使用 `binlog_rows_query_log_events` 变量，如果启用，当使用 `-vv` 选项时，它会将带有语句的 Rows_query 事件添加到 mysqlbinlog 输出中。

- 对于使用 MyISAM 存储引擎的表，在将 INSERT 语句作为基于行的事件应用到二进制日志时，相比作为语句应用，副本上需要更强的锁。这意味着在使用基于行的复制时，不支持 MyISAM 表上的并发插入。