#### 19.4.1.3 通过设置为只读来备份源或副本

通过获取全局读锁并操纵 `read_only` 系统变量来改变服务器的只读状态，可以备份复制设置中的源或副本服务器：

1. 将服务器设置为只读，使其仅处理检索操作并阻止更新。
2. 执行备份。
3. 将服务器恢复到其正常的读/写状态。

    > **注意**
    >
    > 本节中的说明将服务器置于安全的状态，适用于从服务器获取数据的备份方法，如 `mysqldump`（参见第 6.5.4 节，“`mysqldump` —— 一个数据库备份程序”）。您不应尝试使用这些指令来进行二进制备份，即直接复制文件，因为服务器可能仍有修改过的数据缓存在内存中并未刷新到磁盘。

以下说明描述了如何对源和副本执行此操作。在这里讨论的两种情况中，假设您有以下复制设置：

- 源服务器 S1
- 副本服务器 R1，其源为 S1
- 连接到 S1 的客户端 C1
- 连接到 R1 的客户端 C2

在任何情况下，获取全局读锁和操纵 `read_only` 变量的语句都是在要备份的服务器上执行的，不会传播到该服务器的任何副本。

**情景 1：使用只读源进行备份**

通过在源 S1 上执行以下语句，将其置于只读状态：

```sql
mysql> FLUSH TABLES WITH READ LOCK;
mysql> SET GLOBAL read_only = ON;
```

当 S1 处于只读状态时，以下属性为真：

- 由 C1 发送到 S1 的更新请求会被阻塞，因为服务器处于只读模式。
- 由 C1 发送到 S1 的查询请求会成功。
- 在 S1 上进行备份是安全的。
- 在 R1 上进行备份则不安全。这台服务器仍在运行，并可能正在处理来自客户端 C2 的二进制日志或更新请求。

当 S1 处于只读状态时，执行备份。例如，您可以使用 `mysqldump`。

备份操作在 S1 完成后，通过执行以下语句恢复 S1 到其正常运行状态：

```sql
mysql> SET GLOBAL read_only = OFF;
mysql> UNLOCK TABLES;
```

尽管在 S1 上进行备份在备份方面是安全的，但这并不是性能的最佳选择，因为 S1 的客户端被阻止执行更新。

这种策略适用于复制设置中的源备份，但也可用于非复制环境中的单个服务器。

**情景 2：使用只读副本进行备份**

通过在副本 R1 上执行以下语句，将其置于只读状态：

```sql
mysql> FLUSH TABLES WITH READ LOCK;
mysql> SET GLOBAL read_only = ON;
```

当 R1 处于只读状态时，以下属性为真：

- 源 S1 继续运行，因此在源上进行备份是不安全的。
- 副本 R1 已停止，因此在副本 R1 上进行备份是安全的。

这些属性为一个受欢迎的备份情景提供了基础：让一个副本忙于备份一段时间不是问题，因为它不会影响整个网络，系统在备份期间仍在运行。特别是，客户仍然可以在源服务器上进行更新，这些更新不受副本上备份活动的影响。

当 R1 处于只读状态时，执行备份。例如，您可以使用 `mysqldump`。

备份操作在 R1 完成后，通过执行以下语句恢复 R1 到其正常运行状态：

```sql
mysql> SET GLOBAL read_only = OFF;
mysql> UNLOCK TABLES;
```

在副本恢复正常运行后，它将通过赶上源的二进制日志中的任何未完成更新来重新同步到源。