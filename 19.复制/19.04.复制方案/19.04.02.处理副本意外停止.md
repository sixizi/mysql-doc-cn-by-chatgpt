### 19.4.2 处理副本意外停止

为了确保复制对服务器意外停止（有时描述为具备崩溃安全性）具有韧性，必须使副本能够在停止前恢复其状态。本节描述了复制过程中副本意外停止的影响，以及如何配置副本以最佳地恢复并继续复制。

在副本意外停止后，重新启动时复制 SQL 线程必须恢复关于哪些事务已执行的信息。恢复所需的信息存储在副本的应用程序元数据仓库中。从 MySQL 8.0 开始，此仓库默认创建为名为 `mysql.slave_relay_log_info` 的 InnoDB 表。通过使用这种事务性存储引擎，信息在重新启动后始终可以恢复。与事务一起提交对应用程序元数据仓库的更新，意味着记录在该仓库中的副本进度信息始终与已应用到数据库的内容一致，即使在副本服务器意外停止的情况下也是如此。有关应用程序元数据仓库的更多信息，请参见第 19.2.4 节，“中继日志和复制元数据仓库”。

DML 事务和原子 DDL 更新副本的应用程序元数据仓库中的 mysql.slave_relay_log_info 表中的复制位置，并与对数据库的更改一起作为一个原子操作应用。在所有其他情况下，包括不完全原子的 DDL 语句和不支持原子 DDL 的存储引擎，如果服务器意外停止，mysql.slave_relay_log_info 表可能会丢失与复制数据相关的更新。在这种情况下，恢复更新是一个手动过程。有关 MySQL 8.0 中原子 DDL 支持的详细信息以及某些语句复制的结果行为，请参见第 15.1.1 节，“原子数据定义语句支持”。

副本从意外停止中恢复的过程取决于副本的配置。恢复过程的细节受所选复制方法、副本是单线程还是多线程以及相关系统变量的设置的影响。恢复过程的总体目标是识别在意外停止发生前已经在副本数据库上应用的事务，并检索并应用副本错过的事务。

对于基于 GTID 的复制，恢复过程需要已被副本接收或提交的事务的 GTIDs。可以使用 GTID 自动定位从源检索缺失的事务，这会自动比较源的事务和副本的事务，并识别缺失的事务。

对于基于文件位置的复制，恢复过程需要准确的复制 SQL 线程（应用程序）位置，显示在副本上应用的最后一个事务。根据该位置，复制 I/O 线程（接收器）从源的二进制日志中检索从那点开始应在副本上应用的所有事务。

使用基于 GTID 的复制使配置复制对意外停止具有韧性变得最简单。GTID 自动定位意味着副本可以可靠地识别和检索缺失的事务，即使在应用事务序列中存在间隙。

以下信息提供了适合不同类型副本的设置组合，以确保在复制控制范围内尽可能保证恢复：

> **重要**
>
> 复制控制之外的一些因素可能会影响复制恢复过程和恢复过程后复制的总体状态。特别是，影响单个存储引擎恢复过程的设置可能导致副本意外停止事件中丢失事务，因此在复制恢复过程中无法使用。下面列表中提到的 `innodb_flush_log_at_trx_commit=1` 设置是使用 InnoDB 与事务的复制设置的关键设置。然而，特定于 InnoDB 或其他存储引擎的其他设置，尤其是与刷新或同步相关的设置，也可能有影响。始终检查并应用您选择的存储引擎关于崩溃安全设置的建议。

以下是副本对意外停止最具韧性的设置组合：

- 当使用基于 GTID 的复制时（`gtid_mode=ON`），设置 `SOURCE_AUTO_POSITION=1 | MASTER_AUTO_POSITION=1`，激活连接到源的 GTID 自动定位以自动识别和检索缺失的事务。这个选项使用 `CHANGE REPLICATION SOURCE TO` 语句（从 MySQL 8.0.23 开始）或 `CHANGE MASTER TO` 语句（在 MySQL 8.0.23 之前）设置。如果副本有多个复制通道，您需要为每个通道单独设置此选项。有关 GTID 自动定位的工作方式的详细信息，请参见第 19.1.3.3 节，“GTID 自动定位”。当使用基于文件位置的复制时，不使用 `SOURCE_AUTO_POSITION=1 | MASTER_AUTO_POSITION=1`，而是使用二进制日志位置或中继日志位置来控制复制的开始。

- 从 MySQL 8.0.27 开始，当使用基于 GTID 的复制时（`gtid_mode=ON`），设置 `GTID_ONLY=1`，使副本在恢复过程中仅使用 GTIDs，并停止在复制元数据仓库中持久化二进制日志和中继日志文件名及文件位置。这个选项使用 `CHANGE REPLICATION SOURCE TO` 语句设置。如果副本有多个复制通道，您需要为每个通道单独设置此选项。使用 `GTID_ONLY=1` 时，在恢复过程中，文件位置信息将被忽略，使用 GTID 自动跳过来跳过已经提供的事务，而不是识别正确的文件位置。这种策略在您使用默认设置 `relay_log_purge` 清除中继日志时更有效，这意味着只需要检查一个中继日志文件。

- 设置 `sync_relay_log=1`，指示复制接收线程在每次接收到事务并写入中继日志后同步中继日志到磁盘。这意味着副本从源二进制日志中读取的当前位置的记录（在应用程序元数据仓库中）永远不会超前于中继日志中保存的事务记录。注意，虽然这个设置是最安全的，但也是最慢的，因为涉及到的磁盘写入数量。当 `sync_relay_log > 1` 或 `sync_relay_log=0`（同步由操作系统处理）时，如果副本意外停止，可能有未同步到磁盘的已提交事务。这些事务可能会导致恢复过程失败，如果恢复的副本根据其在最后同步到磁盘的中继日志中的信息试图再次检索和应用这些事务而不是跳过它们。对于多线程副本来说，如果事务序列的间隙无法使用中继日志中的信息填补，恢复过程将失败，因此设置 `sync_relay_log=1` 特别重要。对于单线程副本，只有当相关信息不在应用程序元数据仓库中时，恢复过程才需要使用中继日志。

- 设置 `innodb_flush_log_at_trx_commit=1`，在每个事务提交前同步 InnoDB 日志到磁盘。这个设置是默认的，确保 InnoDB 表和 InnoDB 日志被保存在磁盘上，因此不再需要中继日志中关于事务的信息。结合 `sync_relay_log=1` 设置，这个设置进一步确保 InnoDB 表和 InnoDB 日志的内容始终与中继日志的内容一致，这样清除中继日志文件不会在副本意外停止的情况下在副本的事务历史中造成无法填补的间隙。

- 设置 `relay_log_info_repository = TABLE`，将复制 SQL 线程位置存储在 InnoDB 表 mysql.slave_relay_log_info 中，并与事务提交一起更新，以确保记录始终准确。这个设置从 MySQL 8.0 开始是默认的，FILE 设置已被弃用。从 MySQL 8.0.23 开始，使用系统变量本身已被弃用，因此省略它并让它默认。如果使用 FILE 设置，这是早期版本的默认设置，信息存储在数据目录中的一个文件中，在事务应用后更新。这会根据副本在处理事务的哪个阶段停止或甚至文件本身的损坏，创建与源失去同步的风险。使用 `relay_log_info_repository = FILE` 设置，恢复不是保证的。

- 设置 `relay_log_recovery = ON`，启用服务器启动后立即进行自动中继日志恢复。这个全局变量默认为 OFF，并在运行时为只读，但您可以在副本意外停止后的启动时使用 `--relay-log-recovery` 选项将其设置为 ON。请注意，这个设置忽略现有的中继日志文件，以防它们被损坏或不一致。中继日志恢复过程启动一个新的中继日志文件，并从记录在应用程序元数据仓库中的复制 SQL 线程位置开始从源获取事务。先前的中继日志文件随着时间的推移会被副本的正常清除机制移除。

对于多线程副本，设置 `relay_log_recovery = ON` 自动处理来自中继日志执行的事务序列中的任何不一致和间隙。当使用基于文件位置的复制时，这些间隙可能发生。（有关更多细节，请参见第 19.5.1.34 节，“复制和事务不一致性”）。中继日志恢复过程使用与 `START REPLICA UNTIL SQL_AFTER_MTS_GAPS`（或在 MySQL 8.0.22 之前，使用 `START SLAVE` 而不是 `START REPLICA`）语句相同的方法处理间隙。当副本达到一致且无间隙的状态时，中继日志恢复过程继续从源获取事务，从复制 SQL 线程位置开始。当使用基于 GTID 的复制时，从 MySQL 8.0.18 开始，多线程副本首先检查是否设置了 `MASTER_AUTO_POSITION` 为 ON，如果设置了，省略计算应跳过或不应跳过的事务的步骤，这样旧的中继日志就不需要用于恢复过程了。