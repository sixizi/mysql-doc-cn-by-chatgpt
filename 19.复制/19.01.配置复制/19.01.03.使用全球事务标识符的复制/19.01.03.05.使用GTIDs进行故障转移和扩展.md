#### 19.1.3.5 使用GTID进行故障转移和扩展

在使用全局事务标识符（GTID）的MySQL复制进行新副本的配置时，存在多种技术，这些副本随后可用于扩展，必要时可提升为源进行故障转移。本节描述了以下技术：

- [简单复制](#简单复制)
- [将数据和事务复制到副本](#将数据和事务复制到副本)
- [注入空事务](#注入空事务)
- [使用gtid_purged排除事务](#使用gtid_purged排除事务)
- [恢复GTID模式副本](#恢复GTID模式副本)

为了简化复制数据流的管理以及特别是故障转移活动，MySQL复制添加了全局事务标识符。每个标识符唯一地标识了一组共同构成一个事务的二进制日志事件。GTID在将更改应用到数据库中起着关键作用：服务器自动跳过具有服务器认为其之前已处理过的标识符的任何事务。这种行为对于自动复制定位和正确的故障转移至关重要。

标识符与构成给定事务的事件集之间的映射记录在二进制日志中。当使用另一个现有服务器的数据为新服务器配置数据时，这提出了一些挑战。为了在新服务器上重现标识符集，必须将标识符从旧服务器复制到新服务器，并保留标识符与实际事件之间的关系。这对于恢复一个副本是必要的，这个副本立即可用作在故障转移或切换时成为新源的候选。

##### 简单复制

在新服务器上重现所有标识符和事务的最简单方式是使新服务器成为具有整个执行历史的源的副本，并在两台服务器上启用全局事务标识符。有关更多信息，请参见19.1.3.4节，“使用GTID设置复制”。

一旦开始复制，新服务器就会从源复制整个二进制日志，从而获得所有GTID的所有信息。

这种方法简单有效，但需要副本从源读取二进制日志；新副本追上源有时需要相对较长的时间，因此这种方法不适用于快速故障转移或从备份恢复。本节解释了如何通过将二进制日志文件复制到新服务器来避免从源获取所有执行历史。

##### 将数据和事务复制到副本

当源服务器之前已处理大量事务时，执行整个事务历史可能非常耗时，这可能是设置新副本时的主要瓶颈。为了消除这个要求，可以将源服务器包含的数据集快照、二进制日志和全局事务信息导入到新副本。拍摄快照的服务器可以是源或其副本之一，但您必须确保服务器在复制数据之前已处理所有所需的事务。

这种方法有几种变体，区别在于数据转储和来自二进制日志的事务传输到副本的方式，如下所述：

###### 数据集

1. 在源服务器上使用mysqldump创建转储文件。设置mysqldump选项`--master-data`（默认值为1）以包含带有二进制日志信息的`CHANGE REPLICATION SOURCE TO | CHANGE MASTER TO`语句。设置`--set-gtid-purged`选项为AUTO（默认）或ON，以包含转储中执行的事务信息。然后使用mysql客户端在目标服务器上导入转储文件。

2. 或者，使用原始数据文件创建源服务器的数据快照，然后将这些文件复制到目标服务器，按照19.1.2.5节，“选择数据快照方法”的指示进行操作。如果您使用InnoDB表，可以使用MySQL Enterprise Backup组件中的mysqlbackup命令产生一致的快照。此命令记录了快照对应的日志名称和偏移量，以便在副本上使用。MySQL Enterprise Backup是MySQL企业订阅的一部分包含的商业产品。详细信息请参见32.1节，“MySQL企业备份概览”。

3. 或者，停止源和目标服务器，将源的数据目录内容复制到新副本的数据目录，然后重启副本。如果使用此方法，副本必须配置为基于GTID的复制，换句话说，要设置gtid_mode=ON。有关此方法的指示和重要信息，请参见19.1.2.8节，“向复制环境添加副本”。

###### 事务历史

如果源服务器的二进制日志中有完整的事务历史（即，GTID集`@@GLOBAL.gtid_purged`为空），您可以使用这些方法。

1. 使用mysqlbinlog将二进制日志从源服务器导入到新副本，使用`--read-from-remote-server`、`--read-from-remote-source`和`--read-from-remote-master`选项。

2. 或者，将源服务器的二进制日志文件复制到副本。您可以使用带有`--read-from-remote-server`和`--raw`选项的mysqlbinlog从副本复制文件。这些可以通过使用`mysqlbinlog > file`（没有`--raw`选项）将二进制日志文件导出到SQL文件，然后将这些文件传递给mysql客户端进行处理。确保使用单个mysql进程而不是多个连接处理所有二进制日志文件。例如：

   ```bash
   $> mysqlbinlog copied-binlog.000001 copied-binlog.000002 | mysql -u root -p
   ```

   有关更多信息，请参见6.6.9.3节，“使用mysqlbinlog备份二进制日志文件”。

这种方法的优点是新服务器几乎立即可用；只有在快照或转储文件被重放时提交的那些事务仍需要从现有源获取。这意味着副本的可用性不是即时的，但只需要相对较短的时间就可以让副本追上这些少量剩余的事务。

提前将二进制日志复制到目标服务器通常比实时从源读取整个事务执行历史更快。然而，由于大小或其他考虑，可能并非总是可行将这些文件移动到目标服务器。本节讨论的其余两种为新副本配置的方法使用其他方式将事务信息转移到新副本。

##### 注入空事务

源的全局gtid_executed变量包含在源上执行的所有事务的集合。与在拍摄快照以配置新服务器时复制二进制日志相比，您可以改为记录从中拍摄快照的服务器上gtid_executed的内容。在将新服务器添加到复制链之前，只需为源的gtid_executed中包含的每个事务标识符提交一个空事务，如下所示：

```sql
SET GTID_NEXT='aaa-bbb-ccc-ddd:N';

BEGIN;
COMMIT;

SET GTID_NEXT='AUTOMATIC';
```

一旦以这种方式使用空事务重新引入所有事务标识符，您必须刷新并清除副本的二进制日志，如下所示，其中N是当前二进制日志文件名的非零后缀：

```sql
FLUSH LOGS;
PURGE BINARY LOGS TO 'source-bin.00000N';
```

如果此服务器稍后被提升为源，则应该这样做以防止此服务器向复制流中发送虚假事务。（`FLUSH LOGS`语句强制创建一个新的二进制日志文件；`PURGE BINARY LOGS`清除空事务，但保留它们的标识符。）

这种方法创建了一个本质上是快照的服务器，但随着时间的推移能够成为源，因为其二进制日志历史与复制流的历史收敛（即，当它追上源或源时）。这种效果类似于使用剩余的配置方法获得的效果，我们将在接下来的几段中讨论。

##### 使用gtid_purged排除事务

源的全局gtid_purged变量包含已从源的二进制日志中清除的所有事务的集合。与前面讨论的方法（见注入空事务）一样，您可以记录从中拍摄快照的服务器上gtid_executed的值（代替将二进制日志复制到新服务器）。与前一种方法不同，无需提交空事务（或发出`PURGE BINARY LOGS`）；相反，您可以直接基于从中拍摄备份或快照的服务器上gtid_executed的值在副本上设置gtid_purged。

与使用空事务的方法一样，这种方法创建了一个功能上是快照的服务器，但随着时间的推移能够成为源，因为其二进制日志历史与源和其他副本的历史收敛。

##### 恢复GTID模式副本

在基于GTID的复制设置中恢复遇到错误的副本时，注入空事务可能无法解决问题，因为事件没有GTID。

使用mysqlbinlog找到下一个事务，这可能是事件后的下一个日志文件中的第一个事务。复制到该事务的`COMMIT`为止的所有内容，确保包括`SET @@SESSION.gtid_next`。即使您不使用基于行的复制，您仍然可以在命令行客户端中运行二进制日志行事件。

停止副本并运行您复制的事务。mysqlbinlog输出将分隔符设置为`/*!*/;`，因此将其设置回来：

```sql
mysql> DELIMITER ;
```

从正确的位置自动重新启动复制：

```sql
mysql> SET GTID_NEXT=automatic;
mysql> RESET SLAVE;
mysql> START SLAVE;
```

或从MySQL 8.0.22开始：

```sql
mysql> SET GTID_NEXT=automatic;
mysql> RESET REPLICA;
mysql> START REPLICA;
```