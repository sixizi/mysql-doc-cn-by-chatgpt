#### 19.1.3.2 GTID 生命周期

GTID的生命周期包括以下步骤：

1. 在源（原始服务器）上执行并提交一个事务。这个客户端事务被分配了一个由源的UUID和该服务器上尚未使用的最小非零事务序列号组成的GTID。GTID被写入源的二进制日志中（在日志中紧跟在事务本身之前）。如果客户端事务没有被写入二进制日志（例如，因为事务被过滤掉，或事务是只读的），则不会为其分配GTID。

2. 如果为事务分配了GTID，则通过在事务开始时将其写入二进制日志（作为Gtid_log_event）来在提交时原子性地持久化GTID。每当二进制日志轮换或服务器关闭时，服务器会将之前二进制日志文件中写入的所有事务的GTID写入`mysql.gtid_executed`表中。

3. 如果为事务分配了GTID，则通过在事务提交后很短时间内（非原子性地）将其添加到`gtid_executed`系统变量（@@GLOBAL.gtid_executed）中的GTID集合中来外部化GTID。此GTID集包含所有已提交GTID事务集的表示，并在复制中用作代表服务器状态的令牌。启用二进制日志记录（源所需）时，`gtid_executed`系统变量中的GTID集是已应用事务的完整记录，但`mysql.gtid_executed`表不是，因为最新的历史记录仍在当前二进制日志文件中。

4. 在二进制日志数据传输到副本并存储在副本的中继日志中（使用此过程的既定机制，详见第19.2节，“复制实现”，了解详情）后，副本读取GTID并将其`gtid_next`系统变量的值设置为此GTID。这告诉副本下一个事务必须使用此GTID进行日志记录。重要的是要注意，副本在会话上下文中设置`gtid_next`。

5. 副本验证尚未有线程取得`gtid_next`中的GTID的所有权来处理事务。通过在处理事务本身之前先读取并检查复制事务的GTID，副本不仅保证没有之前的事务使用此GTID已在副本上应用，而且也保证没有其他会话已经读取了此GTID但尚未提交关联的事务。因此，如果多个客户端尝试并发应用同一事务，服务器通过只让其中一个执行来解决这个问题。副本的`gtid_owned`系统变量（@@GLOBAL.gtid_owned）显示当前正在使用的每个GTID及其拥有者线程的ID。如果GTID已经被使用，不会引发错误，并使用自动跳过功能来忽略该事务。

6. 如果GTID尚未使用，副本应用复制的事务。因为`gtid_next`已设置为源分配的GTID，副本不尝试为此事务生成新的GTID，而是使用存储在`gtid_next`中的GTID。

7. 如果在副本上启用了二进制日志，通过在事务开始时将其写入二进制日志（作为Gtid_log_event）来在提交时原子性地持久化GTID。每当二进制日志轮换或服务器关闭时，服务器会将之前二进制日志文件中写入的所有事务的GTID写入`mysql.gtid_executed`表中。

8. 如果在副本上禁用了二进制日志，通过直接将GTID写入`mysql.gtid_executed`表来原子性地持久化GTID。MySQL在事务中附加一个语句来将GTID插入表中。从MySQL 8.0开始，对于DDL语句以及DML语句，此操作是原子性的。在这种情况下，`mysql.gtid_executed`表是副本上应用的事务的完整记录。

9. 在副本上提交复制事务后不久，通过将GTID添加到副本的`gtid_executed`系统变量（@@GLOBAL.gtid_executed）中的GTID集合中来非原子性地外部化GTID。对于源来说，此GTID集包含所有已提交GTID事务集的表示。如果在副本上禁用了二进制日志，`mysql.gtid_executed`表也是副本上应用的事务的完整记录。如果在副本上启用了二进制日志，意味着某些GTID仅记录在二进制日志中，`gtid_executed`系统变量中的GTID集是唯一的完整记录。

在源上完全过滤掉的客户端事务不会被分配GTID，因此它们不会被添加到`gtid_executed`系统变量中的事务集合中，也不会被添加到`mysql.gtid_executed`表中。然而，在副本上完全过滤掉的复制事务的GTID被持久化。如果在副本上启用了二进制日志，被过滤的事务作为Gtid_log_event写入二进制日志，后跟只包含BEGIN和COMMIT语句的空事务。如果在副本上禁用了二进制日志，被过滤的事务的GTID被写入`mysql.gtid_executed`表。保留被过滤事务的GTID确保了`mysql.gtid_executed`表和`gtid_executed`系统变量中的GTID集可以被压缩。它还确保如果副本重新连接到源，被过滤的事务不会再次被检索，如第19.1.3.3节“GTID自动定位”所解释的。

在多线程副本上（replica_parallel_workers > 0 或 slave_parallel_workers > 0），事务可以并行应用，因此复制的事务可以无序提交（除非设置了replica_preserve_commit_order=1 或 slave_preserve_commit_order=1）。当发生这种情况时，`gtid_executed`系统变量中的GTID集包含多个GTID范围，它们之间有间隙。（在源或单线程副本上，GTID是单调递增的，数字之间没有间隙。）多线程副本上的间隙仅出现在最近应用的事务中，并随着复制的进行而填补。当使用STOP REPLICA语句干净地停止复制线程时，正在进行的事务被应用以填补间隙。在服务器故障或使用KILL语句停止复制线程等关闭事件中，间隙可能会保留。