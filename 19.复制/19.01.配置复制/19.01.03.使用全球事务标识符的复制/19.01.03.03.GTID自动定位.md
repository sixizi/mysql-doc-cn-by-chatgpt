#### 19.1.3.3 GTID自动定位

GTID替代了之前用于确定数据流在源与副本间开始、停止或恢复的点所需的文件偏移对。当使用GTID时，副本同步到源所需的所有信息直接从复制数据流中获得。

要使用基于GTID的复制启动副本，你需要在`CHANGE REPLICATION SOURCE TO`语句中（从MySQL 8.0.23开始）或`CHANGE MASTER TO`语句中（MySQL 8.0.23之前）启用`SOURCE_AUTO_POSITION | MASTER_AUTO_POSITION`选项。替代的`SOURCE_LOG_FILE | MASTER_LOG_FILE`和`SOURCE_LOG_POS | MASTER_LOG_POS`选项指定日志文件的名称和文件内的起始位置，但使用GTID的副本不需要这种非本地数据。有关配置和使用基于GTID的复制启动源和副本的完整指南，请参见第19.1.3.4节，“使用GTID设置复制”。

`SOURCE_AUTO_POSITION | MASTER_AUTO_POSITION`选项默认是禁用的。如果在副本上启用了多源复制，你需要为每个适用的复制通道设置该选项。再次禁用`SOURCE_AUTO_POSITION | MASTER_AUTO_POSITION`选项会使副本恢复到基于位置的复制；这意味着，当`GTID_ONLY=ON`时，一些位置可能被标记为无效，在这种情况下，当禁用`SOURCE_AUTO_POSITION | MASTER_AUTO_POSITION`时，你也必须同时指定`SOURCE_LOG_FILE | MASTER_LOG_FILE`和`SOURCE_LOG_POS | MASTER_LOG_POS`。

当副本启用了GTID（`GTID_MODE=ON`、`ON_PERMISSIVE`或`OFF_PERMISSIVE`）并启用了`MASTER_AUTO_POSITION`选项时，会为连接到源激活自动定位。源必须设置`GTID_MODE=ON`以确保连接成功。在初始握手中，副本发送一个GTID集合，其中包含它已经接收、提交或两者都有的事务。这个GTID集合等于`gtid_executed`系统变量（`@@GLOBAL.gtid_executed`）中的GTID集的并集，以及在性能模式下复制连接状态表中记录为接收到的事务的GTID集（`SELECT RECEIVED_TRANSACTION_SET FROM PERFORMANCE_SCHEMA.replication_connection_status`语句的结果）。

源通过发送其二进制日志中记录的、GTID不包含在副本发送的GTID集中的所有事务来响应。为此，源首先通过检查其每个二进制日志文件的头部中的`Previous_gtids_log_event`来确定开始工作的适当二进制日志文件，从最近的一个开始。当源找到第一个不包含副本缺少的事务的`Previous_gtids_log_event`时，它就从那个二进制日志文件开始。这种方法是高效的，只有当副本落后于源大量二进制日志文件时，才会花费显著的时间。然后，源读取那个二进制日志文件和随后的文件中的事务，发送副本缺少的GTID的事务，并跳过副本发送的GTID集中已有的事务。副本接收到第一个缺失事务的时间取决于它在二进制日志文件中的偏移量。这种交换确保源只发送副本尚未接收或提交的GTID的事务。如果副本从多个源接收事务，如在菱形拓扑中，自动跳过功能确保事务不会被重复应用。

如果源的二进制日志中应由源发送的任何事务已被清除，或通过其他方法添加到`gtid_purged`系统变量中的GTID集中，源会向副本发送错误`ER_MASTER_HAS_PURGED_REQUIRED_GTIDS`，并且复制不会启动。缺失的已清除事务的GTID在源的错误日志中的警告消息`ER_FOUND_MISSING_GTIDS`中被识别并列出。副本不能自动从这个错误中恢复，因为需要赶上源的事务历史的部分已被清除。尝试在未启用`MASTER_AUTO_POSITION`选项的情况下重新连接，只会导致副本上丢失被清除的事务。从这种情况中恢复的正确方法是，副本从另一个源复制`ER_FOUND_MISSING_GTIDS`消息中列出的缺失事务，或者用从更近的备份创建的新副本替换副本。考虑在源上修订二进制日志过期期限（`binlog_expire_logs_seconds`），以确保情况不再发生。

如果在交换事务期间发现，副本已接收或提交了带有源UUID的GTID的事务，但源本身没有这些事务的记录，源会向副本发送错误`ER_SLAVE_HAS_MORE_GTIDS_THAN_MASTER`，并且复制不会启动。如果源未设置`sync_binlog=1`就经历了电源故障或操作系统崩溃，并丢失了尚未同步到二进制日志文件的已提交事务，但这些事务已被副本接收，就会发生这种情况。如果在源重启后有任何客户端在源上提交事务，源和副本可以发生分歧，这可能导致源和副本使用相同的GTID为不同的事务，从这种情况中恢复的正确方法是手动检查源和副本是否已发生分歧。如果现在使用相同的GTID为不同的事务，则需要根据需要对各个事务进行手动冲突解决，或从复制拓

扑中移除源或副本。如果问题只是源上缺少事务，你可以将源变成副本，让它追上复制拓扑中的其他服务器，然后如果需要，再次将其变成源。

对于在菱形拓扑中的多源副本（即副本从两个或更多源复制，这些源又从一个共同源复制），当使用基于GTID的复制时，确保多源副本上所有通道的任何复制过滤器或其他通道配置都相同。在基于GTID的复制中，过滤器仅应用于事务数据，并且不过滤出GTID。这样做是为了保持副本的GTID集与源的一致，意味着GTID自动定位可以使用，而无需每次重新获取被过滤出的事务。在下游副本是多源的情况下，并且从多个源在菱形拓扑中接收到相同的事务时，下游副本现在有了事务的多个版本，结果取决于哪个通道首先应用事务。第二个尝试它的通道使用GTID自动跳过跳过事务，因为事务的GTID已由第一个通道添加到`gtid_executed`集中。使用通道上相同的过滤，没有问题，因为所有版本的事务包含相同的数据，所以结果相同。然而，如果通道上的过滤不同，数据库可能变得不一致，复制可能会挂起。