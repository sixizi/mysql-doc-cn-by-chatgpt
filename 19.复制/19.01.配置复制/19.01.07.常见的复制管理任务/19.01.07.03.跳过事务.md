#### 19.1.7.3 跳过事务

如果复制因复制事务中的某个事件问题而停止，您可以通过在副本上跳过失败的事务来恢复复制。跳过事务之前，请确保复制 I/O（接收）线程和 SQL（应用）线程都已停止。

首先，您需要识别导致错误的复制事件。错误详情和最后成功应用的事务记录在性能架构表 `replication_applier_status_by_worker` 中。您可以使用 `mysqlbinlog` 来检索和显示错误发生时间周围记录的事件。有关如何执行此操作的说明，请参见第 9.5 节，“点对点（增量）恢复”。或者，您可以在副本上发出 `SHOW RELAYLOG EVENTS` 或在源上发出 `SHOW BINLOG EVENTS`。

在跳过事务并重启副本之前，请检查以下几点：

- 停止复制的事务是否来自未知或不受信任的来源？如果是，调查原因，以防有任何安全考虑表明不应重启副本。

- 是否需要在副本上应用停止复制的事务？如果是，要么进行适当的更正并重新应用事务，要么手动在副本上调整数据。

- 是否需要在源上应用停止复制的事务？如果不需要，手动在事务最初发生的服务器上撤销事务。

要跳过事务，请根据具体情况选择以下方法之一：

- 当使用 GTID 时（`gtid_mode` 为 ON），请参见 19.1.7.3.1 节，“使用 GTID 跳过事务”。

- 当没有使用 GTID 或正在逐步引入 GTID 时（`gtid_mode` 为 OFF、OFF_PERMISSIVE 或 ON_PERMISSIVE），请参见 19.1.7.3.2 节，“没有使用 GTID 时跳过事务”。

- 如果您使用 `CHANGE REPLICATION SOURCE TO` 或 `CHANGE MASTER TO` 语句的 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 选项在复制通道上启用了 GTID 分配，请参见 19.1.7.3.2 节，“没有使用 GTID 时跳过事务”。在复制通道上使用 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 与为该通道引入基于 GTID 的复制不同，您不能使用 GTID 基础复制的事务跳过方法与这些通道。

跳过事务后重新开始复制，发出 `START REPLICA` 语句，如果副本是多源副本，则需要 `FOR CHANNEL` 子句。

##### 19.1.7.3.1 使用 GTID 跳过事务

当使用 GTID 时（`gtid_mode` 为 ON），即使事务的内容被过滤掉，已提交事务的 GTID 也会在副本上持久化。此功能防止副本在使用 GTID 自动定位重新连接到源时检索以前过滤掉的事务。它也可以用来跳过副本上的事务，通过提交一个空事务来代替失败的事务。

当您在复制通道上使用 `CHANGE REPLICATION SOURCE TO` 语句的 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 选项启用 GTID 分配时，此跳过事务的方法不适用。

如果失败的事务在工作线程中生成了错误，您可以直接从性能架构表 `replication_applier_status_by_worker` 中的 `APPLYING_TRANSACTION` 字段获取其 GTID。要查看事务内容，请在副本上发出 `SHOW RELAYLOG EVENTS` 或在源上发出 `SHOW BINLOG EVENTS`，并在输出中搜索该 GTID 前面的事务。

当您根据前述描述评估了失败的事务并采取了任何其他适当的行动（如安全考虑）后，要跳过它，在副本上提交一个与失败事务具有相同 GTID 的空事务。例如：

```mysql
SET GTID_NEXT='aaa-bbb-ccc-ddd:N';
BEGIN;
COMMIT;
SET GTID_NEXT='AUTOMATIC';
```

当您发出 `START REPLICA` 语句以重新启动复制时，副本上这个空事务的存在意味着副本使用自动跳过功能忽略失败的事务，因为它看到具有该 GTID 的事务已经被应用。如果副本是多源副本，提交空事务时不需要指定通道名称，但发出 `START REPLICA` 时需要指定通道名称。

注意，如果在这个副本上使用了二进制日志，空事务将进入复制流，如果未来副本成为源或主节点。如果您需要避免这种可能性，请考虑刷新并清除副本的二进制日志，例如：

```mysql
FLUSH LOGS;
PURGE BINARY LOGS TO 'binlog.000146';
```

空事务的 GTID 被持久化，但通过清除二进制日志文件删除了事务本身。

##### 19.1.7.3.2 没有使用 GTID 时跳过事务

当没有使用 GTID 或正在逐步引入 GTID 时（`gtid_mode` 为 OFF、OFF_PERMISSIVE 或 ON_PERMISSIVE），您可以通过发出 `SET GLOBAL sql_replica_skip_counter` 语句（从 MySQL 8.0.26 开始）或 `SET GLOBAL sql_slave_skip_counter` 语句来跳过指定数量的事件。或者，您可以通过发出 `CHANGE REPLICATION SOURCE TO` 或 `CHANGE MASTER TO` 语句将源二进制日志位置向前移动来跳过一个或多个事件。

当您在复制通道上使用 `CHANGE REPLICATION SOURCE TO` 或 `CHANGE MASTER TO` 语句的 `ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS` 选项启用 GTID 分配时，这些方法也适用。

使用这些方法时，重要的是要理解您不一定跳过了完整的事务，这与之前描述的基于 GTID 的方法始终如此。这些非 GTID 方法本身不了解事务，而是操作事件。二进制日志被组织为一系列称为事件组的序列，每个事件组由一系列事件组成。

- 对于事务性表，事件组对应于一个事务。

- 对于非事务性表，事件组对应于一个 SQL 语句。


单个事务可以包含对事务性和非事务性表的更改。

使用 `SET GLOBAL sql_replica_skip_counter` 或 `SET GLOBAL sql_slave_skip_counter` 语句跳过事件时，如果结果位置在事件组中间，副本继续跳过事件直到到达组的末尾。然后执行从下一个事件组开始。`CHANGE REPLICATION SOURCE TO` 或 `CHANGE MASTER TO` 语句没有这个功能，因此您必须小心确定正确的位置在事件组的开始重新启动复制。然而，使用 `CHANGE REPLICATION SOURCE TO` 或 `CHANGE MASTER TO` 意味着您不必像使用 `SET GLOBAL sql_replica_skip_counter` 或 `SET GLOBAL sql_slave_skip_counter` 那样计算需要跳过的事件数量，而是可以直接指定重新开始的位置。