### 29.4.1 性能模式事件计时

事件通过添加到服务器源代码中的检测器收集。检测器对事件进行计时，这也是性能模式提供事件持续时间信息的方式。也可以配置检测器不收集计时信息。本节讨论可用的计时器及其特性，以及事件中如何表示计时值。

#### 性能模式计时器

性能模式计时器在精度和开销量上各不相同。要查看可用的计时器及其特性，可以检查 `performance_timers` 表：

```sql
mysql> SELECT * FROM performance_schema.performance_timers;
+-------------+-----------------+------------------+----------------+
| TIMER_NAME  | TIMER_FREQUENCY | TIMER_RESOLUTION | TIMER_OVERHEAD |
+-------------+-----------------+------------------+----------------+
| CYCLE       |      2389029850 |                1 |             72 |
| NANOSECOND  |      1000000000 |                1 |            112 |
| MICROSECOND |         1000000 |                1 |            136 |
| MILLISECOND |            1036 |                1 |            168 |
| THREAD_CPU  |       339101694 |                1 |            798 |
+-------------+-----------------+------------------+----------------+
```

如果某个计时器的值为 `NULL`，则说明该计时器在你的平台上不受支持。

每个列的含义如下：

- `TIMER_NAME` 列显示可用计时器的名称。`CYCLE` 是基于 CPU（处理器）周期计数器的计时器。
- `TIMER_FREQUENCY` 表示每秒的计时器单位数。对于周期计数器，频率通常与 CPU 速度相关。上面显示的值是在一个 2.4GHz 处理器的系统上获得的。其他计时器基于秒的固定分数。
- `TIMER_RESOLUTION` 表示计时器值每次增加的单位数。如果某个计时器的分辨率为 10，则每次其值增加 10。
- `TIMER_OVERHEAD` 是使用该计时器进行一次计时的最小开销周期数。每个事件的开销是显示值的两倍，因为在事件的开始和结束时都调用了计时器。

性能模式根据以下方式分配计时器：

- `wait` 事件使用 `CYCLE` 计时器。
- `idle`、`stage`、`statement` 和 `transaction` 事件在支持 `NANOSECOND` 计时器的平台上使用 `NANOSECOND`，否则使用 `MICROSECOND`。

在服务器启动时，性能模式会验证构建时关于计时器分配的假设是否正确，如果某个计时器不可用，会显示警告。

对于 `wait` 事件，最重要的标准是尽量减少开销，即使会牺牲计时器的精度，因此使用 `CYCLE` 计时器是最佳选择。

执行语句（或阶段）所需的时间通常比执行单个 `wait` 事件的时间长得多。对语句进行计时，最重要的标准是获得准确的测量结果，且不受处理器频率变化的影响，因此使用非周期计数器的计时器是最佳选择。语句的默认计时器是 `NANOSECOND`。相比 `CYCLE` 计时器，额外的“开销”并不显著，因为调用计时器两次（一次在语句开始时，另一次在结束时）所造成的开销比执行语句所用的 CPU 时间要小得多。使用 `CYCLE` 计时器没有好处，只有缺点。

#### 周期计数器的优缺点

周期计数器的精度取决于处理器速度。如果处理器以 1GHz（十亿周期/秒）或更高速度运行，则周期计数器提供亚纳秒级精度。使用周期计数器比获取实际时间（如使用 `gettimeofday()` 函数）便宜得多，后者可能需要数百个周期，而这对于每秒可能发生数千次甚至数百万次的数据收集是不可接受的开销。

周期计数器的缺点包括：

- 用户期望以时钟单位（如秒的分数）查看时间。将周期转换为秒的分数可能很耗费资源。因此，这种转换是一种快速且相对粗略的乘法操作。
- 处理器的周期速率可能会改变，例如，当笔记本进入省电模式或 CPU 降速以减少热量时。如果处理器的周期速率波动，从周期到实时单位的转换可能会出现误差。
- 周期计数器可能不可靠或不可用，具体取决于处理器或操作系统。例如，在 Pentium 处理器上，指令是 `RDTSC`（一种汇编语言指令，而不是 C 语言指令），理论上操作系统可能会阻止用户模式程序使用它。
- 一些处理器的乱序执行或多处理器同步相关的细节可能会导致计数器快或慢达 1000 个周期。

MySQL 可以在以下平台上与周期计数器协同工作：x386（Windows、macOS、Linux、Solaris 及其他 Unix 系统）、PowerPC 和 IA-64。

#### 性能模式事件中的计时器表示

存储当前事件和历史事件的性能模式表中的行有三列表示计时信息：`TIMER_START` 和 `TIMER_END` 表示事件的开始和结束时间，`TIMER_WAIT` 表示事件的持续时间。

`setup_instruments` 表中的 `ENABLED` 列指示收集哪些检测器的事件。该表还包含 `TIMED` 列，用于指示哪些检测器进行计时。如果某个检测器未启用，则不会产生任何事件。如果启用的检测器未计时，检测器产生的事件在 `TIMER_START`、`TIMER_END` 和 `TIMER_WAIT` 列中的值为 `NULL`。这会导致在汇总表中计算时间（总和、最小值、最大值和平均值）时忽略这些值。

在事件开始计时时，事件内部的时间以当前计时器的单位存储。在从性能模式表中检索事件时，时间以皮秒（万亿分之一秒）显示，以便将其标准化为统一单位，而不论选择了哪个计时器。

计时器的基线（即“时间零”）发生在服务器启动时的性能模式初始化期间。事件中的 `TIMER_START` 和 `TIMER_END` 值表示自基线以来的皮秒数。`TIMER_WAIT` 值是以皮秒为单位的持续时间。

事件中的皮秒值是近似值，其精度受到从一个单位转换到另一个单位时常见的误差的影响。如果使用 `CYCLE` 计时器且处理器速率变化，可能会产生漂移。因此，不应将事件的 `TIMER_START` 值视为自服务器启动以来经过时间的准确测量。不过，可以合理地使用 `TIMER_START` 或 `TIMER_WAIT` 值在 `ORDER BY` 子句中按开始时间或持续时间对事件排序。

选择使用皮秒而非微秒有其性能基础。实现目标之一是显示统一的时间单位，而不论使用的计时器。在理想情况下，这个时间单位应该类似于时钟单位且精度合理，即微秒。但将周期或纳秒转换为微秒，需要对每次检测进行一次除法运算。在许多平台上，除法的开销很大，而乘法则没有这种问题。因此，选择了乘法运算。因此，时间单位为“皮秒”。这种精度虽然是多余的，但这种选择有助于将开销降到最低。

当 `wait`、`stage`、`statement` 或 `transaction` 事件正在执行时，相应的 `current-event` 表显示当前事件的计时信息：

- `events_waits_current`
- `events_stages_current`
- `events_statements_current`
- `events_transactions_current`

为了确定尚未完成的事件已经运行了多长时间，计时器列设置如下：

- `TIMER_START` 被填充。
- `TIMER_END` 被填充为当前计时器值。
- `TIMER_WAIT` 被填充为目前为止的经过时间（`TIMER_END - TIMER_START`）。

尚未完成的事件的 `END_EVENT_ID` 值为 `NULL`。要评估事件目前为止经过的时间，可以使用 `TIMER_WAIT` 列。因此，要识别尚未完成且目前已耗时超过 N 皮秒的事件，监控应用程序可以在查询中使用以下表达式：

```sql
WHERE END_EVENT_ID IS NULL AND TIMER_WAIT > N
```

上述事件识别方式假设相应的检测器 `ENABLED` 和 `TIMED` 设置为 `YES`，且相关消费者已启用。