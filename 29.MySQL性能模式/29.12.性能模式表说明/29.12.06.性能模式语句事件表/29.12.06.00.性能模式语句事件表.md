### 29.12.6 Performance Schema 语句事件表

- [29.12.6.1 events_statements_current 表](./29.12.06.01.events_statements_current 表.md)
- [29.12.6.2 events_statements_history 表](./29.12.06.02.events_statements_history 表.md)
- [29.12.6.3 events_statements_history_long 表](./29.12.06.03.events_statements_history_long 表.md)
- [29.12.6.4 prepared_statements_instances 表](./29.12.06.04.prepared_statements_instances 表.md)

`Performance Schema` 为语句执行提供监控。语句事件位于事件层次结构的高级别。在该层次结构中，等待事件嵌套在阶段事件内，阶段事件嵌套在语句事件内，语句事件嵌套在事务事件内。

以下表格用于存储语句事件：

- **`events_statements_current`**：每个线程的当前语句事件。
- **`events_statements_history`**：每个线程最近已结束的语句事件。
- **`events_statements_history_long`**：全局范围内所有线程最近已结束的语句事件。
- **`prepared_statements_instances`**：已准备语句实例及其统计信息。

以下部分描述语句事件表。有关语句事件汇总的信息表，请参阅 [Section 29.12.20.3, “Statement Summary Tables”](#section-29-12-20-3-statement-summary-tables)。

关于三个 `events_statements_xxx` 事件表之间的关系，请参阅 [Section 29.9, “Performance Schema Tables for Current and Historical Events”](#section-29-9-performance-schema-tables-for-current-and-historical-events)。

---

#### 配置语句事件的收集

要控制是否收集语句事件，需要设置相关的仪器和消费者状态：

- **`setup_instruments` 表**：包含以 `statement` 开头的仪器名称，用于启用或禁用特定语句事件类别的收集。
- **`setup_consumers` 表**：包含与当前和历史语句事件表名称及语句摘要消费者对应的值，用于过滤语句事件和语句摘要的收集。

语句仪器默认启用，且 `events_statements_current`、`events_statements_history` 和 `statements_digest` 消费者默认启用：

```sql
mysql> SELECT NAME, ENABLED, TIMED
       FROM performance_schema.setup_instruments
       WHERE NAME LIKE 'statement/%';
+---------------------------------------------+---------+-------+
| NAME                                        | ENABLED | TIMED |
+---------------------------------------------+---------+-------+
| statement/sql/select                        | YES     | YES   |
| statement/sql/create_table                  | YES     | YES   |
| statement/sql/create_index                  | YES     | YES   |
...
| statement/sp/stmt                           | YES     | YES   |
| statement/sp/set                            | YES     | YES   |
| statement/sp/set_trigger_field              | YES     | YES   |
| statement/scheduler/event                   | YES     | YES   |
| statement/com/Sleep                         | YES     | YES   |
| statement/com/Quit                          | YES     | YES   |
| statement/com/Init DB                       | YES     | YES   |
...
| statement/abstract/Query                    | YES     | YES   |
| statement/abstract/new_packet               | YES     | YES   |
| statement/abstract/relay_log                | YES     | YES   |
+---------------------------------------------+---------+-------+
```

```sql
mysql> SELECT *
       FROM performance_schema.setup_consumers
       WHERE NAME LIKE '%statements%';
+--------------------------------+---------+
| NAME                           | ENABLED |
+--------------------------------+---------+
| events_statements_current      | YES     |
| events_statements_history      | YES     |
| events_statements_history_long | NO      |
| statements_digest              | YES     |
+--------------------------------+---------+
```

要在服务器启动时控制语句事件的收集，请在 `my.cnf` 文件中使用以下内容：

- 启用：

  ```ini
  [mysqld]
  performance-schema-instrument='statement/%=ON'
  performance-schema-consumer-events-statements-current=ON
  performance-schema-consumer-events-statements-history=ON
  performance-schema-consumer-events-statements-history-long=ON
  performance-schema-consumer-statements-digest=ON
  ```

- 禁用：

  ```ini
  [mysqld]
  performance-schema-instrument='statement/%=OFF'
  performance-schema-consumer-events-statements-current=OFF
  performance-schema-consumer-events-statements-history=OFF
  performance-schema-consumer-events-statements-history-long=OFF
  performance-schema-consumer-statements-digest=OFF
  ```

要在运行时控制语句事件的收集，请更新 `setup_instruments` 和 `setup_consumers` 表：

- 启用：

  ```sql
  UPDATE performance_schema.setup_instruments
  SET ENABLED = 'YES', TIMED = 'YES'
  WHERE NAME LIKE 'statement/%';

  UPDATE performance_schema.setup_consumers
  SET ENABLED = 'YES'
  WHERE NAME LIKE '%statements%';
  ```

- 禁用：

  ```sql
  UPDATE performance_schema.setup_instruments
  SET ENABLED = 'NO', TIMED = 'NO'
  WHERE NAME LIKE 'statement/%';
  
  UPDATE performance_schema.setup_consumers
  SET ENABLED = 'NO'
  WHERE NAME LIKE '%statements%';
  ```

若仅需收集特定的语句事件，请仅启用对应的语句仪器。若只需特定语句事件表的语句事件，请启用语句仪器以及与目标表对应的语句消费者。

有关事件收集配置的更多信息，请参阅 [第 29.3 节，“Performance Schema 启动配置”](#section-29-3-performance-schema-startup-configuration) 和 [第 29.4 节，“Performance Schema 运行时配置”](#section-29-4-performance-schema-runtime-configuration)。

#### 语句监控

语句监控从服务器检测到线程上的活动请求开始，到所有活动停止为止。通常，这意味着从服务器收到客户端的第一个数据包到服务器完成响应发送之间的时间。存储程序中的语句与其他语句一样被监控。

当 `Performance Schema` 为请求（服务器命令或 SQL 语句）设置监控时，它使用的仪器名称从更一般（或“抽象”）逐步变得更具体，直到达到最终的仪器名称。

最终的仪器名称对应服务器命令和 SQL 语句：

- 服务器命令对应于 `mysql_com.h` 头文件中定义的 `COM_xxx` 代码，并在 `sql/sql_parse.cc` 中进行处理。例如，`COM_PING` 和 `COM_QUIT`。这些命令的仪器名称以 `statement/com` 开头，例如 `statement/com/Ping` 和 `statement/com/Quit`。
  
- SQL 语句以文本形式表示，例如 `DELETE FROM t1` 或 SELECT * FROM t2。这些语句的仪器名称以 `statement/sql` 开头，例如 `statement/sql/delete` 和 `statement/sql/select`。
  

某些最终仪器名称专用于错误处理：

- `statement/com/Error`：用于记录服务器收到的带外消息。这可以用来检测客户端发送的服务器无法理解的命令。例如，这可能用于识别配置错误的客户端、使用比服务器版本更新的 MySQL 客户端，或者试图攻击服务器的客户端。
- `statement/sql/error`：用于记录无法解析的 SQL 语句。这可以用来检测客户端发送的格式错误的查询。无法解析的查询与解析成功但因执行错误失败的查询有所不同。例如，`SELECT * FROM` 是格式错误的查询，会使用 statement/sql/error 仪器；而 `SELECT *` 可以解析，但由于 “`No tables used`” 错误失败，这种情况下会使用 statement/sql/select，语句事件中会包含表明错误性质的信息。

### 请求可以从以下来源获取：

1. 作为来自客户端的命令或语句请求，以数据包的形式发送请求。
2. 作为从复制副本的中继日志中读取的语句字符串。
3. 作为来自**事件调度器（Event Scheduler）**的事件。

> **提示**  
> 请求的详细信息最初并不确定，`Performance Schema` 会根据请求的来源，从抽象到具体按顺序确定对应的`instrument`名称。

---

### 客户端请求的处理过程

#### 1. 数据包检测与抽象`instrument`标识
当服务器在套接字级别检测到新数据包时，会以抽象`instrument`名称`statement/abstract/new_packet`启动一个新语句。

#### 2. 读取数据包类型
服务器读取数据包编号后，可以更具体地确定收到的请求类型。`Performance Schema` 会调整`instrument`名称：

- **COM_PING 数据包**  
  直接命名为 `statement/com/Ping`，这是最终名称。

- **COM_QUERY 数据包**  
  如果请求是 SQL 语句，但尚不清楚语句类型，`instrument`会从`statement/abstract/new_packet`变为`statement/abstract/Query`。随后解析请求以进一步分类。

#### 3. 语句解析与最终名称
如果请求为一条语句，语句文本会被读取并交给解析器处理。解析后，语句的确切类型确定：

- **示例：INSERT 语句**  
  `Performance Schema` 会将`instrument`名称从`statement/abstract/Query`更新为`statement/sql/insert`，这是最终名称。

---

### 从复制副本中继日志读取的请求

#### 1. 初始`instrument`名称
从中继日志读取的语句存储为文本形式，不涉及网络协议。因此，不使用`statement/abstract/new_packet`。而是使用初始`instrument`名称`statement/abstract/relay_log`。

#### 2. 语句解析与最终名称
语句被解析后，其确切类型确定：

- **示例：INSERT 语句**  
  `Performance Schema` 将`instrument`名称从`statement/abstract/relay_log`更新为`statement/sql/insert`，这是最终名称。

#### 3. 基于语句的复制与基于行的复制
- **语句复制**  
  上述描述适用于语句复制。

- **行复制**  
  副本在处理行更改时的表 I/O 操作可以被检测，但中继日志中的行事件不会作为离散语句出现。

---

### 来自事件调度器的请求

#### 1. 事件执行的`instrument`名称
事件执行使用名称`statement/scheduler/event`记录，这是最终名称。

#### 2. 事件体中语句的`instrument`名称
事件体内执行的语句使用`statement/sql/*`名称标识，无需使用前置的抽象`instrument`。

> **提示**  
> 事件是存储程序，存储程序在执行前会被预编译到内存中。因此，运行时无需解析语句，其类型在执行前已知。

#### 3. 父子关系的`instrument`标识
- **父操作：事件本身**  
  使用`statement/scheduler/event`标识。
- **子操作：事件体内语句**  
  例如，事件执行一条`INSERT`语句时：
  - 父级：`statement/scheduler/event`
  - 子级：`statement/sql/insert`

父/子关系适用于单独的检测操作，区别于单个检测操作中从抽象到最终名称的细化过程。

---

### 收集语句统计信息的注意事项

> **提示**  
> 为收集语句的统计信息，仅启用用于各语句类型的最终`instrument`（如`statement/sql/*`）是不够的，还必须启用抽象`instrument`（如`statement/abstract/*`）。

- **默认启用**  
  通常情况下，所有语句的`instrument`默认启用，因此无需特别处理。

- **选择性启用的情况**  
  如果应用程序选择性启用或禁用某些语句的`instrument`，需要注意：
  - 禁用抽象`instrument`会同时禁用统计信息的收集。
  - **示例：统计INSERT语句**  
    必须同时启用：
    - `statement/sql/insert`
    - `statement/abstract/new_packet`
    - `statement/abstract/Query`

- **复制语句的检测**  
  必须启用`statement/abstract/relay_log`。

---

### 抽象`instrument`的统计信息

抽象`instrument`（如`statement/abstract/Query`）不聚合任何统计信息，因为没有语句最终会以抽象`instrument`命名。