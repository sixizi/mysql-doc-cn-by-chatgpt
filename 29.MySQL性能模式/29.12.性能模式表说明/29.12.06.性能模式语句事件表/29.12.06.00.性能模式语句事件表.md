### 29.12.6 Performance Schema 语句事件表

- [29.12.6.1 events_statements_current 表](./29.12.06.01.events_statements_current 表.md)
- [29.12.6.2 events_statements_history 表](./29.12.06.02.events_statements_history 表.md)
- [29.12.6.3 events_statements_history_long 表](./29.12.06.03.events_statements_history_long 表.md)
- [29.12.6.4 prepared_statements_instances 表](./29.12.06.04.prepared_statements_instances 表.md)

`Performance Schema` 为语句执行提供监控。语句事件位于事件层次结构的高级别。在该层次结构中，等待事件嵌套在阶段事件内，阶段事件嵌套在语句事件内，语句事件嵌套在事务事件内。

以下表格用于存储语句事件：

- **`events_statements_current`**：每个线程的当前语句事件。
- **`events_statements_history`**：每个线程最近已结束的语句事件。
- **`events_statements_history_long`**：全局范围内所有线程最近已结束的语句事件。
- **`prepared_statements_instances`**：已准备语句实例及其统计信息。

以下部分描述语句事件表。有关语句事件汇总的信息表，请参阅 [Section 29.12.20.3, “Statement Summary Tables”](#section-29-12-20-3-statement-summary-tables)。

关于三个 `events_statements_xxx` 事件表之间的关系，请参阅 [Section 29.9, “Performance Schema Tables for Current and Historical Events”](#section-29-9-performance-schema-tables-for-current-and-historical-events)。

---

#### 配置语句事件的收集

要控制是否收集语句事件，需要设置相关的仪器和消费者状态：

- **`setup_instruments` 表**：包含以 `statement` 开头的仪器名称，用于启用或禁用特定语句事件类别的收集。
- **`setup_consumers` 表**：包含与当前和历史语句事件表名称及语句摘要消费者对应的值，用于过滤语句事件和语句摘要的收集。

语句仪器默认启用，且 `events_statements_current`、`events_statements_history` 和 `statements_digest` 消费者默认启用：

```sql
mysql> SELECT NAME, ENABLED, TIMED
       FROM performance_schema.setup_instruments
       WHERE NAME LIKE 'statement/%';
+---------------------------------------------+---------+-------+
| NAME                                        | ENABLED | TIMED |
+---------------------------------------------+---------+-------+
| statement/sql/select                        | YES     | YES   |
| statement/sql/create_table                  | YES     | YES   |
| statement/sql/create_index                  | YES     | YES   |
...
| statement/sp/stmt                           | YES     | YES   |
| statement/sp/set                            | YES     | YES   |
| statement/sp/set_trigger_field              | YES     | YES   |
| statement/scheduler/event                   | YES     | YES   |
| statement/com/Sleep                         | YES     | YES   |
| statement/com/Quit                          | YES     | YES   |
| statement/com/Init DB                       | YES     | YES   |
...
| statement/abstract/Query                    | YES     | YES   |
| statement/abstract/new_packet               | YES     | YES   |
| statement/abstract/relay_log                | YES     | YES   |
+---------------------------------------------+---------+-------+
```

```sql
mysql> SELECT *
       FROM performance_schema.setup_consumers
       WHERE NAME LIKE '%statements%';
+--------------------------------+---------+
| NAME                           | ENABLED |
+--------------------------------+---------+
| events_statements_current      | YES     |
| events_statements_history      | YES     |
| events_statements_history_long | NO      |
| statements_digest              | YES     |
+--------------------------------+---------+
```

要在服务器启动时控制语句事件的收集，请在 `my.cnf` 文件中使用以下内容：

- 启用：

  ```ini
  [mysqld]
  performance-schema-instrument='statement/%=ON'
  performance-schema-consumer-events-statements-current=ON
  performance-schema-consumer-events-statements-history=ON
  performance-schema-consumer-events-statements-history-long=ON
  performance-schema-consumer-statements-digest=ON
  ```

- 禁用：

  ```ini
  [mysqld]
  performance-schema-instrument='statement/%=OFF'
  performance-schema-consumer-events-statements-current=OFF
  performance-schema-consumer-events-statements-history=OFF
  performance-schema-consumer-events-statements-history-long=OFF
  performance-schema-consumer-statements-digest=OFF
  ```

要在运行时控制语句事件的收集，请更新 `setup_instruments` 和 `setup_consumers` 表：

- 启用：

  ```sql
  UPDATE performance_schema.setup_instruments
  SET ENABLED = 'YES', TIMED = 'YES'
  WHERE NAME LIKE 'statement/%';

  UPDATE performance_schema.setup_consumers
  SET ENABLED = 'YES'
  WHERE NAME LIKE '%statements%';
  ```

- 禁用：

  ```sql
  UPDATE performance_schema.setup_instruments
  SET ENABLED = 'NO', TIMED = 'NO'
  WHERE NAME LIKE 'statement/%';
  
  UPDATE performance_schema.setup_consumers
  SET ENABLED = 'NO'
  WHERE NAME LIKE '%statements%';
  ```

若仅需收集特定的语句事件，请仅启用对应的语句仪器。若只需特定语句事件表的语句事件，请启用语句仪器以及与目标表对应的语句消费者。

有关事件收集配置的更多信息，请参阅 [第 29.3 节，“Performance Schema 启动配置”](#section-29-3-performance-schema-startup-configuration) 和 [第 29.4 节，“Performance Schema 运行时配置”](#section-29-4-performance-schema-runtime-configuration)。

### 语句监控

语句监控从服务器检测到线程上的活动请求开始，到所有活动停止为止。通常，这意味着从服务器收到客户端的第一个数据包到服务器完成响应发送之间的时间。存储程序中的语句与其他语句一样被监控。

当 `Performance Schema` 为请求（服务器命令或 SQL 语句）设置监控时，它使用的仪器名称从更一般（或“抽象”）逐步变得更具体，直到达到最终的仪器名称。

#### 最终仪器名称的类型

- **服务器命令**：对应于 `mysql_com.h` 头文件中定义的 `COM_xxx` 代码，并在 `sql/sql_parse.cc` 中处理。例如 `COM_PING` 和 `COM_QUIT`。
  - 这些命令的仪器名称以 `statement/com` 开头，例如 `statement/com/Ping` 和 `statement/com/Quit`。

- **SQL 语句**：以文本形式表达，例如 `DELETE FROM t1` 或 `SELECT * FROM t2`。
  - 这些语句的仪器名称以 `statement/sql` 开头，例如 `statement/sql/delete` 和 `statement/sql/select`。

#### 特殊情况

一些最终仪器名称专用于错误处理：
- **`statement/com/Error`**：用于记录服务器无法理解的客户端命令。这有助于识别配置错误的客户端、版本不兼容的客户端，或试图攻击服务器的客户端。
- **`statement/sql/error`**：用于记录无法解析的 SQL 语句。例如，`SELECT * FROM` 是格式错误的查询，使用 `statement/sql/error`。而 `SELECT *` 能被解析但在执行时因错误失败（例如 “No tables used” 错误），则使用 `statement/sql/select`。

#### 请求来源

请求可能来源于以下之一：
1. **客户端**：通过数据包发送命令或语句请求。
2. **复制日志**：从副本的中继日志中读取语句字符串。
3. **事件调度器**：由事件调度器触发的事件。

对于每种来源，`Performance Schema` 会根据请求来源，从抽象到具体逐步确定仪器名称。

##### 客户端请求

- 服务器在套接字级别检测到新数据包时，会以抽象仪器名称 `statement/abstract/new_packet` 开始一个新语句。
- 读取数据包号后，根据请求类型更新仪器名称。例如：
  - 对于 `COM_PING` 数据包，最终名称为 `statement/com/Ping`。
  - 对于 `COM_QUERY` 数据包（SQL 语句），仪器名称更新为 `statement/abstract/Query`，需要进一步分类。
- 如果是语句请求，则读取语句文本并将其传递给解析器。解析后，确切的语句类型被识别，例如 `INSERT` 语句，其仪器名称更新为最终名称 `statement/sql/insert`。

##### 从副本中继日志读取的语句

- 中继日志中的语句以文本形式存储，无网络协议，因此不会使用 `statement/abstract/new_packet`。
- 初始仪器名称为 `statement/abstract/relay_log`。
- 解析语句后，更新为确切类型的最终名称，例如 `statement/sql/insert`。

此描述仅适用于基于语句的复制。对于基于行的复制，中继日志中的行事件不会显示为单独的语句，但副本处理行更改时的表 I/O 可以被监控。

##### 来自事件调度器的请求

- 事件本身使用最终名称 `statement/scheduler/event` 进行监控。
- 事件体内的语句使用 `statement/sql/*` 名称监控，无需先前的抽象仪器名称。

事件体内的语句是子语句，例如：
- 事件执行 `INSERT` 语句时，事件本身是父语句，使用 `statement/scheduler/event` 监控；`INSERT` 是子语句，使用 `statement/sql/insert` 监控。

#### 统计收集注意事项

- 若要为语句收集统计信息，需同时启用抽象仪器（如 `statement/abstract/*`）和对应的具体仪器（如 `statement/sql/*`）。
- 例如，为收集 `INSERT` 语句的统计信息，需启用 `statement/sql/insert` 以及 `statement/abstract/new_packet` 和 `statement/abstract/Query`。
- 类似地，为监控复制语句，需启用 `statement/abstract/relay_log`。

抽象仪器（如 `statement/abstract/Query`）不聚合统计信息，因为最终名称不会是抽象仪器。