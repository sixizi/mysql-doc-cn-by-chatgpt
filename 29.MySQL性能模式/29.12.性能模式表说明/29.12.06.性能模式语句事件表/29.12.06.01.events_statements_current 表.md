**29.12.6.1 events_statements_current 表**



events_statements_current 表包含当前语句事件。该表每个线程存储一行，显示线程的最新监控语句事件的当前状态，因此没有用于配置表大小的系统变量。



在包含语句事件行的表中，events_statements_current 是最基本的。其他包含语句事件行的表在逻辑上是从当前事件衍生出来的。例如，events_statements_history 和 events_statements_history_long 表分别是存储已结束的最新语句事件的集合，按线程的最大行数和所有线程的全局最大行数限制。



有关这三个 events_statements_xxx 事件表之间的关系，请参阅第 29.9 节：“当前和历史事件的性能模式表”。



关于配置是否收集语句事件的详细信息，请参阅第 29.12.6 节：“性能模式语句事件表”。



**events_statements_current 表的列：**



​	•	**THREAD_ID, EVENT_ID**

与事件关联的线程，以及事件开始时的线程当前事件编号。THREAD_ID 和 EVENT_ID 的值一起唯一标识行。没有两行具有相同的这对值。

​	•	**END_EVENT_ID**

事件开始时该列为 NULL，事件结束时更新为线程当前事件编号。

​	•	**EVENT_NAME**

收集事件的 instrument 名称。这是来自 setup_instruments 表的名称值。instrument 名称可能有多个部分并形成层次结构，如第 29.6 节“性能模式仪器命名约定”中所述。

对于 SQL 语句，EVENT_NAME 值最初是 statement/com/Query，直到语句被解析，然后更改为更合适的值，详见第 29.12.6 节“性能模式语句事件表”。

​	•	**SOURCE**

产生事件的 instrumented 代码所在的源文件名及文件中的行号。这使您可以检查源代码，确定涉及的具体代码。

​	•	**TIMER_START, TIMER_END, TIMER_WAIT**

事件的时间信息。这些值的单位是皮秒（万亿分之一秒）。TIMER_START 和 TIMER_END 值表示事件计时开始和结束的时间。TIMER_WAIT 是事件的经过时间（持续时间）。

如果事件尚未完成，TIMER_END 是当前计时器值，TIMER_WAIT 是到目前为止的经过时间（TIMER_END - TIMER_START）。

如果事件来自一个 TIMED = NO 的 instrument，则不会收集计时信息，TIMER_START、TIMER_END 和 TIMER_WAIT 都为 NULL。

有关皮秒作为事件时间单位的讨论以及影响时间值的因素，请参见第 29.4.1 节：“性能模式事件计时”。

​	•	**LOCK_TIME**

等待表锁的时间。该值以微秒为单位，但已归一化为皮秒，以便与其他性能模式计时器进行比较。

​	•	**SQL_TEXT**

SQL 语句的文本。如果与 SQL 语句无关的命令，值为 NULL。

默认情况下，语句显示的最大空间为 1024 字节。要更改此值，请在服务器启动时设置 performance_schema_max_sql_text_length 系统变量。（更改此值会影响其他性能模式表中的列。详见第 29.10 节：“性能模式语句摘要和采样”。）

​	•	**DIGEST**

语句摘要的 SHA-256 值，以 64 个十六进制字符表示，若 statements_digest 消费者为否，则为 NULL。有关语句摘要的详细信息，请参见第 29.10 节：“性能模式语句摘要和采样”。

​	•	**DIGEST_TEXT**

标准化的语句摘要文本，若 statements_digest 消费者为否，则为 NULL。有关语句摘要的详细信息，请参见第 29.10 节：“性能模式语句摘要和采样”。

performance_schema_max_digest_length 系统变量确定每个会话用于摘要值存储的最大字节数。然而，由于语句元素（如关键字和文字值）在摘要缓冲区中的编码，语句摘要的显示长度可能会超过可用缓冲区大小。因此，从语句事件表中选择的 DIGEST_TEXT 列的值可能会看起来超过 performance_schema_max_digest_length 值。

​	•	**CURRENT_SCHEMA**

语句的默认数据库，如果没有则为 NULL。

​	•	**OBJECT_SCHEMA, OBJECT_NAME, OBJECT_TYPE**

对于嵌套语句（存储程序），这些列包含父语句的信息。否则，它们为 NULL。

​	•	**OBJECT_INSTANCE_BEGIN**

此列标识语句。值为内存中对象的地址。

​	•	**MYSQL_ERRNO**

语句错误编号，来自语句诊断区域。

​	•	**RETURNED_SQLSTATE**

语句的 SQLSTATE 值，来自语句诊断区域。

​	•	**MESSAGE_TEXT**

语句错误信息，来自语句诊断区域。

​	•	**ERRORS**

语句是否发生错误。如果 SQLSTATE 值以 00（完成）或 01（警告）开头，则值为 0；否则为 1。

​	•	**WARNINGS**

语句的警告数量，来自语句诊断区域。

​	•	**ROWS_AFFECTED**

语句影响的行数。有关“影响”的描述，请参见 mysql_affected_rows()。

​	•	**ROWS_SENT**

语句返回的行数。

​	•	**ROWS_EXAMINED**

服务器层检查的行数（不包括存储引擎内部的处理）。

​	•	**CREATED_TMP_DISK_TABLES**

类似于 Created_tmp_disk_tables 状态变量，但特定于语句。

​	•	**CREATED_TMP_TABLES**

类似于 Created_tmp_tables 状态变量，但特定于语句。

​	•	**SELECT_FULL_JOIN**

类似于 Select_full_join 状态变量，但特定于语句。

​	•	**SELECT_FULL_RANGE_JOIN**

类似于 Select_full_range_join 状态变量，但特定于语句。

​	•	**SELECT_RANGE**

类似于 Select_range 状态变量，但特定于语句。

​	•	**SELECT_RANGE_CHECK**

类似于 Select_range_check 状态变量，但特定于语句。

​	•	**SELECT_SCAN**

类似于 Select_scan 状态变量，但特定于语句。

​	•	**SORT_MERGE_PASSES**

类似于 Sort_merge_passes 状态变量，但特定于语句。

​	•	**SORT_RANGE**

类似于 Sort_range 状态变量，但特定于语句。

​	•	**SORT_ROWS**

类似于 Sort_rows 状态变量，但特定于语句。

​	•	**SORT_SCAN**

类似于 Sort_scan 状态变量，但特定于语句。

​	•	**NO_INDEX_USED**

如果语句执行了表扫描而没有使用索引，则为 1；否则为 0。

​	•	**NO_GOOD_INDEX_USED**

如果服务器未找到可用的好索引供语句使用，则为 1；否则为 0。有关更多信息，请参见 EXPLAIN 输出中的 Extra 列，具体描述“Range checked for each record”值，第 10.8.2 节：“EXPLAIN 输出格式”。

​	•	**NESTING_EVENT_ID, NESTING_EVENT_TYPE, NESTING_EVENT_LEVEL**

这三列与其他列一起提供以下信息，适用于顶级（未嵌套）语句和嵌套语句（在存储程序内执行）。

​	•	对于顶级语句：

​	•	OBJECT_TYPE = NULL

​	•	OBJECT_SCHEMA = NULL

​	•	OBJECT_NAME = NULL

​	•	NESTING_EVENT_ID = 父事务的 EVENT_ID

​	•	NESTING_EVENT_TYPE = 'TRANSACTION'

​	•	NESTING_LEVEL = 0

​	•	对于嵌套语句：

​	•	OBJECT_TYPE = 父语句的对象类型

​	•	OBJECT_SCHEMA = 父语句的对象架构

​	•	OBJECT_NAME = 父语句的对象名称

​	•	NESTING_EVENT_ID = 父语句的 EVENT_ID

​	•	NESTING_EVENT_TYPE = 'STATEMENT'

​	•	NESTING_LEVEL = 父语句的 NESTING_LEVEL + 1

​	•	**STATEMENT_ID**

由服务器在 SQL 层维护的查询 ID。此值对于服务器实例是唯一的，因为这些 ID 是使用原子递增的全局计数器生成的。此列自 MySQL 8.0.14 版本开始新增。

​	•	**CPU_TIME**

当前线程在 CPU 上花费的时间，单位为