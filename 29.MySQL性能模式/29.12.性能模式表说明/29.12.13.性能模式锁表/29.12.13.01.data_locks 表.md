### 29.12.13.1 data_locks 表

`data_locks` 表显示持有和请求的数据锁的信息。有关哪些锁请求被哪些已持有的锁阻塞的信息，请参考 [29.12.13.2 data_lock_waits 表](#29.12.13.2)。

#### 示例：数据锁信息

mysql> SELECT * FROM performance_schema.data_locks\G
*************************** 1. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 139664434886512:1059:139664350547912
ENGINE_TRANSACTION_ID: 2569
            THREAD_ID: 46
             EVENT_ID: 12
        OBJECT_SCHEMA: test
          OBJECT_NAME: t1
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: NULL
OBJECT_INSTANCE_BEGIN: 139664350547912
            LOCK_TYPE: TABLE
            LOCK_MODE: IX
          LOCK_STATUS: GRANTED
            LOCK_DATA: NULL
*************************** 2. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 139664434886512:2:4:1:139664350544872
ENGINE_TRANSACTION_ID: 2569
            THREAD_ID: 46
             EVENT_ID: 12
        OBJECT_SCHEMA: test
          OBJECT_NAME: t1
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: GEN_CLUST_INDEX
OBJECT_INSTANCE_BEGIN: 139664350544872
            LOCK_TYPE: RECORD
            LOCK_MODE: X
          LOCK_STATUS: GRANTED
            LOCK_DATA: supremum pseudo-record

#### 列说明

- **ENGINE**  

  持有或请求锁的存储引擎。

- **ENGINE_LOCK_ID**  

  存储引擎持有或请求的锁的 ID。`(ENGINE_LOCK_ID, ENGINE)` 组合值是唯一的。锁 ID 的格式是内部的，可能随时更改。

- **ENGINE_TRANSACTION_ID**  

  存储引擎内部请求锁的事务 ID。对于 InnoDB，可以将此列与 `INFORMATION_SCHEMA.INNODB_TRX` 表的 `TRX_ID` 列连接以获取事务详情。

- **THREAD_ID**  

  创建锁的会话的线程 ID。可以与 Performance Schema `threads` 表的 `THREAD_ID` 列连接以获取线程详情。

- **EVENT_ID**  

  引发锁的 Performance Schema 事件。`(THREAD_ID, EVENT_ID)` 组合值可标识其他 Performance Schema 表中的父事件。

- **OBJECT_SCHEMA**  

  包含被锁表的模式（数据库）。

- **OBJECT_NAME**  

  被锁表的名称。

- **PARTITION_NAME**  

  被锁分区的名称（如果有），否则为 `NULL`。

- **SUBPARTITION_NAME**  

  被锁子分区的名称（如果有），否则为 `NULL`。

- **INDEX_NAME**  

  被锁索引的名称（如果有），否则为 `NULL`。对于 InnoDB 表，通常为 `GEN_CLUST_INDEX`。

- **OBJECT_INSTANCE_BEGIN**  

  锁在内存中的地址。

- **LOCK_TYPE**  

  锁的类型。对于 InnoDB，可能的值为 `RECORD`（行锁）或 `TABLE`（表锁）。

- **LOCK_MODE**  

  请求锁的方式。对于 InnoDB，可能的值包括 `S[,GAP]`、`X[,GAP]`、`IS[,GAP]`、`IX[,GAP]`、`AUTO_INC` 和 `UNKNOWN`。

- **LOCK_STATUS**  

  锁请求的状态。对于 InnoDB，可能的值为 `GRANTED`（锁已持有）或 `WAITING`（锁正在等待）。

- **LOCK_DATA**  

  与锁相关的数据（如果有）。对于 InnoDB，如果 `LOCK_TYPE` 为 `RECORD`，将显示锁定记录的主键值。

#### 索引

- 主键：`(ENGINE_LOCK_ID, ENGINE)`
- 索引：`(ENGINE_TRANSACTION_ID, ENGINE)`
- 索引：`(THREAD_ID, EVENT_ID)`
- 索引：`(OBJECT_SCHEMA, OBJECT_NAME, PARTITION_NAME, SUBPARTITION_NAME)`

#### 特别说明

- 不允许对 `data_locks` 表执行 `TRUNCATE TABLE` 操作。
- 在 MySQL 8.0.1 之前，类似信息可通过 `INFORMATION_SCHEMA.INNODB_LOCKS` 表获取，但该表已在 8.0.1 中移除，推荐使用 `data_locks` 表。

#### INNODB_LOCKS 与 data_locks 的区别

- 如果事务持有锁，`INNODB_LOCKS` 仅显示当有其他事务在等待该锁时的信息；`data_locks` 无论是否有事务在等待都会显示锁。
- `data_locks` 表没有对应 `LOCK_SPACE`、`LOCK_PAGE` 或 `LOCK_REC` 的列。
- 权限要求：`INNODB_LOCKS` 需要全局 `PROCESS` 权限，而 `data_locks` 仅需对表的 `SELECT` 权限。

#### INNODB_LOCKS 与 data_locks 的列映射

| INNODB_LOCKS 列 | data_locks 列              |
| --------------- | -------------------------- |
| LOCK_ID         | ENGINE_LOCK_ID             |
| LOCK_TRX_ID     | ENGINE_TRANSACTION_ID      |
| LOCK_MODE       | LOCK_MODE                  |
| LOCK_TYPE       | LOCK_TYPE                  |
| LOCK_TABLE      | OBJECT_SCHEMA, OBJECT_NAME |
| LOCK_INDEX      | INDEX_NAME                 |
| LOCK_SPACE      | None                       |
| LOCK_PAGE       | None                       |
| LOCK_REC        | None                       |
| LOCK_DATA       | LOCK_DATA                  |