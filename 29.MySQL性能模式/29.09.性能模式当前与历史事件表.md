## 29.9 Performance Schema 用于当前和历史事件的表

对于 wait、stage、statement 和 transaction 事件，Performance Schema 可以监控并存储当前事件。此外，当事件结束时，Performance Schema 可以将它们存储在历史表中。对于每种事件类型，Performance Schema 使用三个表来存储当前和历史事件。这些表的名称形式如下，其中 xxx 表示事件类型（waits、stages、statements、transactions）：

- events\_xxx\_current：**当前事件**表，用于存储每个线程的当前监控事件（每个线程一行）。
- events\_xxx\_history：**最近历史**表，用于存储每个线程最近结束的事件（每个线程最多存储一定数量的行）。
- events\_xxx\_history\_long：**长历史**表，用于全局存储最近结束的事件（跨所有线程，最多存储一定数量的行）。

每种事件类型的\ \_current 表每个线程只包含一行，因此没有用于配置其最大大小的系统变量。Performance Schema 会自动调整历史表的大小，或者可以在服务器启动时使用特定的系统变量显式配置这些表的大小，相关信息在各自的历史表章节中说明。典型的自动调整值是每个线程的\ \_history 表为 10 行，\_history\_long 表的总行数为 10,000 行。

对于每种事件类型，\_current、\_history 和 \_history\_long 表具有相同的列结构。\_current 和 \_history 表具有相同的索引，而\ \_history\_long 表没有索引。\_

- \_current 表显示服务器当前正在发生的事情。当某个当前事件结束时，它会从\_current 表中删除。\_
- \_history 和 \_history\_long 表显示最近发生的事件。

当历史表变满时，旧的事件会在新的事件添加时被丢弃。两种历史表中的行会以不同的方式过期，因为它们的用途不同：

- **\_history** 用于调查单个线程的情况，独立于全局服务器负载。

- **\_history\_long** 用于调查全局服务器的情况，而不是每个线程的情况。


这两种历史表的主要区别在于数据保留策略。事件首次被记录时，两个表中的数据相同。然而，随着时间推移，数据在各表中的过期方式不同，因此数据在每个表中的保存时间可能较长或较短：

- **\_history** 表：当某个线程的表达到最大行数时，新的行会替换该线程的最旧行。
- **\_history\_long** 表：当表满时，新的行会替换最旧的行，而不考虑是哪一个线程生成的。


当线程结束时，所有该线程的行会从 \_history 表中删除，但不会从 \_history\_long 表中删除。

以下示例说明了事件如何被添加到两种历史表以及如何被丢弃。这些原则适用于所有事件类型。该示例基于以下假设：

- Performance Schema 配置为在 \_history 表中每个线程保留 10 行，并在 \_history\_long 表中总共保留 10,000 行。

- 线程 A 每秒生成 1 个事件。

- 线程 B 每秒生成 100 个事件。

- 没有其他线程在运行。


**运行 5 秒后：**

- A 和 B 分别生成了 5 个和 500 个事件。

- \_history 表包含 A 的 5 行和 B 的 10 行。由于每个线程的存储限制为 10 行，A 没有丢弃任何行，而 B 丢弃了 490 行。

- \_history\_long 表包含 A 的 5 行和 B 的 500 行。由于表的最大行数为 10,000 行，因此两者都没有丢弃任何行。


**运行 5 分钟（300 秒）后：**

- A 和 B 分别生成了 300 个和 30,000 个事件。

- \_history 表包含 A 的 10 行和 B 的 10 行。由于每个线程的存储限制为 10 行，A 丢弃了 290 行，而 B 丢弃了 29,990 行。A 的行包含最长 10 秒前的数据，而 B 的行只包含最长 0.1 秒前的数据。

- \_history\_long 表包含 10,000 行。由于 A 和 B 每秒总共生成 101 个事件，该表包含大约 99 秒内的数据，其中 B 的行大约占比 100:1。