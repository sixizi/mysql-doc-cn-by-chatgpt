#### 17.15.1.3 使用压缩信息架构表

##### 示例 17.1 使用压缩信息架构表

以下是包含压缩表的数据库的示例输出（参见第 17.9 节，“InnoDB 表和页面压缩”，`INNODB_CMP`，`INNODB_CMP_PER_INDEX`，和 `INNODB_CMPMEM`）。

下表显示了轻负载下 `INFORMATION_SCHEMA.INNODB_CMP` 的内容。缓冲池包含的唯一压缩页面大小是 8K。自统计信息重置以来，压缩或解压缩页面消耗的时间不到一秒，因为 `COMPRESS_TIME` 和 `UNCOMPRESS_TIME` 列为零。

| 页面大小 | 压缩操作 | 压缩操作成功 | 压缩时间 | 解压操作 | 解压时间 |
| -------- | -------- | ------------ | -------- | -------- | -------- |
| 1024     | 0        | 0            | 0        | 0        | 0        |
| 2048     | 0        | 0            | 0        | 0        | 0        |
| 4096     | 0        | 0            | 0        | 0        | 0        |
| 8192     | 1048     | 921          | 0        | 61       | 0        |
| 16384    | 0        | 0            | 0        | 0        | 0        |

根据 `INNODB_CMPMEM`，缓冲池中有 6169 个压缩的 8KB 页面。唯一其他分配的块大小是 64 字节。`INNODB_CMPMEM` 中最小的 `PAGE_SIZE` 用于那些压缩页面的块描述符，这些页面在缓冲池中没有未压缩的页面。我们看到有 5910 个这样的页面。间接地，我们看到 259（6169-5910）个压缩页面也以未压缩的形式存在于缓冲池中。

下表显示了轻负载下 `INFORMATION_SCHEMA.INNODB_CMPMEM` 的内容。由于压缩页面的内存分配器碎片化，一些内存变得不可用：`SUM(PAGE_SIZE*PAGES_FREE)=6784`。这是因为小内存分配请求通过分割较大的块来满足，从分配给主缓冲池的 16K 块开始，使用伙伴分配系统。碎片化这么低是因为一些分配的块已经被搬移（复制）以形成更大的相邻空闲块。这种复制 `SUM(PAGE_SIZE*RELOCATION_OPS)` 字节消耗的时间不到一秒（`SUM(RELOCATION_TIME)=0`）。

| 页面大小 | 已使用页面 | 空闲页面 | 搬移操作 | 搬移时间 |
| -------- | ---------- | -------- | -------- | -------- |
| 64       | 5910       | 0        | 2436     | 0        |
| 128      | 0          | 1        | 0        | 0        |
| 256      | 0          | 0        | 0        | 0        |
| 512      | 0          | 1        | 0        | 0        |
| 1024     | 0          | 0        | 0        | 0        |
| 2048     | 0          | 1        | 0        | 0        |
| 4096     | 0          | 1        | 0        | 0        |
| 8192     | 6169       | 0        | 5        | 0        |
| 16384    | 0          | 0        | 0        | 0        |