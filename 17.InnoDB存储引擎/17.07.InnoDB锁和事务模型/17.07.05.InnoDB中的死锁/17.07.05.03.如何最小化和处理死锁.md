#### 17.7.5.3 如何最小化和处理死锁

本节基于15.7.5.2节“死锁检测”中关于死锁的概念信息。它解释了如何组织数据库操作以最小化死锁及应用程序中随后需要的错误处理。

死锁是事务型数据库中的一个经典问题，但只有在它们频繁到无法运行某些事务的程度时才是危险的。通常，您必须编写应用程序，以便在事务因死锁而被回滚时始终准备重新发起事务。

InnoDB使用自动行级锁定。即使在仅插入或删除单个行的事务中，您也可能遇到死锁。这是因为这些操作并不真正“原子”；它们自动在行插入或删除的（可能是多个）索引记录上设置锁。

您可以通过以下技术应对死锁并减少其发生的可能性：

- 任何时候，都可以发出 `SHOW ENGINE INNODB STATUS` 命令来确定最近一次死锁的原因。这可以帮助您调整应用程序以避免死锁。
- 如果频繁的死锁警告引起担忧，可以通过启用 `innodb_print_all_deadlocks` 变量来收集更多的调试信息。MySQL错误日志中会记录每个死锁的信息，而不仅仅是最新的一个。在完成调试后禁用此选项。
- 始终准备重新发起由于死锁而失败的事务。死锁并不危险。只需再试一次。
- 保持事务小且持续时间短，以使它们不太容易发生冲突。
- 在进行一系列相关更改后立即提交事务，以使它们不太容易发生冲突。特别是，不要在交互式mysql会话中长时间保持未提交的事务。
- 如果您使用锁定读取（SELECT ... FOR UPDATE 或 SELECT ... FOR SHARE），尝试使用更低的隔离级别，如 READ COMMITTED。
- 在一个事务中修改多个表或同一表的不同行集时，每次以相同的顺序执行这些操作。这样事务形成明确定义的队列，不会发生死锁。例如，在应用程序中将数据库操作组织到函数中，或调用存储过程，而不是在不同位置编码多个类似的 INSERT、UPDATE 和 DELETE 语句序列。
- 在表中添加精心选择的索引，以便您的查询扫描更少的索引记录并设置更少的锁。使用 EXPLAIN SELECT 确定 MySQL 服务器认为最适合您的查询的索引。
- 使用更少的锁定。如果您可以允许SELECT返回旧快照中的数据，请不要向其添加FOR UPDATE或FOR SHARE子句。在这里使用 READ COMMITTED 隔离级别是好的，因为同一事务中的每个一致读取都从自己的新快照中读取。
- 如果没有其他办法，可以使用表级锁来串行化您的事务。与事务型表（如InnoDB表）一起使用 LOCK TABLES 的正确方式是用 SET autocommit = 0（不是 START TRANSACTION）开始事务，然后 LOCK TABLES，并且在显式提交事务之前不要调用 UNLOCK TABLES。例如，如果您需要写入表 t1 并从表 t2 读取，您可以这样做：

  ```sql
  SET autocommit=0;
  LOCK TABLES t1 WRITE, t2 READ, ...;
  ... do something with tables t1 and t2 here ...
  COMMIT;
  UNLOCK TABLES;
  ```
  
  表级锁可以防止对表的并发更新，从而避免死锁，但代价是繁忙系统的响应性降低。

- 另一种串行化事务的方法是创建一个包含单个行的辅助“信号量”表。在访问其他表之前，让每个事务更新该行。这样，所有事务都以串行方式发生。请注意，InnoDB的即时死锁检测算法在这种情况下也有效，因为串行化锁是行级锁。对于MySQL的表级锁，必须使用超时方法来解决死锁。