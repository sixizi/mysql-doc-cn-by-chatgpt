### 17.7.3 InnoDB中不同SQL语句设置的锁

锁定读取、UPDATE或DELETE通常对SQL语句处理中扫描的每个索引记录设置记录锁。无论语句中是否有排除该行的WHERE条件都无关紧要。InnoDB不记得确切的WHERE条件，只知道哪些索引范围被扫描。这些锁通常是也阻止对记录前的“间隙”进行插入的下一个键锁。然而，可以明确地禁用间隙锁定，这会导致不使用下一个键锁。更多信息，请参阅第15.7.1节，“InnoDB锁定”。事务隔离级别也会影响设置哪些锁；参见15.7.2.1节，“事务隔离级别”。

如果在搜索中使用了辅助索引并且要设置的索引记录锁是排他的，InnoDB还会检索相应的聚簇索引记录并对其设置锁。

如果您没有适合您的语句的索引，并且MySQL必须扫描整个表来处理语句，则表的每一行都会被锁定，这反过来又会阻塞其他用户向表中插入。创建良好的索引非常重要，这样您的查询就不会扫描比必要更多的行。

InnoDB按如下方式设置特定类型的锁。

- `SELECT ... FROM` 是一致读取，读取数据库的快照并且不设置锁，除非事务隔离级别设置为SERIALIZABLE。对于SERIALIZABLE级别，搜索在遇到的索引记录上设置共享的下一个键锁。然而，对于使用唯一索引锁定行以搜索唯一行的语句，只需要索引记录锁。

- `SELECT ... FOR UPDATE` 和 `SELECT ... FOR SHARE` 语句使用唯一索引获取扫描行的锁，并释放不符合结果集包含条件的行的锁（例如，如果它们不符合WHERE子句给出的标准）。然而，在某些情况下，行可能不会立即解锁，因为在查询执行期间，结果行与其原始源之间的关系丢失。例如，在UNION中，从表中扫描（并锁定）的行可能在评估它们是否符合结果集之前插入到临时表中。在这种情况下，临时表中的行与原始表中的行之间的关系丢失，直到查询执行结束时后者的行才会解锁。
- 对于锁定读取（带`FOR UPDATE`或`FOR SHARE`的`SELECT`）、`UPDATE`和`DELETE`语句，所采取的锁取决于该语句是否使用具有唯一搜索条件的唯一索引或范围类型搜索条件。
  - 对于具有唯一搜索条件的唯一索引，InnoDB只锁定找到的索引记录，而不是它之前的间隙。
  - 对于其他搜索条件和非唯一索引，InnoDB锁定扫描的索引范围，使用间隙锁或下一个键锁来阻止其他会话将新记录插入到范围所覆盖的间隙中。有关间隙锁和下一个键锁的信息，请参阅第15.7.1节，“InnoDB锁定”。
- 对于搜索遇到的索引记录，`SELECT ... FOR UPDATE` 阻止其他会话执行 `SELECT ... FOR SHARE` 或在某些事务隔离级别中读取。一致读取忽略存在于读取视图中的任何锁定的记录。
- `UPDATE ... WHERE ...` 对搜索遇到的每个记录设置排他的下一个键锁。然而，对于使用唯一索引锁定行以搜索唯一行的语句，只需要索引记录锁。

- 当 UPDATE 修改聚簇索引记录时，会隐式地在受影响的辅助索引记录上设置锁。在插入新的辅助索引记录之前进行重复检查扫描时，以及在插入新的辅助索引记录时，UPDATE 操作还会对受影响的辅助索引记录采取共享锁。


- `DELETE FROM ... WHERE ...` 对搜索遇到的每个记录设置排他的下一个键锁。然而，对于使用唯一索引锁定行以搜索唯一行的语句，只需要索引记录锁。
- `INSERT` 在插入的行上设置排他锁。这个锁是索引记录锁，不是下一个键锁（即没有间隙锁），不会阻止其他会话插入到插入行之前的间隙。
- 在插入行之前，会设置一种称为插入意图间隙锁的间隙锁。这种锁以这样的方式发出插入意图信号：多个事务插入到同一索引间隙时不需要彼此等待，如果它们不是在间隙中的同一位置插入。假设有索引记录值为4和7。分别尝试插入值为5和6的单独事务在获取插入行的排他锁之前用插入意图锁锁定4和7之间的间隙，但由于行不冲突，所以不会互相阻塞。
- 如果发生重复键错误，会在重复的索引记录上设置共享锁。在这种情况下，使用共享锁可能导致死锁，如果有多个会话尝试插入相同的行，而另一个会话已经拥有排他锁。这可能发生在另一个会话删除该行的情况下。假设 InnoDB 表 t1 有以下结构：

  ```sql
  CREATE TABLE t1 (i INT, PRIMARY KEY (i)) ENGINE = InnoDB;
  ```

  现在假设三个会话按顺序执行以下操作：

  会话 1：

  ```sql
  START TRANSACTION;
  INSERT INTO t1 VALUES(1);
  ```

  会话 2：

  ```sql
  START TRANSACTION;
  INSERT INTO t1 VALUES(1);
  ```

  会话 3：

  ```sql
  START TRANSACTION;
  INSERT INTO t1 VALUES(1);
  ```

  会话 1：

  ```sql
  ROLLBACK;
  ```

  会话 1 的第一个操作获取了该行的排他锁。会话 2 和 3 的操作都导致了重复键错误，并且它们都为该行请求了共享锁。当会话 1 回滚时，它释放了该行的排他锁，会话 2 和 3 的排队共享锁请求被授予。此时，会话 2 和 3 发生了死锁：由于另一个拥有共享锁，它们都无法获得该行的排他锁。

  如果表中已经包含键值为1的行，并且三个会话按顺序执行以下操作，将出现类似情况：

  会话 1：

  ```sql
  START TRANSACTION;
  DELETE FROM t1 WHERE i = 1;
  ```

  会话 2：

  ```sql
  START TRANSACTION;
  INSERT INTO t1 VALUES(1);
  ```

  会话 3：

  ```sql
  START TRANSACTION;
  INSERT INTO t1 VALUES(1);
  ```

  会话 1：

  ```sql
  COMMIT;
  ```

  会话 1 的第一个操作获取了该行的排他锁。会话 2 和 3 的操作都导致了重复键错误，并且它们都为该行请求了共享锁。当会话 1 提交时，它释放了该行的排他锁，会话 2 和 3 的排队共享锁请求被授予。此时，会话 2 和 3 发生了死锁：由于另一个拥有共享锁，它们都无法获得该行的排他锁。

- `INSERT ... ON DUPLICATE KEY UPDATE` 与简单的`INSERT`不同，因为在发生重复键错误时，它会在要更新的行上放置排他锁而不是共享锁。对于重复的主键值，会采取排他索引记录锁。对于重复的唯一键值，会采取排他下一个键锁。

- `REPLACE` 的执行类似于`INSERT`，如果没有唯一键冲突的话。否则，会在要替换的行上放置排他下一个键锁。

- `INSERT INTO T SELECT ... FROM S WHERE ...` 在T中插入的每一行上设置排他索引记录锁（没有间隙锁）。如果事务隔离级别为已提交读（READ COMMITTED），InnoDB会将对S的搜索作为一致读取（无锁）。否则，InnoDB在来自S的行上设置共享下一个键锁。在后一种情况下，InnoDB必须设置锁：在使用基于语句的二进制日志进行向前恢复时，每个SQL语句必须以与最初执行时完全相同的方式执行。

  `CREATE TABLE ... SELECT ...` 的执行将`SELECT`以共享下一个键锁或作为一致读取进行，与 INSERT ... SELECT 相同。

  当`SELECT`用于 REPLACE INTO t SELECT ... FROM s WHERE ... 或 `UPDATE t ... WHERE col IN (SELECT ... FROM s ...)` 构造中时，InnoDB会在来自表s的行上设置共享下一个键锁。

- 当初始化表上先前指定的`AUTO_INCREMENT`列时，InnoDB会在与`AUTO_INCREMENT`列相关联的索引末端上设置排他锁。

  当`innodb_autoinc_lock_mode=`0时，InnoDB使用一种特殊的AUTO-INC表锁模式，在访问自增计数器时获取并保持到当前SQL语句结束（而不是到整个事务结束）的锁。当持有AUTO-INC表锁时，其他客户端不能向表中插入。在`innodb_autoinc_lock_mode=1`下进行“批量插入”时也会出现相同的行为。在`innodb_autoinc_lock_mode=2`下不使用表级AUTO-INC锁。更多信息，请参见第15.6.1.6节，“InnoDB中的AUTO_INCREMENT处理”。

  InnoDB在获取先前初始化的`AUTO_INCREMENT`列的值时不设置任何锁。

- 如果在表上定义了`FOREIGN KEY`约束，则任何插入、更新或删除操作需要检查约束条件，都会在检查约束时查看的记录上设置共享记录级锁。如果约束失败，InnoDB也会设置这些锁。

- LOCK TABLES设置表锁，但它是高于InnoDB层的MySQL层设置的锁。如果`innodb_table_locks=1`（默认值）且`autocommit=0`，InnoDB会意识到表锁，高于InnoDB的MySQL层也会知道行级锁。

  否则，InnoDB的自动死锁检测无法检测到涉及此类表锁的死锁。此外，由于在这种情况下，高MySQL层不知道行级锁，因此可能会在其他会话当前持有行级锁的表上获取表锁。然而，这并不危及事务完整性，如第15.7.5.2节“死锁检测”中讨论的。

- LOCK TABLES在`innodb_table_locks=1`（默认值）的情况下会在每个表上获取两个锁。除了在MySQL层上的表锁外，它还会获取一个InnoDB表锁。要避免获取InnoDB表锁，请设置`innodb_table_locks=0`。如果没有获取InnoDB表锁，即使其他事务正在锁定表的某些记录，LOCK TABLES也会完成。

  在MySQL 8.0中，innodb_table_locks=0对于显式用`LOCK TABLES ... WRITE`锁定的表没有效果。但对于隐式用LOCK TABLES ... WRITE（例如，通过触发器）或`LOCK TABLES ... READ`锁定的表有效。

- 所有InnoDB事务持有的锁在事务提交或中止时释放。因此，在autocommit=1模式下对InnoDB表调用`LOCK TABLES`没有多大意义，因为获得的InnoDB表锁将立即释放。

- 您不能在事务中间锁定额外的表，因为LOCK TABLES执行隐式的COMMIT和UNLOCK TABLES。