### 17.12.1 在线 DDL 操作

本节提供了 DDL 操作的在线支持详情、语法示例和使用说明，涵盖以下主题：

- [索引操作](#索引操作)
- [主键操作](#主键操作)
- [列操作](#列操作)
- [生成列操作](#生成列操作)
- [外键操作](#外键操作)
- [表操作](#表操作)
- [表空间操作](#表空间操作)
- [分区操作](#分区操作)

#### 索引操作

下表提供了对索引操作的在线 DDL 支持概览。星号表示附加信息、异常或依赖关系。详情见语法和使用说明。

表 17.16 索引操作的在线 DDL 支持

| 操作                           | 即时 | 就地 | 重建表 | 允许并发 DML | 仅修改元数据 |
|------------------------------|------|------|--------|-------------|------------|
| 创建或添加二级索引                 | 否   | 是   | 否     | 是          | 否         |
| 删除索引                        | 否   | 是   | 否     | 是          | 是         |
| 重命名索引                       | 否   | 是   | 否     | 是          | 是         |
| 添加 FULLTEXT 索引            | 否   | 是*  | 否*    | 否          | 否         |
| 添加 SPATIAL 索引             | 否   | 是   | 否     | 否          | 否         |
| 更改索引类型                     | 是   | 是   | 否     | 是          | 是         |

##### 语法和使用说明

- 创建或添加二级索引

  ```sql
  CREATE INDEX name ON table (col_list);
  ALTER TABLE tbl_name ADD INDEX name (col_list);
  ```

  在创建索引时，表仍可进行读写操作。`CREATE INDEX` 语句只有在访问表的所有事务完成后才结束，以便索引的初始状态反映表的最新内容。

  添加二级索引的在线 DDL 支持意味着，您可以通过先创建没有二级索引的表，然后在数据加载后添加二级索引，来加速整个创建和加载表及其关联索引的过程。

  新创建的二级索引仅包含 `CREATE INDEX` 或 `ALTER TABLE` 语句执行完成时表中的已提交数据。它不包含任何未提交的值、旧版本的值或标记为删除但尚未从旧索引中移除的值。


- 删除索引

  ```sql
  DROP INDEX name ON table;
  ALTER TABLE tbl_name DROP INDEX name;
  ```

  在删除索引时，表仍可进行读写操作。`DROP INDEX` 语句只有在访问表的所有事务完成后才结束，以便索引的初始状态反映表的最新内容。


- 重命名索引

  ```sql
  ALTER TABLE tbl_name RENAME INDEX old_index_name TO new_index_name, ALGORITHM=INPLACE, LOCK=NONE;
  ```

- 添加 FULLTEXT 索引

  ```sql
  CREATE FULLTEXT INDEX name ON table(column);
  ```

  如果没有用户定义的 FTS_DOC_ID 列，则添加第一个 FULLTEXT 索引会重建表。可以添加额外的 FULLTEXT 索引而不重建表。

- 添加 SPATIAL 索引

  ```sql
  CREATE TABLE geom (g GEOMETRY NOT NULL);
  ALTER TABLE geom ADD SPATIAL INDEX(g), ALGORITHM=INPLACE, LOCK=SHARED;
  ```

- 更改索引类型（使用 {BTREE | HASH}）

  ```sql
  ALTER TABLE tbl_name DROP INDEX i1, ADD INDEX i1(key_part,...) USING BTREE, ALGORITHM=INSTANT;
  ```

#### 主键操作

下表提供了对主键操作的在线 DDL 支持概览。星号表示附加信息、异常或依赖关系。详见语法和使用说明。

表 17.17 主键操作的在线 DDL 支持

| 操作                             | 即时 | 就地 | 重建表 | 允许并发 DML | 仅修改元数据 |
|--------------------------------|------|------|--------|-------------|------------|
| 添加主键                         | 否   | 是*  | 是*    | 是          | 否         |
| 删除主键                         | 否   | 否   | 是     | 否          | 否         |
| 删除主键并添加另一个主键           | 否   | 是   | 是     | 是          | 否         |

##### 语法和使用说明

- 添加主键

  ```sql
  ALTER TABLE tbl_name ADD PRIMARY KEY (column), ALGORITHM=INPLACE, LOCK=NONE;
  ```

  就地重建表。数据被大量重新组织，使其成为一项昂贵的操作。在某些条件下，如果列需要转换为 NOT NULL，则不允许使用 ALGORITHM=INPLACE。

  重组聚集索引总是需要复制表数据。因此，最好在创建表时定义主键，而不是稍后使用 `ALTER TABLE ... ADD PRIMARY KEY`。

  当您创建 UNIQUE 或 PRIMARY KEY 索引时，MySQL 需要进行一些额外工作。对于 UNIQUE 索引，MySQL 检查表中是否存在键的重复值。对于 PRIMARY KEY 索引，MySQL 还检查 PRIMARY KEY 列中是否包含 NULL。

  使用 ALGORITHM=COPY 子句添加主键时，MySQL 将相关列中的 NULL 值转换为默认值：数字为 0，字符型列和 BLOBs 为空字符串，DATETIME 为 0000-00-00 00:00:00。这是 Oracle 不推荐依赖的非标准行为。仅当 SQL_MODE 设置包含 strict_trans_tables 或 strict_all_tables 标志时，才允许使用 ALGORITHM=INPLACE 添加主键；当 SQL_MODE 设置为严格时，允许使用 ALGORITHM=INPLACE，但如果请求的主键列中包含 NULL 值，语句仍然可能失败。ALGORITHM=INPLACE 的行为更符合标准。

  如果您创建一个没有主键的表，InnoDB 会为您选择一个，可以是定义在 NOT NULL 列上的第一个 UNIQUE 键，或一个系统生成的键。为了避免不确定性和可能需要额外隐藏列的空间要求，请在 CREATE TABLE 语句中指定 PRIMARY KEY 子句。

  MySQL 通过将原始表中的现有数据复制到具有所需索引结构的临时表来创建一个新的聚集索引。一旦数据完全复制到临时表中，原始表就会被重命名为不同的临时表名称。包含新聚集索引的临时表将被重命名为原始表的名称，并且原始表将从数据库中删除。

  适用于二级索引操作的在线性能增强不适用于主键索引。InnoDB 表的行存储在基于主键组织的聚集索引中，形成了一些数据库系统所称的“索引组织表”。因为表结构与主键紧密相关，重新定义主键仍然需要复制数据。

  当主键操作使用 ALGORITHM=INPLACE 时，尽管数据仍然被复制，但它比使用 ALGORITHM=COPY 更高效，因为：

  - 对于 ALGORITHM=INPLACE，不需要撤销日志或相关的重做日志。这些操作为使用 ALGORITHM=COPY 的 DDL 语句增加了开销。
  - 二级索引条目是预排序的，因此可以按顺序加载。
  - 不使用变更缓冲区，因为没有随机访问插入到二级索引中。

- 删除主键

  ```sql
  ALTER TABLE tbl_name DROP PRIMARY KEY, ALGORITHM=COPY;
  ```

  仅 ALGORITHM=COPY 支持在同一 ALTER TABLE 语句中删除主键而不添加新主键。

- 删除主键并添加另一个主键

  ```sql
  ALTER TABLE tbl_name DROP PRIMARY KEY, ADD PRIMARY KEY (column), ALGORITHM=INPLACE, LOCK=NONE;
  ```

  数据被大量重新组织，使其成为一项昂贵的操作。