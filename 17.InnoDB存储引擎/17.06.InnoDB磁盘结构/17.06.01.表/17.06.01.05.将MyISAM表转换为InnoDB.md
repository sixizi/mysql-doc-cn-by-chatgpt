#### 17.6.1.5 将MyISAM表转换为InnoDB表

如果您有想要转换为InnoDB的MyISAM表，以获得更好的可靠性和可伸缩性，请在转换前参考以下指南和提示。

> **注意**
>
> 在MySQL早期版本中创建的分区MyISAM表与MySQL 8.0不兼容。这些表必须在升级前进行准备，要么移除分区，要么转换为InnoDB。有关更多信息，请参见24.6.2节，“与存储引擎相关的分区限制”。

- [调整MyISAM和InnoDB的内存使用](#调整MyISAM和InnoDB的内存使用)
- [处理过长或过短的事务](#处理过长或过短的事务)
- [处理死锁](#处理死锁)
- [存储布局](#存储布局)
- [转换现有表](#转换现有表)
- [克隆表的结构](#克隆表的结构)
- [转移数据](#转移数据)
- [存储需求](#存储需求)
- [定义主键](#定义主键)
- [应用性能考虑因素](#应用性能考虑因素)
- [了解与InnoDB表相关的文件](#了解与InnoDB表相关的文件)

##### 调整MyISAM和InnoDB的内存使用

当您从MyISAM表过渡时，降低`key_buffer_size`配置选项的值以释放不再需要的用于缓存结果的内存。增加`innodb_buffer_pool_size`配置选项的值，这个选项为InnoDB表分配缓存内存，起到类似的作用。InnoDB缓冲池缓存表数据和索引数据，加速查询的查找并将查询结果保留在内存中以供重用。有关缓冲池大小配置的指导，请参见8.12.3.1节，“MySQL如何使用内存”。

##### 处理过长或过短的事务

由于MyISAM表不支持事务，您可能没有太注意`autocommit`配置选项以及`COMMIT`和`ROLLBACK`语句。这些关键字对于允许多个会话同时读写InnoDB表非常重要，为写入密集型工作负载提供了可观的可伸缩性好处。

当事务打开时，系统保留事务开始时数据的快照，如果

系统在一个偏离的事务持续运行时插入、更新和删除数百万行，这可能导致显著的开销。因此，要注意避免运行时间过长的事务：

- 如果您在交互式mysql会话中进行实验，请始终使用`COMMIT`（完成更改）或`ROLLBACK`（撤销更改）。关闭交互式会话，而不是长时间保持开启状态，以避免意外地长时间保持事务开启。
- 确保您的应用程序中的任何错误处理程序也要执行`ROLLBACK`以回滚不完整的更改或`COMMIT`以提交完成的更改。

`ROLLBACK`是一个相对昂贵的操作，因为对InnoDB表的`INSERT`、`UPDATE`和`DELETE`操作在`COMMIT`之前被写入，预期大多数更改会成功提交，回滚操作很少见。在处理大量数据时，避免对大量行进行更改然后回滚这些更改。

在使用一系列`INSERT`语句加载大量数据时，定期`COMMIT`结果，以避免事务持续数小时。在典型的数据仓库加载操作中，如果出现问题，您可以使用`TRUNCATE TABLE`截断表，并从头开始，而不是执行`ROLLBACK`。

上述技巧节省了在过长事务中可能浪费的内存和磁盘空间。当事务比应该的时间更短时，问题是过多的I/O。每次`COMMIT`时，MySQL确保每次更改都安全地记录到磁盘，这涉及一些I/O。

对于InnoDB表的大多数操作，您应该使用`autocommit=0`设置。从效率的角度来看，这避免了在发出大量连续的`INSERT`、`UPDATE`或`DELETE`语句时不必要的I/O。从安全的角度来看，这允许您发出`ROLLBACK`语句以恢复在mysql命令行上或应用程序的异常处理程序中出现错误时丢失或混乱的数据。

当运行一系列用于生成报告或分析统计的查询时，`autocommit=1`适用于InnoDB表。在这种情况下，与`COMMIT`或`ROLLBACK`相关的I/O开销不存在，InnoDB可以自动优化只读工作负载。

如果您进行一系列相关更改，请在最后使用单个`COMMIT`一次性完成所有更改。例如，如果您将相关信息插入多个表，请在进行所有更改后执行单个`COMMIT`。或者，如果您运行了许多连续的`INSERT`语句，请在所有数据加载完毕后执行单个`COMMIT`；如果您执行了数百万个`INSERT`语句，您可能需要在每隔一万或十万条记录后发出`COMMIT`，以防事务变得过大。

记住，即使是`SELECT`语句也会打开一个事务，所以在交互式mysql会话中运行一些报告或调试查询后，要么发出`COMMIT`，要么关闭mysql会话。

有关相关信息，请参见15.7.2.2节，“autocommit, Commit和Rollback”。

##### 处理死锁

您可能会在MySQL错误日志中或`SHOW ENGINE INNODB STATUS`的输出中看到关于“死锁”的警告消息。对于InnoDB表来说，死锁不是一个严重的问题，通常不需要任何纠正措施。当两个事务开始修改多个表，并以不同的顺序访问表时，它们可能会达到一种状态，即每个事务都在等待另一个，而双方都无法继续。当启用死锁检测（默认情况下）时，MySQL会立即检测到这种情况，并取消（回滚）“较小”的事务，让另一个事务继续进行。如果使用`innodb_deadlock_detect`配置选项禁用了死锁检测，InnoDB依赖于`innodb_lock_wait_timeout`设置来在发生死锁时回滚事务。

无论哪种方式，您的应用程序都需要错误处理逻辑来重启由于死锁而被强制取消的事务。当您重新发出与之前相同的SQL语句时，原始的定时问题不再适用。要么另一个事务已经完成，您的事务可以继续进行；要么另一个事务仍在进行中，您的事务等待直到它完成。

如果死锁警告不断发生，您可能需要审查应用程序代码，以一致的方式重新排序SQL操作，或缩短事务。您可以启用`innodb_print_all_deadlocks`选项来在MySQL错误日志中查看所有死锁警告，而不仅是`SHOW ENGINE INNODB STATUS`输出中的最后一个警告。

有关更多信息，请参见15.7.5节，“InnoDB中的死锁”。

##### 存储布局

要从InnoDB表获得最佳性能，您可以调整与存储布局相关的多个参数。

当您转换大型、频繁访问且保存重要数据的MyISAM表时，调查并考虑`innodb_file_per_table和`innodb_page_size`变量，以及`CREATE TABLE`语句的`ROW_FORMAT`和`KEY_BLOCK_SIZE`子句。

在您的初始实验中，最重要的设置是`innodb_file_per_table`。当启用此设置（默认情况下），新创建的InnoDB表隐式地创建在文件每表表空间中。与InnoDB系统表空间相比，文件每表表空间允许在截断或删除表时由操作系统回收磁盘空间。文件每表表空间还支持DYNAMIC和COMPRESSED行格式及相关功能，如表压缩、长变长列的高效离页存储和大索引前缀。有关更多信息，请参见15.6.3.2节，“文件每表表空间”。

您还可以将InnoDB表存储在共享通用表空间中，它支持多个表和所有行格式。更多信息，请参见15.6.3.3节，“通用表空间”。

##### 转换现有表

要将非InnoDB表转换为使用InnoDB，请使用`ALTER TABLE`：

```sql
ALTER TABLE table_name ENGINE=InnoDB;
```

##### 克隆表的结构

在使用`ALTER TABLE`执行转换之前，您可能会创建一个与MyISAM表相同的InnoDB表，以便在切换之前并行测试旧表和新表。

创建一个具有相同列和索引定义的空InnoDB表。使用`SHOW CREATE TABLE table_name\G`查看完整的`CREATE TABLE`语句。将`ENGINE`子句更改为`ENGINE=INNODB`。

##### 转移数据

要将大量数据传输到如上一节所示创建的空InnoDB表中，请插入行，使用`INSERT INTO innodb_table SELECT * FROM myisam_table ORDER BY primary_key_columns`。

您还可以在插入数据后为InnoDB表创建索引。历史上，为InnoDB创建新的二级索引是一个缓慢的操作，但现在您可以在数据加载后以相对较少的开销创建索引。

如果您在二级键上有唯一性约束，可以在导入操作期间暂时关闭唯一性检查以加快表导入速度：

```sql
SET unique_checks=0;
... 导入操作 ...
SET unique_checks=1;
```

对于大表，这可以节省磁盘I/O，因为InnoDB可以使用其更改缓冲区将二级索引记录作为批量写入。但请确保数据中没有重复键。`unique_checks`允许但不要求存储引擎忽略重复键。

为了更好地控制插入过程，您可以分批插入大表：

```sql
INSERT INTO newtable SELECT * FROM oldtable
   WHERE yourkey > something AND yourkey <= somethingelse;
```

在插入所有记录后，您可以重命名表。

在转换大型表的过程中，增加InnoDB缓冲池的大小以减少磁盘I/O。通常，建议的缓冲池大小为系统内存的50%到75%。您还可以增加InnoDB日志文件的大小。

##### 存储需求

如果您打算在转换过程中在InnoDB表中创建数据的几个临时副本，建议您在文件每表表空间中创建表，以便在删除表时回收磁盘空间。当启用`innodb_file_per_table`配置选项（默认情况下）时，新创建的InnoDB表隐式地创建在文件每表表空间中。

无论您是直接转换MyISAM表还是创建克隆的InnoDB表，请确保在过程中有足够的磁盘空间容纳旧表和新表。InnoDB表需要的磁盘空间比MyISAM表多。如果`ALTER TABLE`操作耗尽空间，它将开始回滚，如果是磁盘受限，这可能需要数小时。对于插入，InnoDB使用插入缓冲区将二级索引记录批量合并到索引中。这节省了大量的磁盘I/O。对于回滚，没有使用这样的机制，回滚可能比插入慢30倍。

在回滚失控的情况下，如果您的数据库中没有宝贵的数据，可能建议杀死数据库进程，而不是等待数百万个磁盘I/O操作完成。完整程序，请参见15.21.3节，“强制InnoDB恢复”。

##### 定义主键

`PRIMARY KEY`子句是影响MySQL查询性能和表及索引空间使用的关键因素。主键唯一地标识表中的一行。表中的每一行应该有一个主键值，且没有两行可以具有相同的主键值。

以下是一些有关主键的指导原则，以及更详细的解释。

- 为每个表声明一个`PRIMARY KEY`。通常，它是您在WHERE子句中引用的最重要的列，用于查找单个行。
- 在最初的`CREATE TABLE`语句中声明`PRIMARY KEY`子句，而不是通过`ALTER TABLE`语句稍后添加它。

- 仔细选择列及其数据类型。相较于字符或字符串类型，优先选择数字类型的列。
- 考虑使用自增长列，如果没有其他稳定、唯一、非空、数值类型的列可用。
- 如果有任何疑问主键列的值是否可能更改，使用自增长列也是个好选择。更改主键列的值是一个昂贵的操作，可能涉及重新排列表中的数据以及每个二级索引中的数据。

考虑为没有主键的表添加主键。根据表的最大预计大小，使用尽可能小的实用数字类型。这可以使每行稍微紧凑一些，对于大型表来说可以节省大量空间。如果表有任何二级索引，这种空间节省会被乘以多次，因为主键值在每个二级索引条目中都会重复。除了减少磁盘上的数据大小，小的主键还可以让更多数据适应缓冲池，加速各种操作并提高并发性。

如果表已经有一个较长列的主键，例如`VARCHAR`，考虑添加一个新的无符号`AUTO_INCREMENT`列，并将主键切换到该列，即使该列在查询中未被引用。这种设计更改可以在二级索引中产生显著的空间节省。您可以将原主键列指定为`UNIQUE NOT NULL`，以执行与`PRIMARY KEY`子句相同的约束，即防止所有这些列中出现重复或空值。

如果您将相关信息分布在多个表中，通常每个表都使用相同的列作为其主键。例如，人事数据库可能有几个表，每个表都以员工号作为主键。销售数据库可能有一些表以客户号作为主键，其他表以订单号作为主键。由于使用主键进行查找非常快，您可以构造高效的联接查询。

如果您完全省略`PRIMARY KEY`子句，MySQL将为您创建一个不可见的主键。它是一个6字节的值，可能比您需要的更长，从而浪费空间。因为它是隐藏的，您无法在查询中引用它。

##### 应用性能考虑因素

InnoDB的可靠性和可伸缩性特性需要比相当的MyISAM表更多的磁盘存储空间。您可能会稍微更改列和索引定义，以便更好地利用空间，减少处理结果集时的I/O和内存消耗，并获得更有效利用索引查找的查询优化计划。

如果您为主键设置了数值ID列，请使用该值在其他表中与相关值进行交叉引用，特别是对于联接查询。例如，与其接受一个国家名称作为输入并进行搜索相同名称的查询，不如先进行一次查找以确定国家ID，然后进行其他查询（或单个联接查询）以查找多个表中的相关信息。与其将客户或目录项目号作为一串数字存储，占用几个字节，不如将其转换为数值ID进行存储和查询。一个4字节无符号的`INT`列可以索引超过40亿项（以美国对十亿的理解：1000百万）。有关不同整数类型范围的信息，请参见11.1.2节，“整数类型（精确值）- INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT”。

##### 了解与InnoDB表相关的文件

与MyISAM文件相比，InnoDB文件需要更多的关注和规划。

- 您绝不能删除代表InnoDB系统表空间的`ibdata`文件。
- 将InnoDB表移动或复制到不同服务器的方法在15.6.1.4节，“移动或复制InnoDB表”中有描述。
