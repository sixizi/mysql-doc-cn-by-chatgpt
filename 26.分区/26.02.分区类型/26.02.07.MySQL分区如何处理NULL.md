### 26.2.7 MySQL 分区如何处理 NULL

在 MySQL 中，分区不禁止将 NULL 作为分区表达式的值，无论它是列值还是用户提供的表达式值。即使允许使用 NULL 作为必须返回整数的表达式的值，也需要注意 NULL 不是一个数字。MySQL 的分区实现将 NULL 视为小于任何非 NULL 值，就像 `ORDER BY` 所做的一样。

这意味着不同类型的分区对 NULL 的处理方式不同，如果您没有做好准备，可能会产生意外的行为。本节将讨论每种 MySQL 分区类型在确定应将行存储在哪个分区时如何处理 NULL 值，并提供相应的示例。

#### RANGE 分区中处理 NULL

如果将一行插入到按 RANGE 分区的表中，并且用于确定分区的列值为 NULL，则该行将插入到最低的分区中。考虑在名为 `p` 的数据库中创建的以下两个表：

```sql
CREATE TABLE t1 (
    c1 INT,
    c2 VARCHAR(20)
)
PARTITION BY RANGE(c1) (
    PARTITION p0 VALUES LESS THAN (0),
    PARTITION p1 VALUES LESS THAN (10),
    PARTITION p2 VALUES LESS THAN MAXVALUE
);

CREATE TABLE t2 (
    c1 INT,
    c2 VARCHAR(20)
)
PARTITION BY RANGE(c1) (
    PARTITION p0 VALUES LESS THAN (-5),
    PARTITION p1 VALUES LESS THAN (0),
    PARTITION p2 VALUES LESS THAN (10),
    PARTITION p3 VALUES LESS THAN MAXVALUE
);
```

您可以使用以下查询查看这两个 `CREATE TABLE` 语句创建的分区：

```sql
SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME LIKE 't_';
```

输出结果如下：

```
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| t1         | p0             |          0 |              0 |           0 |
| t1         | p1             |          0 |              0 |           0 |
| t1         | p2             |          0 |              0 |           0 |
| t2         | p0             |          0 |              0 |           0 |
| t2         | p1             |          0 |              0 |           0 |
| t2         | p2             |          0 |              0 |           0 |
| t2         | p3             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
```

现在让我们向每个表中插入包含 NULL 的行，并使用一对 SELECT 语句验证这些行是否插入：

```sql
INSERT INTO t1 VALUES (NULL, 'mothra');
INSERT INTO t2 VALUES (NULL, 'mothra');

SELECT * FROM t1;
SELECT * FROM t2;
```

输出结果如下：

```
+------+--------+
| c1   | c2     |
+------+--------+
| NULL | mothra |
+------+--------+

+------+--------+
| c1   | c2     |
+------+--------+
| NULL | mothra |
+------+--------+
```

您可以通过重新运行之前的 `INFORMATION_SCHEMA.PARTITIONS` 查询并检查输出来查看插入的行存储在哪些分区：

```sql
SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME LIKE 't_';
```

输出结果如下：

```
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| t1         | p0             |          1 |             20 |          20 |
| t1         | p1             |          0 |              0 |           0 |
| t1         | p2             |          0 |              0 |           0 |
| t2         | p0             |          1 |             20 |          20 |
| t2         | p1             |          0 |              0 |           0 |
| t2         | p2             |          0 |              0 |           0 |
| t2         | p3             |          0 |              0 |           0 |
+------------+----------------+------------+----------------+-------------+
```

您还可以通过删除这些分区并重新执行 SELECT 语句来验证这些行存储在哪些分区：

```sql
ALTER TABLE t1 DROP PARTITION p0;
ALTER TABLE t2 DROP PARTITION p0;

SELECT * FROM t1;
SELECT * FROM t2;
```

结果如下：

```
Empty set (0.00 sec)
Empty set (0.00 sec)
```

对于使用 SQL 函数的分区表达式，NULL 也会被这样处理。例如，我们可以使用以下 `CREATE TABLE` 语句定义一个表：

```sql
CREATE TABLE tndate (
    id INT,
    dt DATE
)
PARTITION BY RANGE( YEAR(dt) ) (
    PARTITION p0 VALUES LESS THAN (1990),
    PARTITION p1 VALUES LESS THAN (2000),
    PARTITION p2 VALUES LESS THAN MAXVALUE
);
```

与其他 MySQL 函数一样，`YEAR(NULL)` 返回 NULL。`dt` 列值为 NULL 的行被视为分区表达式计算结果小于任何其他值，并因此插入到分区 `p0`。

#### LIST 分区中处理 NULL

按 LIST 分区的表只有在其分区之一的值列表中包含 NULL 时才允许 NULL 值。如果 LIST 分区的表没有显式在值列表中使用 NULL，则会拒绝导致分区表达式为 NULL 值的行，如以下示例所示：

```sql
CREATE TABLE ts1 (
    c1 INT,
    c2 VARCHAR(20)
)
PARTITION BY LIST(c1) (
    PARTITION p0 VALUES IN (0, 3, 6),
    PARTITION p1 VALUES IN (1, 4, 7),
    PARTITION p2 VALUES IN (2, 5, 8)
);

INSERT INTO ts1 VALUES (9, 'mothra');
-- ERROR 1504 (HY000): Table has no partition for value 9

INSERT INTO ts1 VALUES (NULL, 'mothra');
-- ERROR 1504 (HY000): Table has no partition for value NULL
```

只有 `c1` 值在 0 到 8 之间的行可以插入到 `ts1` 中。NULL 超出此范围，就像数字 9 一样。我们可以创建值列表中包含 NULL 的表 `ts2` 和 `ts3`，如下所示：

```sql
CREATE TABLE ts2 (
    c1 INT,
    c2 VARCHAR(20)
)
PARTITION BY LIST(c1) (
    PARTITION p0 VALUES IN (0, 3, 6),
    PARTITION p1 VALUES IN (1, 4, 7),
    PARTITION p2 VALUES IN (2, 5, 8),
    PARTITION p3 VALUES IN (NULL)
);

CREATE TABLE ts3 (
    c1 INT,
    c2 VARCHAR(20)
)
PARTITION BY LIST(c1) (
    PARTITION p0 VALUES IN (0, 3, 6),
    PARTITION p1 VALUES IN (1, 4, 7, NULL),
    PARTITION p2 VALUES IN (2, 5, 8)
);
```

在定义分区的值列表时，您可以（也应该）像对待任何其他值一样对待 NULL。例如，`VALUES IN (NULL)` 和 `VALUES IN (1, 4, 7, NULL)` 是有效的，`VALUES IN (1, NULL, 4, 7)`、`VALUES IN (NULL, 1, 4, 7)` 等也是有效的。您可以向 `ts2` 和 `ts3` 表中插入 `c1` 为 NULL 的行：

```sql
INSERT INTO ts2 VALUES (NULL, 'mothra');
INSERT INTO ts3 VALUES (NULL, 'mothra');
```

通过在 `INFORMATION_SCHEMA.PARTITIONS` 中执行相应查询，可以确定存储刚插入的行的分区（我们假设与前面的示例一样，分区表是在 `p` 数据库中创建的）：

```sql
SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH, DATA_LENGTH
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME LIKE 'ts_';
```

输出结果如下：

```
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| ts2        | p0             |          0 |              0 |           0 |
| ts2        | p1             |          