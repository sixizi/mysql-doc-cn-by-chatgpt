# 26.6 分区的限制和局限

## 26.6.1 分区键、主键和唯一键

## 26.6.2 与存储引擎相关的分区限制

## 26.6.3 与函数相关的分区限制

本节讨论了 MySQL 分区支持的当前限制和局限。

### 禁止的构造
在分区表达式中不允许使用以下构造：

- 存储过程、存储函数、可加载函数或插件。
- 声明的变量或用户变量。

有关在分区表达式中允许使用的 SQL 函数的列表，请参见 [26.6.3 节，“与函数相关的分区限制”](#26-6-3-与函数相关的分区限制)。

### 算术和逻辑运算符
在分区表达式中允许使用算术运算符 `+`、`-` 和 `*`。但是，结果必须是整数值或 `NULL`（除了 [LINEAR] KEY 分区之外，如本章其他部分所讨论的，详情参见 [26.2 节，“分区类型”](#26-2-分区类型)）。

支持 `DIV` 运算符；不允许使用 `/` 运算符。

在分区表达式中不允许使用位运算符 `|`、`&`、`^`、`<<`、`>>` 和 `~`。

### 服务器 SQL 模式
使用用户定义分区的表不保留它们在创建时生效的 SQL 模式。如本手册其他地方所讨论的（参见 [7.1.11 节，“服务器 SQL 模式”](#7-1-11-服务器-sql-模式)），许多 MySQL 函数和运算符的结果可能会根据服务器 SQL 模式的不同而变化。因此，在创建分区表后任何时候更改 SQL 模式都可能导致此类表的行为发生重大变化，并且可能会导致数据损坏或丢失。因此，强烈建议在创建分区表后不要更改服务器 SQL 模式。

考虑以下 `CREATE TABLE` 语句，只有在 `NO_UNSIGNED_SUBTRACTION` 模式生效时才能成功执行：

```sql
mysql> SELECT @@sql_mode;
+------------+
| @@sql_mode |
+------------+
|            |
+------------+
1 row in set (0.00 sec)

mysql> CREATE TABLE tu (c1 BIGINT UNSIGNED)
    ->   PARTITION BY RANGE(c1 - 10) (
    ->     PARTITION p0 VALUES LESS THAN (-5),
    ->     PARTITION p1 VALUES LESS THAN (0),
    ->     PARTITION p2 VALUES LESS THAN (5),
    ->     PARTITION p3 VALUES LESS THAN (10),
    ->     PARTITION p4 VALUES LESS THAN (MAXVALUE)
    -> );
ERROR 1563 (HY000): Partition constant is out of partition function domain

mysql> SET sql_mode='NO_UNSIGNED_SUBTRACTION';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT @@sql_mode;
+-------------------------+
| @@sql_mode              |
+-------------------------+
| NO_UNSIGNED_SUBTRACTION |
+-------------------------+
1 row in set (0.00 sec)

mysql> CREATE TABLE tu (c1 BIGINT UNSIGNED)
    ->   PARTITION BY RANGE(c1 - 10) (
    ->     PARTITION p0 VALUES LESS THAN (-5),
    ->     PARTITION p1 VALUES LESS THAN (0),
    ->     PARTITION p2 VALUES LESS THAN (5),
    ->     PARTITION p3 VALUES LESS THAN (10),
    ->     PARTITION p4 VALUES LESS THAN (MAXVALUE)
    -> );
Query OK, 0 rows affected (0.05 sec)
```

如果在创建 `tu` 后移除 `NO_UNSIGNED_SUBTRACTION` 服务器 SQL 模式，则可能无法再访问此表：

```sql
mysql> SET sql_mode='';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT * FROM tu;
ERROR 1563 (HY000): Partition constant is out of partition function domain
mysql> INSERT INTO tu VALUES (20);
ERROR 1563 (HY000): Partition constant is out of partition function domain
```

参见 [7.1.11 节，“服务器 SQL 模式”](#7-1-11-服务器-sql-模式)。

服务器 SQL 模式也会影响分区表的复制。源和副本上的 SQL 模式不同可能导致分区表达式的评估结果不同；这可能导致在源和副本的给定表副本中分区之间的数据分布不同，甚至可能导致在源上成功的分区表插入在副本上失败。为了获得最佳效果，应始终在源和副本上使用相同的服务器 SQL 模式。

### 性能考虑
分区操作对性能的某些影响如下所示：

#### 文件系统操作
分区和重新分区操作（如使用 `PARTITION BY ...`、`REORGANIZE PARTITION` 或 `REMOVE PARTITIONING` 的 `ALTER TABLE`）依赖于文件系统操作来实现。这意味着这些操作的速度受文件系统类型和特性、磁盘速度、交换空间、操作系统的文件处理效率以及与文件处理相关的 MySQL 服务器选项和变量的影响。特别是，您应该确保启用了 `large_files_support`，并且正确设置了 `open_files_limit`。涉及 InnoDB 表的分区和重新分区操作可以通过启用 `innodb_file_per_table` 来提高效率。

参见最大分区数。

#### 表锁
通常，对表执行分区操作的进程会对表进行写锁定。从这些表中读取相对不受影响；挂起的 `INSERT` 和 `UPDATE` 操作将在分区操作完成后立即执行。有关此限制的 InnoDB 特定例外，请参见分区操作。

#### 索引；分区修剪
与非分区表一样，正确使用索引可以显著加快分区表的查询速度。此外，设计分区表和这些表上的查询以利用分区修剪可以显著提高性能。详情参见 [26.4 节，“分区修剪”](#26-4-分区修剪)。

支持对分区表的索引条件下推优化。参见 [10.2.1.6 节，“索引条件下推优化”](https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html)。

#### 使用 `LOAD DATA` 的性能
在 MySQL 8.0 中，`LOAD DATA` 使用缓冲来提高性能。您应注意，缓冲区使用每个分区 130 KB 的内存来实现这一点。

### 最大分区数
对于不使用 NDB 存储引擎的给定表，最大可能的分区数为 8192。此数字包括子分区。

对于使用 NDB 存储引擎的表，最大可能的用户定义分区数取决于所使用的 NDB Cluster 软件版本、数据节点的数量和其他因素。详情参见 [NDB 和用户定义分区](https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-user-defined-partitioning.html)。

如果在创建具有大量分区（但少于最大值）的表时遇到错误消息，例如从存储引擎获取错误...：打开文件时资源不足，您可以通过增加 `open_files_limit` 系统变量的值来解决问题。然而，这取决于操作系统，并不一定在所有平台上都可行或可取；详情参见 [B.3.2.16 节，“找不到文件和类似错误”](https://dev.mysql.com/doc/refman/8.0/en/cannot-find-file.html)。在某些情况下，由于其他原因，使用大量（数百个）分区也可能不明智，因此使用更多分区并不一定会带来更好的结果。

参见文件系统操作。

### InnoDB 分区表不支持外键
使用 InnoDB 存储引擎的分区表不支持外键。更具体地说，这意味着以下两种情况成立：

- 使用用户定义分区的 InnoDB 表的定义中不得包含外键引用；定义中包含外键引用的 InnoDB 表不得进行分区。
- InnoDB 表定义中不得包含对用户分区表的外键引用；具有用户定义分区的 InnoDB 表不得包含被外键引用的列。

上述限制的范围包括使用 InnoDB 存储引擎的所有表。导致表违反这些限制的 `CREATE TABLE` 和 `ALTER TABLE` 语句不允许执行。

### `ALTER TABLE ... ORDER BY`
对分区表运行的 `ALTER TABLE ... ORDER BY column` 语句仅在每个分区内对行进行排序。

### `ADD COLUMN ... ALGORITHM=INSTANT`
一旦对分区表执行了 `ALTER TABLE ... ADD COLUMN ... ALGORITHM=INSTANT`，就无法再与此表交换分区。

### 修改主键对 `REPLACE` 语句的影响
在某些情况下（参见 [26.6.1 节，“分区键、主键和唯一键”