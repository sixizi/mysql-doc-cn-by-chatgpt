### 26.5 分区选择

支持显式选择匹配给定 `WHERE` 条件的行的分区和子分区。分区选择与分区修剪类似，都只检查特定的分区是否匹配，但有两个关键区别：

1. 由语句发布者指定要检查的分区，而分区修剪是自动的。
2. 分区修剪仅适用于查询，而显式分区选择则支持查询和多个 DML 语句。

支持显式分区选择的 SQL 语句如下所示：

- `SELECT`
- `DELETE`
- `INSERT`
- `REPLACE`
- `UPDATE`
- `LOAD DATA`
- `LOAD XML`

本节的其余部分讨论显式分区选择在上述语句中的一般应用，并提供一些示例。

显式分区选择是使用 `PARTITION` 选项实现的。对于所有支持的语句，此选项的语法如下：

```sql
PARTITION (partition_names)

partition_names:
    partition_name, ...
```

此选项始终位于分区或子分区所属表的名称之后。`partition_names` 是要使用的分区或子分区的逗号分隔列表。此列表中的每个名称都必须是指定表的现有分区或子分区的名称；如果找不到任何分区或子分区，则语句失败并出现错误（`partition 'partition_name' doesn't exist`）。在 `partition_names` 中列出的分区和子分区可以按任意顺序列出，并且可以重叠。

使用 `PARTITION` 选项时，仅检查列出的分区和子分区是否有匹配的行。可以在 `SELECT` 语句中使用此选项来确定哪些行属于给定分区。考虑一个名为 `employees` 的分区表，使用如下语句创建并填充：

```sql
SET @@SQL_MODE = '';

CREATE TABLE employees  (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    fname VARCHAR(25) NOT NULL,
    lname VARCHAR(25) NOT NULL,
    store_id INT NOT NULL,
    department_id INT NOT NULL
)
    PARTITION BY RANGE(id)  (
        PARTITION p0 VALUES LESS THAN (5),
        PARTITION p1 VALUES LESS THAN (10),
        PARTITION p2 VALUES LESS THAN (15),
        PARTITION p3 VALUES LESS THAN MAXVALUE
);

INSERT INTO employees VALUES
    ('', 'Bob', 'Taylor', 3, 2), ('', 'Frank', 'Williams', 1, 2),
    ('', 'Ellen', 'Johnson', 3, 4), ('', 'Jim', 'Smith', 2, 4),
    ('', 'Mary', 'Jones', 1, 1), ('', 'Linda', 'Black', 2, 3),
    ('', 'Ed', 'Jones', 2, 1), ('', 'June', 'Wilson', 3, 1),
    ('', 'Andy', 'Smith', 1, 3), ('', 'Lou', 'Waters', 2, 4),
    ('', 'Jill', 'Stone', 1, 4), ('', 'Roger', 'White', 3, 2),
    ('', 'Howard', 'Andrews', 1, 2), ('', 'Fred', 'Goldberg', 3, 3),
    ('', 'Barbara', 'Brown', 2, 3), ('', 'Alice', 'Rogers', 2, 2),
    ('', 'Mark', 'Morgan', 3, 3), ('', 'Karen', 'Cole', 3, 2);
```

您可以这样查看存储在分区 `p1` 中的行：

```sql
mysql> SELECT * FROM employees PARTITION (p1);
+----+-------+--------+----------+---------------+
| id | fname | lname  | store_id | department_id |
+----+-------+--------+----------+---------------+
|  5 | Mary  | Jones  |        1 |             1 |
|  6 | Linda | Black  |        2 |             3 |
|  7 | Ed    | Jones  |        2 |             1 |
|  8 | June  | Wilson |        3 |             1 |
|  9 | Andy  | Smith  |        1 |             3 |
+----+-------+--------+----------+---------------+
5 rows in set (0.00 sec)
```

结果与查询 `SELECT * FROM employees WHERE id BETWEEN 5 AND 9` 得到的结果相同。

要从多个分区获取行，请提供其名称作为逗号分隔的列表。例如，`SELECT * FROM employees PARTITION (p1, p2)` 返回来自 `p1` 和 `p2` 分区的所有行，同时排除其余分区中的行。

任何对分区表的有效查询都可以使用 `PARTITION` 选项重写，以限制结果到一个或多个所需的分区。您可以使用 `WHERE` 条件、`ORDER BY` 和 `LIMIT` 选项等。您还可以使用带有 `HAVING` 和 `GROUP BY` 选项的聚合函数。以下每个查询在之前定义的 `employees` 表上运行时都会生成有效结果：

```sql
mysql> SELECT * FROM employees PARTITION (p0, p2)
    ->     WHERE lname LIKE 'S%';
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
|  4 | Jim   | Smith |        2 |             4 |
| 11 | Jill  | Stone |        1 |             4 |
+----+-------+-------+----------+---------------+
2 rows in set (0.00 sec)

mysql> SELECT id, CONCAT(fname, ' ', lname) AS name
    ->     FROM employees PARTITION (p0) ORDER BY lname;
+----+----------------+
| id | name           |
+----+----------------+
|  3 | Ellen Johnson  |
|  4 | Jim Smith      |
|  1 | Bob Taylor     |
|  2 | Frank Williams |
+----+----------------+
4 rows in set (0.06 sec)

mysql> SELECT store_id, COUNT(department_id) AS c
    ->     FROM employees PARTITION (p1,p2,p3)
    ->     GROUP BY store_id HAVING c > 4;
+---+----------+
| c | store_id |
+---+----------+
| 5 |        2 |
| 5 |        3 |
+---+----------+
2 rows in set (0.00 sec)
```

使用分区选择的语句可以与使用任何支持的分区类型的表一起使用。当使用 `[LINEAR] HASH` 或 `[LINEAR] KEY` 分区创建表并且未指定分区名称时，MySQL 自动将分区命名为 `p0`、`p1`、`p2`、...、`pN-1`，其中 `N` 是分区的数量。对于未显式命名的子分区，MySQL 将为每个分区 `pX` 中的子分区自动分配名称 `pXsp0`、`pXsp1`、`pXsp2`、...、`pXspM-1`，其中 `M` 是子分区的数量。当对该表执行 `SELECT`（或其他允许显式分区选择的 SQL 语句）时，可以在 `PARTITION` 选项中使用这些生成的名称，如下所示：

```sql
mysql> CREATE TABLE employees_sub  (
    ->     id INT NOT NULL AUTO_INCREMENT,
    ->     fname VARCHAR(25) NOT NULL,
    ->     lname VARCHAR(25) NOT NULL,
    ->     store_id INT NOT NULL,
    ->     department_id INT NOT NULL,
    ->     PRIMARY KEY pk (id, lname)
    -> )
    ->     PARTITION BY RANGE(id)
    ->     SUBPARTITION BY KEY (lname)
    ->     SUBPARTITIONS 2 (
    ->         PARTITION p0 VALUES LESS THAN (5),
    ->         PARTITION p1 VALUES LESS THAN (10),
    ->         PARTITION p2 VALUES LESS THAN (15),
    ->         PARTITION p3 VALUES LESS THAN MAXVALUE
    -> );
Query OK, 0 rows affected (1.14 sec)

mysql> INSERT INTO employees_sub   # reuse data in employees table
    ->     SELECT * FROM employees;
Query OK, 18 rows affected (0.09 sec)
Records: 18  Duplicates: 0  Warnings: 0

mysql> SELECT id, CONCAT(fname, ' ', lname) AS name
    ->     FROM employees_sub PARTITION (p2sp1);
+----+---------------+
| id | name          |
+----+---------------+
| 10 | Lou Waters    |
| 14 | Fred Goldberg |
+----+---------------+
2 rows in set (0.00 sec)
```

您还可以在 `INSERT ... SELECT` 语句的 `SELECT` 部分中使用 `PARTITION` 选项，如下所示：

```sql
mysql> CREATE TABLE employees_copy LIKE employees;
Query OK, 0 rows affected (0.28 sec