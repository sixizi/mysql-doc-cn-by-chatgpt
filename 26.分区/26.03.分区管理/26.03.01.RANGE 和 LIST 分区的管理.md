## 26.3 分区管理

### 26.3.1 RANGE 和 LIST 分区的管理

添加和删除 RANGE 和 LIST 分区的操作方式相似，因此我们在本节讨论两种分区类型的管理。有关 HASH 或 KEY 分区管理的信息，请参见[第 26.3.2 节](#2632-hash-和-key-分区的管理)。

使用 `ALTER TABLE` 语句的 `DROP PARTITION` 选项，可以从按 RANGE 或 LIST 分区的表中删除分区。假设使用以下 `CREATE TABLE` 和 `INSERT` 语句创建并填充了一个按范围分区的表，其中包含 10 条记录：

```sql
CREATE TABLE tr (id INT, name VARCHAR(50), purchased DATE)
    PARTITION BY RANGE( YEAR(purchased) ) (
        PARTITION p0 VALUES LESS THAN (1990),
        PARTITION p1 VALUES LESS THAN (1995),
        PARTITION p2 VALUES LESS THAN (2000),
        PARTITION p3 VALUES LESS THAN (2005),
        PARTITION p4 VALUES LESS THAN (2010),
        PARTITION p5 VALUES LESS THAN (2015)
    );
```

```sql
INSERT INTO tr VALUES
    (1, 'desk organiser', '2003-10-15'),
    (2, 'alarm clock', '1997-11-05'),
    (3, 'chair', '2009-03-10'),
    (4, 'bookcase', '1989-01-10'),
    (5, 'exercise bike', '2014-05-09'),
    (6, 'sofa', '1987-06-05'),
    (7, 'espresso maker', '2011-11-22'),
    (8, 'aquarium', '1992-08-04'),
    (9, 'study desk', '2006-09-16'),
    (10, 'lava lamp', '1998-12-25');
```

可以使用以下查询查看哪些项已插入到分区 `p2` 中：

```sql
SELECT * FROM tr
    WHERE purchased BETWEEN '1995-01-01' AND '1999-12-31';
```

```sql
+------+-------------+------------+
| id   | name        | purchased  |
+------+-------------+------------+
|    2 | alarm clock | 1997-11-05 |
|   10 | lava lamp   | 1998-12-25 |
+------+-------------+------------+
```

也可以使用分区选择来获取此信息，如下所示：

```sql
SELECT * FROM tr PARTITION (p2);
```

```sql
+------+-------------+------------+
| id   | name        | purchased  |
+------+-------------+------------+
|    2 | alarm clock | 1997-11-05 |
|   10 | lava lamp   | 1998-12-25 |
+------+-------------+------------+
```

有关分区选择的更多信息，请参见[第 26.5 节](#265-分区选择)。

要删除名为 `p2` 的分区，请执行以下命令：

```sql
ALTER TABLE tr DROP PARTITION p2;
```

> **注意**
>
> NDBCLUSTER 存储引擎不支持 `ALTER TABLE ... DROP PARTITION`。然而，它支持本章中描述的其他与分区相关的 `ALTER TABLE` 扩展。

必须记住，当删除一个分区时，也会删除存储在该分区中的所有数据。通过重新运行前面的查询可以看到这一点：

```sql
SELECT * FROM tr WHERE purchased
    BETWEEN '1995-01-01' AND '1999-12-31';
```

```sql
Empty set (0.00 sec)
```

> **注意**
>
> `DROP PARTITION` 受原生分区原地 API 支持，可与 `ALGORITHM={COPY|INPLACE}` 一起使用。`ALGORITHM=INPLACE` 的 `DROP PARTITION` 删除分区中的数据并删除该分区。然而，`ALGORITHM=COPY` 或 `old_alter_table=ON` 的 `DROP PARTITION` 会重建分区表，并尝试将数据从删除的分区移动到具有兼容 `PARTITION ... VALUES` 定义的另一个分区。无法移动到其他分区的数据将被删除。

因此，必须具有表的 `DROP` 特权，才能对该表执行 `ALTER TABLE ... DROP PARTITION`。

如果希望删除所有分区中的所有数据，但保留表定义及其分区方案，请使用 `TRUNCATE TABLE` 语句。（见[第 15.1.37 节](#15137-truncate-table-语句)）。

如果要在不丢失数据的情况下更改表的分区，请使用 `ALTER TABLE ... REORGANIZE PARTITION`。有关 `REORGANIZE PARTITION` 的信息，请参见下文或[第 15.1.9 节](#1519-alter-table-语句)。

现在执行 `SHOW CREATE TABLE` 语句，可以看到表的分区构成发生了变化：

```sql
SHOW CREATE TABLE tr\G
```

```sql
*************************** 1. row ***************************
       Table: tr
Create Table: CREATE TABLE `tr` (
  `id` int(11) DEFAULT NULL,
  `name` varchar(50) DEFAULT NULL,
  `purchased` date DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
/*!50100 PARTITION BY RANGE ( YEAR(purchased))
(PARTITION p0 VALUES LESS THAN (1990) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (1995) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (2005) ENGINE = InnoDB,
 PARTITION p4 VALUES LESS THAN (2010) ENGINE = InnoDB,
 PARTITION p5 VALUES LESS THAN (2015) ENGINE = InnoDB) */
1 row in set (0.00 sec)
```

当插入新的行且 `purchased` 列值在 '1995-01-01' 和 '2004-12-31' 之间（含）时，这些行会存储在分区 `p3` 中。可以如下验证：

```sql
INSERT INTO tr VALUES (11, 'pencil holder', '1995-07-12');
```

```sql
SELECT * FROM tr WHERE purchased
    BETWEEN '1995-01-01' AND '2004-12-31';
```

```sql
+------+----------------+------------+
| id   | name           | purchased  |
+------+----------------+------------+
|    1 | desk organiser | 2003-10-15 |
|   11 | pencil holder  | 1995-07-12 |
+------+----------------+------------+
```

```sql
ALTER TABLE tr DROP PARTITION p3;
```

```sql
SELECT * FROM tr WHERE purchased
    BETWEEN '1995-01-01' AND '2004-12-31';
```

```sql
Empty set (0.00 sec)
```

`ALTER TABLE ... DROP PARTITION` 删除的行数不会像等效的 `DELETE` 查询那样被服务器报告。

删除 LIST 分区使用与删除 RANGE 分区完全相同的 `ALTER TABLE ... DROP PARTITION` 语法。然而，这对以后使用表有一个重要影响：无法再向表中插入包含已删除分区的值列表中任意值的行。（参见[第 26.2.2 节](#2622-list-分区)中的示例。）

要向先前分区的表中添加新的范围或列表分区，请使用 `ALTER TABLE ... ADD PARTITION` 语句。对于按 RANGE 分区的表，可以使用此语句在现有分区列表的末尾添加新的范围。假设有一个包含组织成员数据的分区表，其定义如下：

```sql
CREATE TABLE members (
    id INT,
    fname VARCHAR(25),
    lname VARCHAR(25),
    dob DATE
)
PARTITION BY RANGE( YEAR(dob) ) (
    PARTITION p0 VALUES LESS THAN (1980),
    PARTITION p1 VALUES LESS THAN (1990),
    PARTITION p2 VALUES LESS THAN (2000)
);
```

假设成员的最低年龄为 16 岁。在 2015 年接近尾声时，您意识到必须为出生于 2000 年及以后的新成员做好准备。可以通过如下方式修改 `members` 表，以容纳出生于 2000 年至 2010 年的新成员：

```sql
ALTER TABLE members ADD PARTITION (PARTITION p3 VALUES LESS THAN (2010));
```

对于按范围分区的表，可以使用 `ADD PARTITION` 仅在分区列表的高端添加新分区。尝试以这种方式在现有分区之间或之前添加新分区会导致错误，如下所示：

```sql
ALTER TABLE members
    ADD PARTITION (
        PARTITION n VALUES LESS THAN (1970));
```

```sql
ERROR 1463 (HY000): VALUES LESS THAN value must be strictly increasing for each partition
```

可以通过将第一个分区重新组织为两个新分区来解决这个问题，使它们之间的范围分开，如下所示：