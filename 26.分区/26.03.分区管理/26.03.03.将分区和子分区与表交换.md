### 26.3.3 将分区和子分区与表交换

在 MySQL 8.0 中，可以使用 `ALTER TABLE pt EXCHANGE PARTITION p WITH TABLE nt` 语句，将一个表的分区或子分区与另一个表进行交换，其中 `pt` 是分区表，`p` 是要交换的 `pt` 的分区或子分区，`nt` 是要与 `p` 交换的未分区表。前提是以下条件为真：

- 表 `nt` 本身不是分区表。
- 表 `nt` 不是临时表。
- 表 `pt` 和 `nt` 的结构完全相同。
- 表 `nt` 不包含外键引用，且没有其他表包含对 `nt` 的外键引用。
- 表 `nt` 中没有超出分区 `p` 定义范围的行。如果使用 `WITHOUT VALIDATION`，则不适用此条件。
- 两个表必须使用相同的字符集和排序规则。
- 对于 InnoDB 表，两个表必须使用相同的行格式。要确定 InnoDB 表的行格式，请查询 `INFORMATION_SCHEMA.INNODB_TABLES`。
- 分区 `p` 的任何分区级别的 `MAX_ROWS` 设置必须与表级别的 `MAX_ROWS` 值相同，分区 `p` 的 `MIN_ROWS` 设置也必须与表 `nt` 的 `MIN_ROWS` 值相同。
- 表 `pt` 没有使用 `DATA DIRECTORY` 选项的分区。此限制在 MySQL 8.0.14 及更高版本的 InnoDB 表中已取消。
- `INDEX DIRECTORY` 在表和要与其交换的分区之间不能不同。
- 两个表中都不能使用任何 `TABLESPACE` 选项。

除了通常所需的 `ALTER`、`INSERT` 和 `CREATE` 权限之外，执行 `ALTER TABLE ... EXCHANGE PARTITION` 还需要具有 `DROP` 权限。

需要注意以下几点：

- 执行 `ALTER TABLE ... EXCHANGE PARTITION` 不会触发分区表或要交换的表上的任何触发器。
- 交换表中的任何 `AUTO_INCREMENT` 列都会重置。
- 使用 `ALTER TABLE ... EXCHANGE PARTITION` 时，`IGNORE` 关键字无效。

`ALTER TABLE ... EXCHANGE PARTITION` 的语法如下，其中 `pt` 是分区表，`p` 是要交换的分区（或子分区），`nt` 是要与 `p` 交换的未分区表：

```sql
ALTER TABLE pt
    EXCHANGE PARTITION p
    WITH TABLE nt;
```

可选地，可以附加 `WITH VALIDATION` 或 `WITHOUT VALIDATION`。当指定 `WITHOUT VALIDATION` 时，`ALTER TABLE ... EXCHANGE PARTITION` 操作在交换分区与未分区表时不会进行逐行验证，允许数据库管理员确保行在分区定义的范围内。默认情况下是 `WITH VALIDATION`。

在单个 `ALTER TABLE EXCHANGE PARTITION` 语句中，只能交换一个分区或子分区与一个未分区表。要交换多个分区或子分区，请使用多个 `ALTER TABLE EXCHANGE PARTITION` 语句。`EXCHANGE PARTITION` 不能与其他 `ALTER TABLE` 选项结合使用。分区表可以使用 MySQL 8.0 支持的任何类型或类型的分区和（如果适用）子分区。

#### 将分区与未分区表交换

假设使用以下 SQL 语句创建并填充了一个分区表 `e`：

```sql
CREATE TABLE e (
    id INT NOT NULL,
    fname VARCHAR(30),
    lname VARCHAR(30)
)
    PARTITION BY RANGE (id) (
        PARTITION p0 VALUES LESS THAN (50),
        PARTITION p1 VALUES LESS THAN (100),
        PARTITION p2 VALUES LESS THAN (150),
        PARTITION p3 VALUES LESS THAN (MAXVALUE)
);

INSERT INTO e VALUES
    (1669, "Jim", "Smith"),
    (337, "Mary", "Jones"),
    (16, "Frank", "White"),
    (2005, "Linda", "Black");
```

现在创建一个名为 `e2` 的未分区副本。这可以通过 `mysql` 客户端完成，如下所示：

```sql
mysql> CREATE TABLE e2 LIKE e;
Query OK, 0 rows affected (0.04 sec)

mysql> ALTER TABLE e2 REMOVE PARTITIONING;
Query OK, 0 rows affected (0.07 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

可以通过查询 `INFORMATION_SCHEMA.PARTITIONS` 表，查看 `e` 表中的哪些分区包含行，如下所示：

```sql
mysql> SELECT PARTITION_NAME, TABLE_ROWS
           FROM INFORMATION_SCHEMA.PARTITIONS
           WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          1 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
2 rows in set (0.00 sec)
```

要将 `e` 表中的分区 `p0` 与表 `e2` 交换，可以使用如下所示的 `ALTER TABLE` 语句：

```sql
mysql> ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;
Query OK, 0 rows affected (0.04 sec)
```

更准确地说，刚刚执行的语句会将分区中的任何行与表中的那些行进行交换。可以通过再次查询 `INFORMATION_SCHEMA.PARTITIONS` 表来观察这种情况。之前在分区 `p0` 中的表行不再存在：

```sql
mysql> SELECT PARTITION_NAME, TABLE_ROWS
           FROM INFORMATION_SCHEMA.PARTITIONS
           WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          0 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.00 sec)
```

如果查询 `e2` 表，可以看到之前“丢失”的行现在在那里：

```sql
mysql> SELECT * FROM e2;
+----+-------+-------+
| id | fname | lname |
+----+-------+-------+
| 16 | Frank | White |
+----+-------+-------+
1 row in set (0.00 sec)
```

要交换的表不一定是空的。为演示这一点，首先在 `e` 表中插入一行新记录，确保该行存储在分区 `p0` 中，然后再次使用之前的 `ALTER TABLE` 语句交换分区 `p0` 和表 `e2`：

```sql
mysql> INSERT INTO e VALUES (41, "Michael", "Green");
Query OK, 1 row affected (0.05 sec)

mysql> SELECT PARTITION_NAME, TABLE_ROWS
           FROM INFORMATION_SCHEMA.PARTITIONS
           WHERE TABLE_NAME = 'e';            
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          1 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.00 sec)

mysql> ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;
Query OK, 0 rows affected (0.28 sec)

mysql> SELECT * FROM e;
+------+-------+-------+
| id   | fname | lname |
+------+-------+-------+
|   16 | Frank | White |
| 1669 | Jim   | Smith |
|  337 | Mary  | Jones |
| 2005 | Linda | Black |
+------+-------+-------+
4 rows in set (0.00 sec)

mysql> SELECT PARTITION_NAME, TABLE_ROWS
           FROM INFORMATION_SCHEMA.PARTITIONS
           WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |          1 |
| p1             |          0 |
| p2             |          0 |
| p3             |          3 |
+----------------+------------+
4 rows in set (0.00 sec)

mysql> SELECT * FROM e2;
+----+---------+-------+
| id | fname   | lname |
+----+---------+-------+
| 41 | Michael | Green |
+----+---------+-------+
1 row in set (0.00 sec)
```

#### 不匹配的行

请记住，在执行 `ALTER TABLE ... EXCHANGE PARTITION` 语句之前，未分区表中的任何行都必须满足存储在目标分区中的条件；否则，语句将失败。要了解这一点，首先在 `e2` 表中插入一行超出分区 `p0` 定义范围的行。例如，插入一个 id 列值太大的行，然后再次尝试交换表与分区：

```sql
mysql> INSERT INTO e2 VALUES