### 25.2.4 MySQL NDB Cluster 8.0 新功能

以下部分描述了 NDB Cluster 8.0（至 8.0.38 版本）的实现变化，与早期版本相比的变化。NDB Cluster 8.0 从 NDB 8.0.19 开始作为 General Availability (GA) 版本提供。NDB Cluster 7.6 和 7.5 是之前仍支持的 GA 版本；有关 NDB Cluster 7.6 的信息，请参阅 [NDB Cluster 7.6 的新特性](https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-what-is-new-7-6.html)。有关 NDB Cluster 7.5 的类似信息，请参阅 [NDB Cluster 7.5 的新特性](https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-what-is-new-7-5.html)。NDB Cluster 7.4 和 7.3 是之前的 GA 版本，但已达到生命周期终点，不再支持或维护。我们建议新的生产部署使用 MySQL NDB Cluster 8.0。

#### NDB Cluster 8.0 的新特性

NDB Cluster 8.0 中主要的变更和新特性如下：

- **兼容性增强**：以下更改减少了 NDB 与其他 MySQL 存储引擎行为之间的长期非必要差异：

  - **与 MySQL 服务器并行开发**：从此版本开始，MySQL NDB Cluster 与标准 MySQL 8.0 服务器并行开发，并采用新的统一发布模型，具有以下特点：

    - NDB 8.0 在 MySQL 8.0 源代码树中开发、构建和发布。
    - NDB Cluster 8.0 版本的编号方案与 MySQL 8.0 一致。
    - 构建带有 NDB 支持的源代码会在 `mysql -V` 返回的版本字符串中附加 `-cluster`，如以下示例所示：

      ```shell
      $> mysql -V
      mysql  Ver 8.0.38-cluster for Linux on x86_64 (Source distribution)
      ```

      NDB 二进制文件继续显示 MySQL 服务器版本和 NDB 引擎版本，如下所示：

      ```shell
      $> ndb_mgm -V
      MySQL distrib mysql-8.0.38 ndb-8.0.38, for Linux (x86_64)
      ```
      在 MySQL Cluster NDB 8.0 中，这两个版本号总是相同的。

    要构建带有 NDB Cluster 支持的 MySQL 源代码，请使用 CMake 选项 `-DWITH_NDB`（NDB 8.0.31 及以后版本；对于更早的版本，使用 `-DWITH_NDBCLUSTER`）。

  - **平台支持说明**：

    - NDB 8.0 不再支持 32 位平台。从 NDB 8.0.21 开始，NDB 构建过程会检查系统架构，如果不是 64 位平台则会中止。
    - 现在可以为 64 位 ARM CPU 从源代码构建 NDB。目前，该支持仅限于源代码，我们不提供此平台的预编译二进制文件。

  - **数据库和表名**。NDB 8.0 取消了以前对数据库和表标识符的 63 字节限制。这些标识符现在可以使用多达 64 字节，与其他 MySQL 存储引擎相同。详见[第 25.2.7.11 节，"NDB Cluster 8.0 中解决的先前 NDB Cluster 问题"](https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-ndb-8-0-issues.html)。

  - **自动生成的外键名称**。NDB 现在使用 `tbl_name_fk_N` 模式为内部生成的外键命名，这与 InnoDB 使用的模式类似。

- **Schema和元数据分发与同步**。NDB 8.0 使用 MySQL 数据字典将schema信息分发到加入集群的 SQL 节点，并在现有 SQL 节点之间同步新的架构更改。以下是与此集成工作相关的个别增强功能：

  - **Schema分发增强**：NDB schema分发协调器在 NDB 8.0 中得到了扩展，以确保在架构操作结束时释放所用资源。以前，这些工作的一部分由架构分发客户端完成；由于客户端并不总是拥有所有必要的状态信息，当客户端决定在完成之前放弃架构操作而不通知协调器时，可能会导致资源泄漏。

      为了解决这个问题，架构操作超时检测已从架构分发客户端转移到协调器，使协调器有机会清理架构操作期间使用的任何资源。协调器现在会定期检查正在进行的架构操作是否超时，并在检测到超时时将尚未完成给定架构操作的参与者标记为失败。每当发生架构操作超时时，协调器还会提供适当的警告（应注意，在检测到此类超时后，架构操作本身会继续进行）。

      另外，当有一个或多个架构操作正在进行时，协调器会定期打印活动架构操作列表。

  - **磁盘数据文件分发**：NDB Cluster 8.0.14 使用 MySQL 数据字典确保磁盘数据文件和相关结构（如表空间和日志文件组）在所有连接的 SQL 节点之间正确分发。

  - **表空间对象的schema同步**：当 MySQL 服务器作为 SQL 节点连接到 NDB 集群时，它会将其数据字典与 NDB 字典中的信息进行检查和同步。

      以前，在连接新的 SQL 节点时，唯一同步的 NDB 对象是数据库和表；MySQL NDB Cluster 8.0 还实现了包括表空间和日志文件组在内的磁盘数据对象的架构同步。除此之外，这还消除了在本地备份和恢复后 MySQL 数据字典与 NDB 字典之间不匹配的可能性，因为表空间和日志文件组已恢复到 NDB 字典，但未恢复到 MySQL Server 的数据字典中。

      现在，不能再发出引用不存在的表空间的 `CREATE TABLE` 语句。这样的语句现在会失败并报错。

  - **数据库 DDL 同步增强**。为 NDB 8.0 所做的工作确保了新加入（或重新加入）的 SQL 节点与现有 SQL 节点同步数据库时，正确利用数据字典，以便在连接（或重新连接）到集群时，任何可能被该 SQL 节点错过的数据库级操作（`CREATE DATABASE`、`ALTER DATABASE` 或 `DROP DATABASE`）都能被正确复制。

      作为启动时执行的schema同步过程的一部分，SQL 节点现在会将集群数据节点上的所有数据库与其自身的数据字典进行比较，如果发现任何数据库在 SQL 节点的数据字典中缺失，SQL 节点会通过执行 `CREATE DATABASE` 语句在本地安装它。如此创建的数据库使用在执行该语句时该 SQL 节点上有效的默认 MySQL Server 数据库属性（例如由 `character_set_database` 和 `collation_database` 决定的那些属性）。

  - **NDB 元数据更改检测和同步**：NDB 8.0 实现了一种新的机制，用于检测 NDB 字典与 MySQL 数据字典之间的数据对象（如表、表空间和日志文件组）元数据的更新。这是通过一个后台线程完成的，该线程定期检查 NDB 字典和 MySQL 数据字典之间的一致性。

      该线程默认每 60 秒执行一次元数据检查。可以通过设置 `ndb_metadata_check_interval` 系统变量来调整轮询间隔；通过设置 `ndb_metadata_check` 系统变量为 `OFF` 可以完全禁用轮询。状态变量 `Ndb_metadata_detected_count` 显示自上次启动 mysqld 以来检测到的不一致次数。

      NDB 确保 NDB 数据库、表、日志文件组和表空间对象在启动后的操作过程中由元数据更改监控线程提交时，自动检查是否存在不匹配并由 NDB binlog 线程同步。

      NDB 8.0 增加了两个与自动同步相关的状态变量：`Ndb_metadata_synced_count` 显示自动同步的对象数量；`Ndb_metadata_excluded_count` 显示同步失败的对象数量（NDB 8.0.22 之前，该变量名为 `Ndb_metadata_blacklist_size`）。此外，您可以通过检查集群日志来查看哪些对象已同步。

      将 `ndb_metadata_sync` 系统变量设置为 true 会覆盖为 `ndb_metadata_check_interval` 和 `ndb_metadata_check` 所做的任何设置，使更改监控线程开始连续元数据更改检测。

      在 NDB 8.0.22 及更高版本中，将 `ndb_metadata_sync` 设置为 `true` 会清除先前同步失败的对象列表，这意味着不再需要发现单个表或通过重新连接 SQL 节点到集群来重新触发同步。此外，将此变量设置为 `false` 会清除等待重试的对象列表。

      从 NDB 8.0.21 开始，除了从日志消息或状态变量中获取的详细信息外，还可以通过添加到 MySQL 性能模式中的两个新表来获取有关自动同步当前状态的更详细信息。这些表如下：

      - `ndb_sync_pending_objects`：包含 NDB 字典与 MySQL 数据字典之间检测到不匹配的数据库对象的信息（且未被排除在自动同步之外）。
      - `ndb_sync_excluded_objects`：包含由于无法在 NDB 字典和 MySQL 数据字典之间同步而被排除的 NDB 数据库对象的信息，这些对象需要手动干预。

      这些表中的一行提供了数据库对象的父模式、名称和类型。对象类型包括模式、表空间、日志文件组和表。（如果对象是日志文件组或表空间，则父模式为 `NULL`。）此外，`ndb_sync_excluded_objects` 表显示了该对象被排除的原因。

      这些表仅在启用了 `NDBCLUSTER` 存储引擎支持时才存在。有关这些表的更多信息，请参见 [第 29.12.12 节，“性能模式 NDB 集群表”](#)。

  - **NDB 表额外元数据的变化**。NDB 表的额外元数据属性用于存储 MySQL 数据字典的序列化元数据，而不是像以前版本那样存储表的二进制表示（这是一个不再被 MySQL 服务器使用的 `.frm` 文件）。作为支持此更改工作的一部分，表的额外元数据的可用大小已增加。这意味着在 NDB Cluster 8.0 中创建的 NDB 表与以前的 NDB Cluster 版本不兼容。在以前版本中创建的表可以在 NDB 8.0 中使用，但之后无法再被早期版本打开。

    此元数据可通过 NDB API 方法 `getExtraMetadata()` 和 `setExtraMetadata()` 访问。

    有关更多信息，请参见 [第 25.3.7 节，“升级和降级 NDB Cluster”](#)。

  - **在线升级使用 .frm 文件的表**：在 NDB 7.6 及以前版本中创建的表包含 `.frm` 文件形式的元数据，MySQL 8.0 不再支持此文件。为了促进在线升级到 NDB 8.0，NDB 在后台对这些元数据进行转换，并将其写入 MySQL 服务器的数据字典，这使得 NDB Cluster 8.0 中的 `mysqld` 能够处理表，同时不会阻止早期版本的 NDB 软件使用该表。

    > **重要**
    >
    > 一旦在 NDB 8.0 中修改了表的结构，其元数据将使用数据字典存储，早期版本的 NDB 将无法再访问该表。

  - **元数据一致性检查错误日志记录**：作为 NDB 8.0 之前工作的一部分，自动同步过程中执行的元数据检查包括表名、存储引擎和内部 ID。从 NDB 8.0.23 开始，检查范围扩展到以下数据对象的属性：

    - 列
    - 索引
    - 外键

    此外，任何元数据属性不匹配的详细信息现在会写入 MySQL 服务器错误日志。错误日志消息的格式略有不同，具体取决于不匹配是出现在表级别还是列、索引或外键级别。日志错误消息格式如下，其中 `property` 是属性名，`ndb_value` 是 NDB 字典中存储的属性值，`mysqld_value` 是 MySQL 数据字典中存储的属性值：

    ```plaintext
    Diff in 'property' detected, 'ndb_value' != 'mysqld_value'
    ```
    对于列、索引和外键属性的不匹配，格式如下，其中 `obj_type` 是列、索引或外键之一，`obj_name` 是对象名称：

    ```plaintext
    Diff in obj_type 'obj_name.property' detected, 'ndb_value' != 'mysqld_value'
    ```
    在 NDB Cluster 中，任何 mysqld 作为 SQL 节点安装的数据字典中的 NDB 表在自动同步期间会执行元数据检查。如果 mysqld 是调试编译的，则还会在执行 `CREATE TABLE` 语句时以及每次打开 NDB 表时进行检查。

  - **即时升级使用 `.frm` 文件的表**。在 NDB 7.6 及更早版本中创建的表包含以压缩 `.frm` 文件形式存储的元数据，这在 MySQL 8.0 中不再受支持。为了便于在线升级到 NDB 8.0，NDB 会即时翻译这些元数据并将其写入 MySQL Server 的数据字典，这使得 NDB Cluster 8.0 中的 `mysqld` 能够处理该表，而不会阻止后续版本的 NDB 软件继续使用该表。

      > **重要**
      >
      > 一旦在 NDB 8.0 中修改了表的结构，其元数据将使用数据字典存储，并且无法再被 NDB 7.6 及更早版本访问。

      此增强功能还使得可以将使用早期版本进行的 NDB 备份恢复到运行 NDB 8.0（或更高版本）的集群。

  - **NDB_STORED_USER 同步用户权限**。在 NDB 8.0 中，引入了一种新的机制，通过 `NDB_STORED_USER` 权限在 SQL 节点之间共享和同步用户、角色和权限。在 NDB 7.6 及更早版本中实现的分布式权限（参见“使用共享授权表的分布式权限”）不再受支持。

    一旦在 SQL 节点上创建了用户帐户，该用户及其权限可以通过执行如下 `GRANT` 语句存储在 NDB 中，从而在集群中的所有 SQL 节点之间共享：

    ```sql
    GRANT NDB_STORED_USER ON *.* TO 'jon'@'localhost';
    ```

    `NDB_STORED_USER` 始终具有全局范围，必须使用 `ON *.*` 授予。系统保留帐户（例如 `mysql.session@localhost` 或 `mysql.infoschema@localhost`）不能分配此权限。

    通过执行适当的 `GRANT NDB_STORED_USER` 语句，也可以在 SQL 节点之间共享角色。将这样的角色分配给用户不会导致该用户被共享；必须显式地将 `NDB_STORED_USER` 权限授予每个用户。

    一旦具有 `NDB_STORED_USER` 的用户或角色及其权限共享给所有 SQL 节点，这些节点在加入指定的 NDB 集群时会立即同步。可以从任何已连接的 SQL 节点进行此类更改，但推荐的做法是仅从指定的 SQL 节点进行此操作，因为不能保证影响权限的语句在不同 SQL 节点上的执行顺序是相同的。

    在 NDB 8.0.27 之前，对用户或角色权限的更改会立即与所有已连接的 SQL 节点同步。从 MySQL 8.0.27 开始，SQL 节点在更新权限时会获取全局读锁，以防止多个 SQL 节点执行的并发更改导致死锁。

    **升级的影响**。由于 MySQL 服务器权限系统的更改（参见[第 8.2.3 节，“授权表”](#)），使用 NDB 存储引擎的权限表在 NDB 8.0 中无法正常运行。保留在 NDB 7.6 或更早版本中创建的此类权限表是安全的，但不再用于访问控制。在 NDB 8.0 中，作为 SQL 节点的 `mysqld` 在 NDB 中检测到此类表时，会向 MySQL 服务器日志写入警告，并在本地创建 InnoDB 影子表；每个连接到集群的 MySQL 服务器都会创建此类影子表。从 NDB 7.6 或更早版本执行升级时，一旦所有作为 SQL 节点的 MySQL 服务器都已升级，可以安全地使用 `ndb_drop_table` 删除使用 NDB 的权限表（参见[第 25.3.7 节，“升级和降级 NDB Cluster”](#)）。

    `ndb_restore` 实用程序的 `--restore-privilege-tables` 选项已被弃用，但在 NDB 8.0 中继续有效，仍然可以将从以前版本的 NDB 集群备份中存在的分布式权限表恢复到运行 NDB 8.0 的集群。这些表的处理方式如前文所述。

    共享用户和授权存储在 `ndb_sql_metadata` 表中，默认情况下 `ndb_restore` 在 NDB 8.0 中不会恢复该表；可以指定 `--include-stored-grants` 选项来使其恢复。

    更多信息，请参见[第 25.6.13 节，“权限同步和 NDB_STORED_USER”](#)。

  - **INFORMATION_SCHEMA 的更改**。以下更改适用于 Information Schema 中 `FILES` 表显示的关于磁盘数据文件的信息：

      - 表空间和日志文件组不再在 `FILES` 表中表示。（这些结构实际上不是文件。）
      - 每个数据文件现在在 `FILES` 表中表示为一行。每个撤销日志文件现在也在该表中仅表示一行。（以前，每个数据节点上的每个副本都会显示一行。）

      另外，INFORMATION_SCHEMA 表现在填充了 MySQL Cluster 表的表空间统计信息。（错误 #27167728）

  - **ndb_perror 错误信息**。已移除 `perror` 的弃用选项 `--ndb`。取而代之的是，使用 `ndb_perror` 从 NDB 错误代码获取错误消息信息。（错误 #81704，错误 #81705，错误 #23523926，错误 #23523957）

  - **条件下推增强**。以前，条件下推仅限于引用同一表列值的谓词项。在 NDB 8.0 中，此限制已被移除，以便查询计划中较早表的列值也可以在下推条件中引用。NDB 8.0 支持比较列表达式以及同一表中的列之间的比较。被比较的列和列表达式必须完全相同的类型；这意味着它们还必须具有相同的符号、长度、字符集、精度和小数位数（如果适用）。在 NDB 8.0.27 之前，下推条件不能作为下推连接的一部分，这一限制在 NDB 8.0.27 被取消。

      下推条件的较大部分允许数据节点过滤掉更多的行，从而减少 `mysqld` 在连接处理期间必须处理的行数。此增强功能的另一个好处是过滤可以在 LDM 线程中并行执行，而不是在 SQL 节点上的单个 `mysqld` 进程中执行；这有可能显著提高查询性能。

      被比较的列值之间的类型兼容性现有规则继续适用（参见[第 10.2.1.5 节，“引擎条件下推优化”](#)）。

      **外连接和半连接的下推**。在 NDB 8.0.20 中完成的工作允许将许多外连接和半连接（不仅仅是使用主键或唯一键查找的那些）下推到数据节点（参见[第 10.2.1.5 节，“引擎条件下推优化”](#)）。

      现在可以下推的使用扫描的外连接包括满足以下条件的那些：

      - 表上没有未下推的条件
      - 在同一连接嵌套中或其依赖的上层连接嵌套中没有未下推的条件
      - 同一连接嵌套中的所有其他表或其依赖的上层连接嵌套也都被下推

      如果使用索引扫描的半连接满足上述条件并使用 `firstMatch` 策略（参见[第 10.2.2.1 节，“通过半连接转换优化 IN 和 EXISTS 子查询谓词”](#)），则现在也可以下推。

      在 NDB 8.0.21 中还进行了以下改进：

      - 通过 MySQL 优化器将 `NOT EXISTS` 和 `NOT IN` 查询转换生成的反连接（参见[第 10.2.2.1 节，“通过半连接转换优化 IN 和 EXISTS 子查询谓词”](#)）可以由 NDB 下推到数据节点。
      - 这可以在表上没有未下推条件且查询满足外连接下推的任何其他条件时完成。
      - NDB 尝试在尝试从附加表检索任何行之前识别和评估非依赖性标量子查询。当能够这样做时，获取的值作为下推条件的一部分使用，而不是使用提供该值的子查询。

      从 NDB 8.0.27 开始，作为下推查询的一部分下推的条件现在可以引用同一下推查询中祖先表的列，受以下条件约束：

      - 下推条件可以包含任何比较运算符 `<`、`<=`、`>`、`>=`、`=` 和 `<>`。
      - 被比较的值必须为相同类型，包括长度、精度和小数位数。
      - 根据 ISO SQL 标准指定的比较语义执行 `NULL` 处理；任何与 `NULL` 的比较返回 `NULL`。

      考虑使用如下语句创建的表：

      ```sql
      CREATE TABLE t (
          x INT PRIMARY KEY, 
          y INT
      ) ENGINE=NDB;
      ```

      像 `SELECT * FROM t AS m JOIN t AS n ON m.x >= n.y` 这样的查询现在可以使用引擎条件下推优化来下推条件列 `y`。

      当连接不能下推时，`EXPLAIN` 应提供原因。

      更多信息，请参见[第 10.2.1.5 节，“引擎条件下推优化”](#)。

      NDB 8.0.27 中作为此工作的组成部分添加了 `NDB API` 方法 `branch_col_eq_param()`、`branch_col_ne_param()`、`branch_col_lt_param()`、`branch_col_le_param()`、`branch_col_gt_param()` 和 `branch_col_ge_param()`。这些 `NdbInterpretedCode` 可用于将列值与参数值进行比较。

      另外，NDB 8.0.27 中还添加了 `NdbScanFilter::cmp_param()`，使得可以定义列值和参数值之间的比较以用于执行扫描。

  - **增加最大行大小**：NDB 8.0 将 NDBCLUSTER 表中可以存储的最大字节数从 14000 增加到 30000 字节。

      BLOB 或 TEXT 列继续使用此总数的 264 字节，与以前一样。

      固定宽度列的最大偏移量仍为 8188 字节，与以前版本相比没有变化。

      有关更多信息，请参见 [第 25.2.7.5 节，“NDB Cluster 中与数据库对象相关的限制”](#)。

  - **`ndb_mgm SHOW` 命令和单用户模式**：在 NDB 8.0 中，当集群处于单用户模式时，管理客户端的 `SHOW` 命令输出指示哪个 API 或 SQL 节点在此模式生效期间具有独占访问权。

  - **在线列重命名**：NDB 表的列现在可以在线重命名，使用 `ALGORITHM=INPLACE`。详细信息请参阅[第 25.6.12 节，“NDB Cluster 中的 ALTER TABLE 在线操作”](https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-alter-table-online.html)。

  - **提高 `ndb_mgmd` 启动时间**：NDB 8.0 中，以下方式显著提高了管理节点守护进程的启动时间：

    - 由于用哈希表替换了 `ndb_mgmd` 用于处理配置数据中的节点属性的列表数据结构，管理服务器的总体启动时间减少了 6 倍以上。
    - 此外，在集群配置文件中使用管理服务器主机文件中不存在的数据和 SQL 节点主机名的情况下，`ndb_mgmd` 启动时间比以前减少了多达 20 倍。

  - **NDB API 增强**：`NdbScanFilter::cmp()` 和几个 `NdbInterpretedCode` 的比较方法现在可以用于比较表列值。受影响的 `NdbInterpretedCode` 方法列在这里：

    - `branch_col_eq()`
    - `branch_col_ge()`
    - `branch_col_gt()`
    - `branch_col_le()`
    - `branch_col_lt()`
    - `branch_col_ne()`

    对于上述所有方法，被比较的表列值必须完全匹配类型，包括长度、精度、符号、刻度、字符集和排序规则。

  - **离线多线程索引构建**：现在可以为执行离线多线程构建有序索引的 I/O 线程指定一组核心，而不是正常的 I/O 任务，如文件 I/O、压缩或解压缩。“离线”在此上下文中指的是在父表未被写入时执行的有序索引构建；此类构建在 NDB 集群执行节点或系统重启时，或作为使用 `ndb_restore --rebuild-indexes` 从备份恢复集群的一部分进行。

    此外，离线索引构建工作的默认行为已修改为使用 `ndbmtd` 可用的所有核心，而不是限制在为 I/O 线程保留的核心上。这可以提高重启和恢复时间、性能、可用性和用户体验。

    此增强功能实现如下：
    1. `BuildIndexThreads` 的默认值从 0 更改为 128。这意味着离线有序索引构建现在默认是多线程的。
    2. `TwoPassInitialNodeRestartCopy` 的默认值从 false 更改为 true。这意味着初始节点重启首先将所有数据从“活动”节点复制到正在启动的节点——不创建任何索引——然后离线构建有序索引，然后再次与活动节点同步数据，即同步两次，并在两次同步之间离线构建索引。这使得初始节点重启的行为更像正常的节点重启，并减少了构建索引所需的时间。
    3. 为 `ThreadConfig` 配置参数定义了一个新线程类型（`idxbld`），以允许将离线索引构建线程锁定到特定 CPU。

    此外，NDB 现在通过以下两个标准区分可供 `ThreadConfig` 使用的线程类型：
    1. 线程是否是执行线程。`main`、`ldm`、`recv`、`rep`、`tc` 和 `send` 类型的线程是执行线程；`io`、`watchdog` 和 `idxbld` 类型的线程不是执行线程。
    2. 将线程分配给给定任务是永久性的还是临时性的。目前，除 `idxbld` 之外的所有线程类型都是永久性的。

  - **`logbuffers` 表备份过程信息**：执行 NDB 备份时，`ndbinfo.logbuffers` 表现在显示备份过程中每个数据节点的缓冲区使用信息。这是通过显示除 REDO 和 DD-UNDO 之外的两个新日志类型的行实现的。其中一个行的日志类型为 `BACKUP-DATA`，显示在备份过程中用于将片段复制到备份文件的数据缓冲区使用量。另一个行的日志类型为 `BACKUP-LOG`，显示在备份过程中用于记录备份开始后进行的更改的日志缓冲区使用量。`logbuffers` 表中每个数据节点显示这两个日志类型之一的行。这些日志类型的行仅在当前进行 NDB 备份时存在于表中。

  - **Windows 平台上的 `ndbinfo.processes` 表**：Windows 平台上使用 `RESTART` 生成和重启 `mysqld` 的监控进程的进程 ID 现在显示在 `processes` 表中的 `angel_pid` 列中。

  - **字符串哈希改进**：在 NDB 8.0 之前，所有字符串哈希都是基于首先将字符串转换为规范形式，然后对结果二进制图像进行 MD5 哈希。这可能会导致一些性能问题，原因如下：

    - 规范化字符串始终用空格填充到其完整长度。对于 `VARCHAR`，这通常涉及添加比原始字符串更多的空格。
    - 字符串库未针对这种空格填充进行优化，在某些用例中增加了大量开销。
    - 填充语义在字符集之间有所不同，有些字符集未填充到其完整长度。
    - 即使没有空格填充，转换后的字符串也可能变得非常大；一些 Unicode 9.0 排序规则可以将单个代码点转换为 100 字节或更多字符数据。
    - 随后的 MD5 哈希主要由填充空格组成，并不特别高效，可能导致刷新大量 L1 缓存，从而进一步影响性能。

    排序规则提供了自己的哈希函数，可以直接对字符串进行哈希，而无需先创建规范化字符串。此外，对于 Unicode 9.0 排序规则，哈希是在不进行填充的情况下计算的。NDB 现在在哈希使用 Unicode 9.0 排序规则的字符串时利用此内置函数。

    由于对于其他排序规则，现有数据库在转换字符串时基于哈希分区，因此 NDB 继续对这些字符串使用以前的方法，以保持兼容性。

  - **`RESET MASTER` 更改**：由于 MySQL 服务器现在使用全局读锁执行 `RESET MASTER`，使用此语句与 NDB Cluster 的行为在以下两个方面有所不同：

    - 不再保证是同步的；也就是说，可能在发出 `RESET MASTER` 之前立即进行的读取直到二进制日志旋转之后才被记录。
    - 无论语句是在哪个 SQL 节点上发出的，都以相同方式操作，无论该节点是否正在写入二进制日志。

        > **注意**
        >
        > `SHOW BINLOG EVENTS`、`FLUSH LOGS` 和大多数数据定义语句继续以同步方式操作，正如在以前的 NDB 版本中一样。

  - **`ndb_restore` 选项使用**：调用 `ndb_restore` 时，`--nodeid` 和 `--backupid` 选项现在都必需。

  - **`ndb_log_bin` 默认值**：NDB 8.0 将 `ndb_log_bin` 系统变量的默认值从 `TRUE` 更改为 `FALSE`。

  - **动态事务资源分配**：现在使用动态内存池分配事务协调器中的资源。这意味着由数据节点配置参数（如 `MaxDMLOperationsPerTransaction`、`MaxNoOfConcurrentIndexOperations`、`MaxNoOfConcurrentOperations`、`MaxNoOfConcurrentScans`、`MaxNoOfConcurrentTransactions`、`MaxNoOfFiredTriggers`、`MaxNoOfLocalScans` 和 `TransactionBufferMemory`）确定的资源分配现在以一种方式进行分配，即如果每个参数代表的负载在所有这些资源的目标负载之内，则其他资源可以受到限制，以不超过可用总资源。

    作为此工作的一部分，添加了几个控制 DBTC 中事务资源的新数据节点参数，包括：
    - `ReservedConcurrentIndexOperations`
    - `ReservedConcurrentOperations`
    - `ReservedConcurrentScans`
    - `ReservedConcurrentTransactions`
    - `ReservedFiredTriggers`
    - `ReservedLocalScans`
    - `ReservedTransactionBufferMemory`

  - **使用多个 LDM 的备份**：现在可以使用多个本地数据管理器（LDM）在单个数据节点上并行执行 NDB 备份。（以前，备份在数据节点之间是并行进行的，但在数据节点进程内始终是串行的。）启用此功能不需要在 `ndb_mgm` 客户端的 `START BACKUP` 命令中使用特殊语法，但所有数据节点必须使用多个 LDM。这意味着数据节点必须运行 `ndbmtd`（`ndbd` 是单线程的，因此始终只有一个 LDM），并且必须在进行备份之前配置为使用多个 LDM；您可以通过选择适当的多线程数据节点配置参数 `MaxNoOfExecutionThreads` 或 `ThreadConfig` 设置来实现这一点。

    使用多个 LDM 创建备份时，会在 `BACKUP/BACKUP-backup_id/` 目录下创建多个子目录，每个 LDM 一个。`ndb_restore` 现在会自动检测这些子目录，如果它们存在，则尝试并行恢复备份；请参阅[第 25.5.23.3 节，“从并行备份恢复”](https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-backup-restoring.html#mysql-cluster-backup-restoring-parallel) 了解详细信息。（单线程备份恢复与以前版本的 NDB 一样。）还可以通过修改常规恢复过程来使用早期版本的 NDB Cluster 的 `ndb_restore` 二进制文件恢复并行备份；[第 25.5.23.3.2 节，“串行恢复并行备份”](https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-backup-restoring.html#mysql-cluster-backup-restoring-serial) 提供了如何执行此操作的信息。

    您可以通过在集群全局配置文件（`config.ini`）的 `[ndbd default]` 部分中为所有数据节点设置 `EnableMultithreadedBackup` 数据节点参数为 0 来强制创建单线程备份。

  - **二进制配置文件增强**：NDB 8.0 对管理服务器的二进制配置文件格式进行了新的改进。以前，集群配置文件中的最大部分数为 16381；现在，最大部分数为 4G。这旨在支持比此更改之前更大数量的节点。

      升级到新格式相对无缝，通常不需要手动干预，因为管理服务器继续能够读取旧格式而不会出现问题。从 NDB 8.0 降级到 NDB Cluster 软件的旧版本需要手动删除任何二进制配置文件，或者，启动旧的管理服务器二进制文件时使用 `--initial` 选项。

  - **增加数据节点数量**：NDB 8.0 将每个集群支持的数据节点最大数量从 48 增加到 144。数据节点现在可以使用 1 到 144 范围内的节点 ID。

      以前，管理节点的推荐节点 ID 为 49 和 50。这些节点 ID 仍然支持作为管理节点使用，但将它们用作管理节点会将数据节点的最大数量限制为 142；因此，现在建议使用节点 ID 145 和 146 作为管理节点。

      作为此工作的组成部分，用于数据节点 sysfile 的格式已更新为版本 2。此文件记录信息，如最后的全局检查点索引、重启状态和每个节点的节点组成员资格。

  - **`RedoOverCommitCounter` 和 `RedoOverCommitLimit` 更改**：由于将其设置为 0 的语义含糊不清，因此数据节点配置参数 `RedoOverCommitCounter` 和 `RedoOverCommitLimit` 的最小值已增加到 1。

  - **`ndb_autoincrement_prefetch_sz` 更改**：`ndb_autoincrement_prefetch_sz` 服务器系统变量的默认值增加到 512。

  - **参数最大值和默认值的更改**：NDB 8.0 对配置参数最大值和默认值进行了以下更改：

      - `DataMemory` 的最大值增加到 16 TB。
      - `DiskPageBufferMemory` 的最大值也增加到 16 TB。
      - `StringMemory` 的默认值增加到 25%。
      - `LcpScanProgressTimeout` 的默认值增加到 180 秒。

  - **磁盘数据检查点改进**：NDB Cluster 8.0 提供了一些新的增强功能，帮助减少使用固态驱动器（SSD）和 NVMe 规范等非易失性存储设备进行磁盘数据表和表空间检查点的延迟。这些改进包括以下内容：

      - 避免检查点磁盘写入的突发
      - 在重做日志或撤销日志变满时加快磁盘数据表空间的检查点速度
      - 必要时平衡磁盘和内存中的检查点
      - 保护磁盘设备免受过载，帮助确保在高负载下的低延迟

      作为此工作的一部分，添加了两个数据节点配置参数：`MaxDiskDataLatency`：限制磁盘访问的允许延迟程度，并导致超过此时长的事务中止。`DiskDataUsingSameDisk`：通过增加磁盘数据表空间检查点的执行速度，使得可以利用将磁盘数据表空间放置在单独磁盘上的优势。

      此外，`ndbinfo` 数据库中添加了三个新表，用于提供有关磁盘数据性能的信息：
      - `diskstat`：报告过去一秒钟内对磁盘数据表空间的写入
      - `diskstats_1sec`：报告过去 20 秒内每秒对磁盘数据表空间的写入
      - `pgman_time_track_stats`：报告与磁盘数据表空间相关的磁盘操作延迟

  - **内存分配和 `TransactionMemory`**：新参数 `TransactionMemory` 简化了事务的数据节点内存分配，作为将事务内存和本地数据管理器（LDM）内存池化工作的组成部分。此参数旨在取代几个已弃用的旧事务内存参数。

      现在可以通过以下三种方式之一设置事务内存：
      - 设置 `TransactionMemory`。如果设置了 `TransactionMemory`，则使用此值确定事务内存。

        > **注意**
        >
        > `SHOW BINLOG EVENTS`、`FLUSH LOGS` 和大多数数据定义语句在以前的 NDB 版本中一样，继续以同步方式操作。

      - 如果未设置 `TransactionMemory`，且未设置任何与 `TransactionMemory` 不兼容的参数，则由 NDB 设置事务内存。

      - 不能同时设置 `TransactionMemory` 和任何不兼容的参数（如 `MaxNoOfConcurrentOperations`、`MaxNoOfConcurrentScans`、`MaxNoOfConcurrentTransactions`、`MaxNoOfFiredTriggers`、`MaxNoOfLocalScans`、`TransactionBufferMemory`），否则管理服务器无法启动。

      了解更多信息，请参阅 `TransactionMemory` 描述以及[第 25.4.3.13 节，“数据节点内存管理”](https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-data-node-memory-management.html)。

  - **支持额外的分片副本**：NDB 8.0 将生产环境中支持的最大分片副本数量从两个增加到四个（以前可以将 `NoOfReplicas` 设置为 3 或 4，但这未得到官方支持或验证）。

  - **切片恢复**：从 NDB 8.0.20 开始，可以将备份分成大致相等的部分（切片），并使用 ndb_restore 的两个新选项并行恢复这些切片：

      - `--num-slices`：确定备份应分成的切片数量。
      - `--slice-id`：提供当前 `ndb_restore` 实例要恢复的切片 ID。

      这使得可以使用多个 `ndb_restore` 实例并行恢复备份的子集，从而可能减少执行恢复操作所需的时间。

      了解更多信息，请参阅 `ndb_restore --num-slices` 选项描述。

  - **启用从任何分片副本读取**：默认情况下，所有 NDB 表启用从任何分片副本读取。这意味着系统变量 `ndb_read_backup` 的默认值现在是 `ON`，并且在创建新 NDB 表时，NDB 表注释选项 `READ_BACKUP` 的值为 1。启用从任何分片副本读取显著提高 NDB 表的读取性能，对写入影响最小。

      了解更多信息，请参阅 `ndb_read_backup` 系统变量描述以及[第 15.1.20.12 节，“设置 NDB 注释选项”](https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-comment-options.html)。

  - **`ndb_blob_tool` 增强**：从 NDB 8.0.20 开始，`ndb_blob_tool` 工具可以检测存在内联部分但缺失 BLOB 部分的情况，并用占位符 BLOB 部分（由空格字符组成）替换这些部分。使用 `--check-missing` 选项检查是否缺少 BLOB 部分。使用 `--add-missing` 选项用占位符替换任何缺失的 BLOB 部分。

      了解更多信息，请参阅[第 25.5.6 节，“ndb_blob_tool — 检查和修复 NDB Cluster 表的 BLOB 和 TEXT 列”](https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster-ndb-blob-tool.html)。

  - **`ndbinfo` 版本控制**：NDB 8.0.20 及以后版本支持 `ndbinfo` 表的版本控制，并在内部维护其表的当前定义。启动时，NDB 将支持的 `ndbinfo` 版本与数据字典中存储的版本进行比较。如果版本不同，NDB 将删除任何旧的 `ndbinfo` 表，并使用当前定义重新创建它们

  - **支持 Fedora Linux**：从 NDB 8.0.20 开始，Fedora Linux 是 NDB Cluster Community 版本的受支持平台，可以使用 Oracle 提供的 RPM 安装。这些 RPM 可从 [NDB Cluster 下载页面](https://dev.mysql.com/downloads/cluster/) 获得。

  - **NDB 程序 — NDBT 依赖关系移除**：删除了许多 NDB 实用程序程序对 NDBT 库的依赖。此库在内部用于开发，不需要用于正常使用；其包含在这些程序中可能在测试时导致问题。

    受影响的程序如下所示，列出了移除依赖关系的 NDB 版本：
    - `ndb_restore`
    - `ndb_delete_all`
    - `ndb_show_tables`（NDB 8.0.20）
    - `ndb_waiter`（NDB 8.0.20）

    这一更改对用户的主要影响是这些程序在运行完成后不再打印 `NDBT_ProgramExit - status`。升级到指定版本时依赖此行为的应用程序应进行相应更新。

  - **外键和字母大小写**：NDB 使用定义时的大小写存储外键的名称。以前，当系统变量 `lower_case_table_names` 的值设置为 0 时，它执行外键名称在 SQL 语句中的使用与存储的名称的大小写敏感比较。从 NDB 8.0.20 开始，这种比较现在始终以大小写不敏感的方式执行，而不考虑 `lower_case_table_names` 的值。

  - **多传输器**：NDB 8.0.20 引入了支持多个传输器处理数据节点之间的节点到节点通信。这有助于提高每个节点组的更新操作速率，并有助于避免系统或其他限制对使用单个套接字进行节点间通信的限制。

    默认情况下，NDB 现在根据本地数据管理（LDM）线程或事务协调器（TC）线程的数量（以较大者为准）使用多个传输器。默认情况下，传输器数量等于该数量的一半。虽然默认设置对于大多数工作负载应表现良好，但可以通过设置 `NodeGroupTransporters` 数据节点配置参数（也在 NDB 8.0.20 中引入）来调整每个节点组使用的传输器数量，最多可以是 LDM 线程数或 TC 线程数中较大者的数量。将其设置为 0 会导致传输器数量与 LDM 线程数量相同。

  - **`ndb_restore`：主键架构更改**：NDB 8.0.21（及以后版本）支持在 `ndb_restore` 恢复 NDB 原生备份时使用 `--allow-pk-changes` 选项，源表和目标表具有不同的主键定义。支持增加和减少构成原始主键的列数量。

      当主键扩展了额外的列时，添加的列必须定义为 `NOT NULL`，并且在备份期间这些列中的值不能更改。因为某些应用程序在更新行时会设置该行的所有列值，不论是否实际更改了所有值，这可能会导致恢复操作失败，即使主键中添加的列的值没有更改。您可以使用 NDB 8.0.21 中新增的 `--ignore-extended-pk-updates` 选项来覆盖此行为；在这种情况下，您必须确保没有更改这些值。

      无论某列是否仍然是表的一部分，都可以从表的主键中删除该列。

      有关更多信息，请参见 `ndb_restore` 的 `--allow-pk-changes` 选项的说明。

  - **合并备份与 `ndb_restore`**。在某些情况下，可能需要将最初存储在不同 NDB Cluster 实例中的数据（均使用相同的模式）合并到单个目标 NDB Cluster 中。这在使用 `ndb_mgm` 客户端创建的备份（参见 [第 25.6.8.2 节, “使用 NDB Cluster 管理客户端创建备份”](#)）并使用 `ndb_restore` 进行恢复时，通过使用 NDB 8.0.21 中新增的 `--remap-column` 选项以及 `--restore-data` 选项（以及可能需要或希望的其他兼容选项）来实现。`--remap-column` 可用于处理源集群之间主键和唯一键值重叠的情况，并确保它们在目标集群中不重叠，同时保持表之间的其他关系（例如外键）。

      `--remap-column` 的参数格式为 `db.tbl.col:fn:args`，其中 `db`、`tbl` 和 `col` 分别是数据库、表和列的名称，`fn` 是重新映射函数的名称，`args` 是 `fn` 的一个或多个参数。没有默认值。仅支持 `offset` 作为函数名称，`args` 为在从备份插入到目标表时应用于列值的整数偏移量。该列必须是 `INT` 或 `BIGINT` 类型；偏移量的允许范围与该类型的有符号版本相同（如果需要，可以是负值）。

      在同一次 `ndb_restore` 调用中，可以多次使用此新选项，以便可以重新映射同一表、不同表或两者的多个列的新值。偏移值不必在所有选项实例中都相同。

      此外，从 NDB 8.0.21 开始，`ndb_desc` 提供了两个新选项：

      - `--auto-inc`（简写为 `-a`）：如果表具有 `AUTO_INCREMENT` 列，则在输出中包括下一个自增值。

      - `--context`（简写为 `-x`）：提供有关表的额外信息，包括模式、数据库名称、表名称和内部 ID。

      有关更多信息和示例，请参见 `--remap-column` 选项的说明。

  - **发送线程改进**。从 NDB 8.0.20 开始，每个发送线程现在处理一个子集的传输器，每个块线程现在仅协助一个发送线程，从而增加了发送线程的数量，从而提高了性能和数据节点的可扩展性。

  - **使用 `SpinMethod` 进行自适应旋转控制**。一个简单的接口，用于在支持的平台上设置自适应 CPU 旋转，使用数据节点参数 `SpinMethod`。该参数（在 NDB 8.0.20 中添加，NDB 8.0.24 开始可用）有四个设置，分别用于静态旋转、基于成本的自适应旋转、延迟优化的自适应旋转以及为每个线程都有自己的 CPU 的数据库机器优化的自适应旋转。每个设置使数据节点使用一组预定值来启用自适应旋转、设置旋转时间和设置旋转开销，以适应给定场景，从而无需为常见使用情况直接设置这些值。

  - 要精细调整旋转行为，还可以直接设置这些和其他旋转参数，使用现有的 `SchedulerSpinTimer` 数据节点配置参数以及 `ndb_mgm` 客户端中的以下 `DUMP` 命令：

    - `DUMP 104000 (SetSchedulerSpinTimerAll)`：设置所有线程的旋转时间

    - `DUMP 104001 (SetSchedulerSpinTimerThread)`：设置指定线程的旋转时间

    - `DUMP 104002 (SetAllowedSpinOverhead)`：设置旋转开销为允许的 CPU 时间单位数，以获得 1 单位的延迟

    - `DUMP 104003 (SetSpintimePerCall)`：设置调用旋转的时间

    - `DUMP 104004 (EnableAdaptiveSpinning)`：启用或禁用自适应旋转

    NDB 8.0.20 还增加了一个新的 TCP 配置参数 `TcpSpinTime`，用于设置给定 TCP 连接的旋转时间。

    `ndb_top` 工具也进行了增强，提供每个线程的旋转时间信息。

    有关详细信息，请参见 `SpinMethod` 参数、列出的 `DUMP` 命令和 [第 25.5.29 节, “ndb_top — 查看 NDB 线程的 CPU 使用信息”](#)。

  - **磁盘数据和集群重启**。从 NDB 8.0.21 开始，集群的初始重启会强制删除所有磁盘数据对象，如表空间和日志文件组，包括与这些对象关联的任何数据文件和撤消日志文件。

    有关更多信息，请参见 [第 25.6.11 节, “NDB Cluster 磁盘数据表”](#)。

  - **磁盘数据范围分配**。从 NDB 8.0.20 开始，数据文件中的范围分配在给定表空间使用的所有数据文件中以循环方式进行。这有望在使用多个存储设备进行磁盘数据存储的情况下改善数据分布。

    有关更多信息，请参见 [第 25.6.11.1 节, “NDB Cluster 磁盘数据对象”](#)。

  - **`--ndb-log-fail-terminate` 选项**。从 NDB 8.0.21 开始，您可以在无法完全记录所有行事件时使 SQL 节点终止。可以通过启动 `mysqld` 并带有 `--ndb-log-fail-terminate` 选项来实现此目的。

  - **`AllowUnresolvedHostNames` 参数**。默认情况下，当管理节点无法解析全局配置文件中存在的主机名时，拒绝启动，这在某些环境（如 Kubernetes）中可能会出现问题。从 NDB 8.0.22 开始，可以通过在集群全局配置文件（config.ini 文件）的 `[tcp default]` 部分中设置 `AllowUnresolvedHostNames=true` 来覆盖此行为。这样做会将此类错误视为警告，并允许 `ndb_mgmd` 继续启动。

  - **Blob 写入性能增强**.NDB 8.0.22 实现了一系列改进，使在修改同一行中的多个 blob 列或在同一语句中修改包含 blob 列的多行时，可以更高效地进行批处理，从而减少在应用这些修改时 SQL 或其他 API 节点与数据节点之间所需的往返次数。因此，许多 `INSERT`、`UPDATE` 和 `DELETE` 语句的性能可以得到提高。此类语句的示例如下，其中 `table` 是包含一个或多个 Blob 列的 NDB 表：

    - `INSERT INTO table VALUES ROW(1, blob_value1, blob_value2, ...)`，即插入包含一个或多个 Blob 列的行

    - `INSERT INTO table VALUES ROW(1, blob_value1), ROW(2, blob_value2), ROW(3, blob_value3), ...`，即插入包含一个或多个 Blob 列的多行

    - `UPDATE table SET blob_column1 = blob_value1, blob_column2 = blob_value2, ...`

    - `UPDATE table SET blob_column = blob_value WHERE primary_key_column IN (value_list)`，其中主键列不是 Blob 类型

    - `DELETE FROM table WHERE primary_key_column = value`，其中主键列不是 Blob 类型

    - `DELETE FROM table WHERE primary_key_column IN (value_list)`，其中主键列不是 Blob 类型

    其他 SQL 语句也可能受益于这些改进。这些包括 `LOAD DATA INFILE` 和 `CREATE TABLE ... SELECT ...`。此外，当 `table` 在执行语句之前使用其他存储引擎而非 NDB 时，`ALTER TABLE table ENGINE = NDB` 也可能执行得更有效率。

    此增强适用于影响 MySQL 类型为 `BLOB`、`MEDIUMBLOB`、`LONGBLOB`、`TEXT`、`MEDIUMTEXT` 和 `LONGTEXT` 的列的语句。仅更新 `TINYBLOB` 或 `TINYTEXT` 列（或两者）的语句不受此工作影响，其性能也不会有变化。

    由于需要扫描表 Blob 列，某些 SQL 语句的性能不会因该增强而显著提高，从而打破批处理。这类语句包括以下类型：

    - `SELECT FROM table [WHERE key_column IN (blob_value_list)]`，其中按使用 Blob 类型的主键或唯一键列进行匹配选择行

    - `UPDATE table SET blob_column = blob_value WHERE condition`，使用不依赖唯一值的条件

    - `DELETE FROM table WHERE condition`，使用不依赖唯一值的条件删除包含一个或多个 Blob 列的行

    - 在执行语句之前已使用 NDB 存储引擎的表上执行复制的 `ALTER TABLE` 语句，并且在执行语句之前或之后（或两者）其行包含一个或多个 Blob 列

    为了充分利用这一改进，您可能希望增加 `mysqld` 的 `--ndb-batch-size` 和 `--ndb-blob-write-batch-bytes` 选项的值，以最小化修改 blobs 所需的往返次数。对于复制，还建议您启用 `slave_allow_batching` 系统变量，这可以最大限度地减少副本集群应用 epoch 事务所需的往返次数。

    > **注意**
    >
    > 从 NDB 8.0.30 开始，您应使用 `ndb_replica_batch_size` 代替 `--ndb-batch-size`，使用 `ndb_replica_blob_write_batch_bytes` 代替 `--ndb-blob-write-batch-bytes`。有关这些变量的说明以及 [第 25.7.5 节, “为复制准备 NDB Cluster”](#) 的更多信息，请参见这些变量的说明。

  - **Node.js 更新**.从 NDB 8.0.22 开始，Node.js 的 NDB 适配器是使用 12.18.3 版本构建的，现在仅支持该版本（或更高版本）的 Node.js。

  - **加密备份**。NDB 8.0.22 增加了对使用 `AES-256-CBC` 加密的备份文件的支持；这旨在防止未授权方访问备份后恢复数据的风险。加密时，备份数据由用户提供的密码保护。密码可以是包含最多 256 个可打印 ASCII 字符（不包括 `!`、`'`、`"`、`$`、`%`、`\` 和 `^`）的任何字符串。用户或应用程序必须保留用于加密任何给定 NDB Cluster 备份的密码；NDB 不保存密码。密码可以为空，尽管不推荐这样做。

    进行 NDB Cluster 备份时，可以通过使用管理客户端 `START BACKUP` 命令中的 `ENCRYPT PASSWORD=password` 进行加密。MGM API 用户还可以通过调用 `ndb_mgm_start_backup4()` 发起加密备份。

    您可以使用 NDB Cluster 8.0.22 发行版中新增的 `ndbxfrm` 实用程序加密现有备份文件；此程序还可用于解密加密备份文件。此外，`ndbxfrm` 可以使用与 NDB Cluster 创建备份时设置 `CompressedBackup` 配置参数为 1 时采用的方法相同的方法压缩备份文件并解压缩压缩的备份文件。

    要从加密备份恢复，请使用 `ndb_restore` 并带有 `--decrypt` 和 `--backup-password` 选项。这两个选项都是必需的，以及其他在备份未加密时恢复同一备份所需的任何其他选项。`ndb_print_backup_file` 和 `ndbxfrm` 也可以使用 `-P password` 和 `--decrypt-password=password` 读取加密文件。

    在所有需要提供密码并带有加密或解密选项的情况下，必须引用密码；您可以使用单引号或双引号来限定密码。

    从 NDB 8.0.24 开始，以下列出的几个 NDB 程序也支持从标准输入输入密码，类似于使用 `--password` 选项以交互方式登录 mysql 客户端的方式：

    - 对于 `ndb_restore` 和 `ndb_print_backup_file`，`--backup-password-from-stdin` 选项使能以安全方式输入密码，类似于 mysql 客户端的 `--password` 选项。对于 `ndb_restore`，将该选项与 `--decrypt` 选项一起使用；对于 `ndb_print_backup_file`，使用该选项代替 `-P` 选项。

    - 对于 `ndb_mgm`，`--backup-password-from-stdin` 选项与 `--execute "START BACKUP [options]"` 一起使用，以便从系统 shell 启动集群备份。

    - `ndbxfrm` 选项 `--encrypt-password-from-stdin` 和 `--decrypt-password-from-stdin` 在使用该程序加密或解密备份文件时导致类似的行为。

    有关更多信息，请参见所列程序的说明。

    从 NDB 8.0.22 开始，还可以通过在集群全局配置文件的 `[ndbd default]` 部分中设置 `RequireEncryptedBackup=1` 来强制加密备份。这样做时，`ndb_mgm` 客户端会拒绝执行任何未加密的备份尝试。

    从 NDB 8.0.24 开始，您可以通过启动时使用 `--encrypt-backup` 选项来使 `ndb_mgm` 在创建备份时使用加密。在这种情况下，如果没有提供密码，则在调用 `START BACKUP` 时会提示用户输入密码。

  - **IPv6 支持**。

    从 NDB 8.0.22 开始，IPv6 地址支持管理节点和数据节点的连接；这包括管理节点和数据节点与 SQL 节点之间的连接。在配置集群时，可以使用数字 IPv6 地址、解析为 IPv6 地址的主机名或两者。

    IPv6 地址能够正常工作，前提是部署集群的操作平台和网络支持 IPv6。与使用 IPv4 地址时一样，操作平台必须提供主机名解析为 IPv6 地址的功能。

    在 Linux 平台上运行 NDB 8.0.22 及更高版本时的一个已知问题是，即使未使用 IPv6 地址，操作系统内核仍需要提供 IPv6 支持。此问题已在 NDB 8.0.34 及更高版本中修复，您可以在不打算使用 IPv6 地址的情况下安全地在 Linux 内核中禁用 IPv6 支持（Bug #33324817，Bug #33870642）。

    NDB 继续支持 IPv4 地址。不推荐同时使用 IPv4 和 IPv6 地址，但在以下情况下可以正常工作：

    - 当管理节点配置为使用 IPv6，数据节点配置为在 `config.ini` 文件中使用 IPv4 地址时：如果未使用 `--bind-address` 启动 `mgmd`，并且数据节点以 `--ndb-connectstring` 设置为管理节点的 IPv4 地址启动，则此方法有效。

    - 当管理节点配置为使用 IPv4，数据节点配置为在 `config.ini` 文件中使用 IPv6 地址时：同样，如果未将 `--bind-address` 传递给 `mgmd`，并且数据节点以 `--ndb-connectstring` 设置为管理节点的 IPv6 地址启动，则此方法有效。

    这些情况有效，因为 `ndb_mgmd` 默认不绑定到任何 IP 地址。

    要从不支持 IPv6 地址的 NDB 版本升级到支持 IPv6 地址的版本，前提是网络支持 IPv4 和 IPv6，首先执行软件升级；完成后，您可以将 `config.ini` 文件中使用的 IPv4 地址更新为 IPv6 地址。之后，为了使配置更改生效并使集群开始使用 IPv6 地址，需要执行集群的系统重启。

  - **自动安装程序弃用和移除**。MySQL NDB Cluster 自动安装程序网页安装工具（`ndb_setup.py`）在 NDB 8.0.22 中弃用，并在 NDB 8.0.23 及更高版本中移除。它不再受支持。

  - **`ndbmemcache` 弃用和移除**。`ndbmemcache` 不再受支持。`ndbmemcache` 在 NDB 8.0.22 中弃用，并在 NDB 8.0.23 中移除。

  - **`ndbinfo` `backup_id` 表**。NDB 8.0.24 在 `ndbinfo` 信息数据库中添加了一个 `backup_id` 表。这是为了替代使用 `ndb_select_all` 转储内部 `SYSTAB_0` 表内容的方式，这种方式容易出错且执行时间过长。

    该表包含一个单列单行，其中包含使用管理客户端命令 `START BACKUP` 进行的集群最近一次备份的 ID。如果找不到该集群的任何备份，该表包含单行，其列值为 0。

  - **表分区增强**。NDB 8.0.23 引入了一种新的表分区和碎片处理方法，可以独立于重做日志部分的数量来确定给定数据节点的本地数据管理器（LDM）的数量。这意味着 LDM 的数量现在可以高度变化。NDB 可以在 `ClassicFragmentation` 数据节点配置参数（同样在 NDB 8.0.23 中实现）设置为 `false` 时使用这种方法；在这种情况下，不再使用 LDM 的数量来确定为每个数据节点创建多少个分区，而是使用 `PartitionsPerNode` 参数（也在 NDB 8.0.23 中引入）来确定该数量，该参数还用于计算表使用的碎片数量。

    当 `ClassicFragmentation` 设置为默认值 `true` 时，则使用传统方法，通过使用 LDM 的数量来确定表应该有多少个碎片。

    有关更多信息，请参见之前引用的新参数的说明，位于 [多线程配置参数（ndbmtd）](#)。

- **术语更新**。为了与 MySQL 8.0.21 和 NDB 8.0.21 中开始的工作对齐，NDB 8.0.23 实现了一系列术语变更，列表如下：

  - 系统变量 `ndb_slave_conflict_role` 现在已弃用。它被 `ndb_conflict_role` 取代。

  - 许多 NDB 状态变量已弃用。这些变量及其替代项如下表所示：

    | 弃用变量                                     | 替代变量                                       |
    | -------------------------------------------- | ---------------------------------------------- |
    | `Ndb_api_adaptive_send_deferred_count_slave` | `Ndb_api_adaptive_send_deferred_count_replica` |
    | `Ndb_api_adaptive_send_forced_count_slave`   | `Ndb_api_adaptive_send_forced_count_replica`   |
    | `Ndb_api_adaptive_send_unforced_count_slave` | `Ndb_api_adaptive_send_unforced_count_replica` |
    | `Ndb_api_bytes_received_count_slave`         | `Ndb_api_bytes_received_count_replica`         |
    | `Ndb_api_bytes_sent_count_slave`             | `Ndb_api_bytes_sent_count_replica`             |
    | `Ndb_api_pk_op_count_slave`                  | `Ndb_api_pk_op_count_replica`                  |
    | `Ndb_api_pruned_scan_count_slave`            | `Ndb_api_pruned_scan_count_replica`            |
    | `Ndb_api_range_scan_count_slave`             | `Ndb_api_range_scan_count_replica`             |
    | `Ndb_api_read_row_count_slave`               | `Ndb_api_read_row_count_replica`               |
    | `Ndb_api_scan_batch_count_slave`             | `Ndb_api_scan_batch_count_replica`             |
    | `Ndb_api_table_scan_count_slave`             | `Ndb_api_table_scan_count_replica`             |
    | `Ndb_api_trans_abort_count_slave`            | `Ndb_api_trans_abort_count_replica`            |
    | `Ndb_api_trans_close_count_slave`            | `Ndb_api_trans_close_count_replica`            |
    | `Ndb_api_trans_commit_count_slave`           | `Ndb_api_trans_commit_count_replica`           |
    | `Ndb_api_trans_local_read_row_count_slave`   | `Ndb_api_trans_local_read_row_count_replica`   |
    | `Ndb_api_trans_start_count_slave`            | `Ndb_api_trans_start_count_replica`            |
    | `Ndb_api_uk_op_count_slave`                  | `Ndb_api_uk_op_count_replica`                  |
    | `Ndb_api_wait_exec_complete_count_slave`     | `Ndb_api_wait_exec_complete_count_replica`     |
    | `Ndb_api_wait_meta_request_count_slave`      | `Ndb_api_wait_meta_request_count_replica`      |
    | `Ndb_api_wait_nanos_count_slave`             | `Ndb_api_wait_nanos_count_replica`             |
    | `Ndb_api_wait_scan_result_count_slave`       | `Ndb_api_wait_scan_result_count_replica`       |
    | `Ndb_slave_max_replicated_epoch`             | `Ndb_replica_max_replicated_epoch`             |
    
    - 
      弃用的状态变量继续显示在 `SHOW STATUS` 的输出中，但应尽快更新应用程序以不再依赖它们，因为将来发布的版本中可能不再提供这些变量。
    
    
      - `ndbinfo.table_distribution_status` 表中的 `tab_copy_status` 列之前显示的值 `ADD_TABLE_MASTER` 和 `ADD_TABLE_SLAVE` 已弃用。这些值分别被 `ADD_TABLE_COORDINATOR` 和 `ADD_TABLE_PARTICIPANT` 取代。
    
    
      - 一些 NDB 客户端和实用程序程序（例如 `ndb_restore`）的 `--help` 输出已被修改。
    
  
  - **`ThreadConfig` 增强**。从 NDB 8.0.23 开始，`ThreadConfig` 参数的可配置性扩展了两个新线程类型，列表如下：
  
    - `query`：查询线程仅处理 `READ COMMITTED` 查询。查询线程还充当恢复线程。查询线程的数量必须是 LDM 线程数量的 0、1、2 或 3 倍。0（默认值，除非使用 `ThreadConfig` 或启用 `AutomaticThreadConfig`）会导致 LDM 行为与 NDB 8.0.23 之前相同。
  
    - `recover`：恢复线程从本地检查点检索数据。指定为此类的恢复线程永远不会充当查询线程。
  
      还可以通过以下两种方式组合现有的 `main` 和 `rep` 线程：
  
    - 通过将这些参数中的任何一个设置为 0 组合为一个线程。当这样做时，生成的组合线程在 `ndbinfo.threads` 表中显示为 `main_rep`。
  
    - 通过将 `ldm` 和 `tc` 都设置为 0，并将 `recv` 设置为 1，与 `recv` 线程一起组合。在这种情况下，组合线程命名为 `main_rep_recv`。
  
    此外，某些现有线程类型的最大数量已经增加。包括查询线程和恢复线程在内的新最大值如下：
  
    - `LDM`: 332
  
    - `Query`: 332
  
    - `Recovery`: 332
  
    - `TC`: 128
  
    - `Receive`: 64
  
    - `Send`: 64
  
    - `Main`: 2
  
    其他线程类型的最大值保持不变。
  
    此外，由于与此任务相关的工作结果，NDB 现在使用互斥体保护在使用超过 32 个块线程时的作业缓冲区。虽然这可能会导致性能略有下降（大多数情况下下降 1% 至 2%），但也显著减少了非常大配置所需的内存。例如，在 NDB 8.0.23 之前使用 64 个线程的设置需要 2 GB 的作业缓冲区内存，而在 NDB 8.0.23 及更高版本中应仅需要约 1 GB。在我们的测试中，这在执行非常复杂的查询时总体上提高了约 5% 的效率。
  
    有关详细信息，请参见 `ThreadConfig` 参数和 `ndbinfo.threads` 表的说明。
  
  - **`ThreadConfig` 线程计数更改**。由于在 NDB 8.0.30 中进行的工作结果，从此 NDB Cluster 版本开始，设置 `ThreadConfig` 的值需要在 `ThreadConfig` 值字符串中明确包括 `main`、`rep`、`recv` 和 `ldm`。此外，必须明确为每个未使用的线程类型（`main`、`rep` 或 `ldm`）设置 `count=0`，并且设置 `rep` 的 `count=1` 时需要同时设置 `main` 的 `count=1`。
  
    这些更改可能会对使用此参数的 NDB 集群升级产生重大影响；有关更多信息，请参见 [第 25.3.7 节, “NDB Cluster 的升级和降级”](#)。
  
  - **`ndbmtd` 线程自动配置**。从 NDB 8.0.23 开始，可以使用 `ndbmtd` 配置参数 `AutomaticThreadConfig` 对多线程数据节点的线程进行自动配置。当此参数设置为 1 时，NDB 会根据应用程序可用处理器的数量自动设置线程分配，适用于所有受支持的线程类型，包括之前描述的新查询和恢复线程类型。如果系统未限制处理器数量，可以通过设置 `NumCPUs`（也在 NDB 8.0.23 中添加）来限制，否则，自动线程配置可容纳多达 1024 个 CPU。
  
    无论 `config.ini` 中设置了任何值，自动线程配置都会发生；这意味着不需要设置 `ThreadConfig` 或 `MaxNoOfExecutionThreads` 这两个参数。
  
    此外，NDB 8.0.23 实现了一些新的 `ndbinfo` 信息数据库表，提供有关硬件和 CPU 可用性以及 NDB 数据节点 CPU 使用情况的信息。这些表如下：
  
    - `cpudata`
  
    - `cpudata_1sec`
  
    - `cpudata_20sec`
  
    - `cpudata_50ms`
  
    - `cpuinfo`
  
    - `hwinfo`
  
    这些表并非在 NDB Cluster 支持的每个平台上都可用；有关更多信息，请参见它们的单独说明。
  
  - **NDB 数据库对象的层次视图**。NDB 8.0.24 中添加的 `ndbinfo` 信息数据库的 `dict_obj_tree` 表可以提供许多 NDB 数据库对象的层次结构和树状视图，包括以下内容：
  
    - 表和相关索引
  
    - 表空间和相关数据文件
  
    - 日志文件组和相关撤消日志文件
  
    有关更多信息和示例，请参见 [第 25.6.16.25 节, “ndbinfo.dict_obj_tree 表”](#)。
  
  - **索引统计信息增强**。NDB 8.0.24 实现了以下索引统计信息计算的改进：
  
    - 以前仅从一个碎片收集索引统计信息；此更改扩展到其他碎片。
  
    - 用于非常小表（如只有几行的表，结果会被丢弃）的算法已改进，因此此类表的估计应该比以前更准确。
  
    - 从 NDB 8.0.27 开始，索引统计信息表默认情况下自动创建和更新，`IndexStatAutoCreate` 和 `IndexStatAutoUpdate` 都默认设置为 1（启用），而不是 0（禁用），不再需要运行 `ANALYZE TABLE` 以更新统计信息。
  
    有关更多信息，请参见 [第 25.6.15 节, “NDB API 统计计数器和变量”](#)。
  
  - **恢复操作期间在 `NULL` 和 `NOT NULL` 之间的转换**。从 NDB 8.0.26 开始，`ndb_restore` 可以支持将 `NULL` 列恢复为 `NOT NULL` 及其反向操作，使用以下选项：
  
    - 要将 `NULL` 列恢复为 `NOT NULL`，请使用 `--lossy-conversions` 选项。
    - 最初声明为 `NULL` 的列不得包含任何 `NULL` 行；如果有，`ndb_restore` 会出错退出。
  
    - 要将 `NOT NULL` 列恢复为 `NULL`，请使用 `--promote-attributes` 选项。
  
    有关更多信息，请参见所指示的 `ndb_restore` 选项的说明。
  
  - **NdbScanFilter 的 SQL 合规 NULL 比较模式**。传统上，当涉及 `NULL` 进行比较时，`NdbScanFilter` 将 `NULL` 视为等于 `NULL`（因此认为 `NULL == NULL` 为 `TRUE`）。这与 SQL 标准规定的不同，SQL 标准要求任何与 `NULL` 的比较返回 `NULL`，包括 `NULL == NULL`。
  
    以前，NDB API 应用程序无法覆盖此行为；从 NDB 8.0.26 开始，您可以在创建扫描过滤器之前调用 `NdbScanFilter::setSqlCmpSemantics()` 来实现此目的。（因此，该方法总是作为类方法调用，而不是实例方法。）这样做会导致下一个 `NdbScanFilter` 对象在其生命周期内的所有比较操作中使用 SQL 合规的比较方式。您必须为每个应使用 SQL 合规比较的 `NdbScanFilter` 对象调用该方法。
  
    有关更多信息，请参见 `NdbScanFilter::setSqlCmpSemantics()`。
  
  - **NDB API `.FRM` 文件方法弃用**。MySQL 8.0 和 NDB 8.0 不再使用 `.FRM` 文件存储表元数据。因此，从 NDB 8.0.27 开始，NDB API 方法 `getFrmData()`、`getFrmLength()` 和 `setFrm()` 被弃用，并将在未来版本中移除。要读取和写入表元数据，请改用 `getExtraMetadata()` 和 `setExtraMetadata()`。
  
  - **优先使用 IPv4 或 IPv6 地址**。NDB 8.0.26 增加了 `PreferIPVersion` 配置参数，用于控制 DNS 解析的地址优先级。默认情况下为 IPv4（`PreferIPVersion=4`）。由于 NDB 中的配置检索需要对所有 TCP 连接的此优先级相同，因此应仅在集群全局配置（config.ini）文件的 `[tcp default]` 部分设置此参数。
  
    有关更多信息，请参见 [第 25.4.3.10 节, “NDB Cluster TCP/IP 连接”](#)。
  
  - **日志记录增强**。以前，分析 NDB Cluster 数据节点和管理节点日志可能会受到不同日志消息使用不同格式以及并非所有日志消息都包含时间戳的影响。这些问题部分是由于日志记录由多种不同机制执行，例如 `printf`、`fprintf`、`ndbout` 和 `ndbout_c`，以及 `<<` 运算符的重载等。
  
    我们通过标准化使用 NDB 中已有的 `EventLogger` 机制解决了这些问题，该机制在每个日志消息开头添加 `YYYY-MM-DD HH:MM:SS` 格式的时间戳。
  
    有关 NDB Cluster 事件日志和 `EventLogger` 日志消息格式的更多信息，请参见 [第 25.6.3 节, “NDB Cluster 中生成的事件报告”](#)。
  
  - **复制的 `ALTER TABLE` 改进**。从 NDB 8.0.27 开始，在 NDB 表上执行复制的 `ALTER TABLE` 会在执行复制之前和之后比较源表的碎片提交计数。这允许执行此语句的 SQL 节点确定是否有任何并发写入活动到被修改的表；如果有，SQL 节点可以终止操作。
  
    当检测到对被修改表的并发写入时，`ALTER TABLE` 语句会被拒绝，并显示错误消息 `Detected change to data in source table during copying ALTER TABLE. Alter aborted to avoid inconsistency (ER_TABLE_DEF_CHANGED)`。终止修改操作而不是在并发写入情况下继续进行，可以帮助防止静默数据丢失或损坏。
  
  - **`ndbinfo` `index_stats` 表**。NDB 8.0.28 增加了 `index_stats` 表，提供有关 NDB 索引统计信息的基本信息。它主要用于内部测试，但可能作为 `ndb_index_stat` 的补充。
  
  - **`ndb_import` `--table` 选项**。在 NDB 8.0.28 之前，`ndb_import` 总是将从 CSV 文件读取的数据导入名称源自读取文件名称的表中。NDB 8.0.28 为该程序增加了一个 `--table` 选项（简写为 `-t`），以直接指定目标表的名称，并覆盖以前的行为。
  
    `ndb_import` 的默认行为仍然是使用输入文件的基本名称作为目标表的名称。
  
  - **`ndb_import` `--missing-ai-column` 选项**。从 NDB 8.0.29 开始，`ndb_import` 可以使用该版本中引入的 `--missing-ai-column` 选项，从包含 `AUTO_INCREMENT` 列的 CSV 文件中导入数据。该选项可以与一个或多个包含此类列的表一起使用。
  
    为了使此选项有效，CSV 文件中的 `AUTO_INCREMENT` 列不得包含任何值。否则，导入操作无法进行。
  
  - **`ndb_import` 和空行**。`ndb_import` 一直拒绝在传入 CSV 文件中遇到的任何空行。NDB 8.0.30 增加了将空行导入单列的支持，前提是可以将空值转换为列值。
  
  - **`ndb_restore` `--with-apply-status` 选项**。从 NDB 8.0.29 开始，可以使用该版本中添加的 `--with-apply-status` 选项从 NDB 备份恢复 `ndb_apply_status` 表。要使用此选项，您必须在调用 `ndb_restore` 时使用 `--restore-data`。
  
    `--with-apply-status` 会恢复 `ndb_apply_status` 表的所有行，但 `server_id = 0` 的行除外；要恢复该行，请使用 `--restore-epoch`。有关更多信息，请参见 `ndb_apply_status` 表及其 `--with-apply-status` 选项的说明。
  
  - **对缺少索引的表的 SQL 访问**。在 NDB 8.0.29 之前，当用户查询尝试打开缺少或损坏索引的 NDB 表时，MySQL 服务器会引发 NDB 错误 4243（索引未找到）。当约束违规或缺少数据使恢复 NDB 表上的索引变得不可能，并且使用 `ndb_restore --disable-indexes` 恢复数据而不恢复索引时，可能会出现这种情况。
  
    从 NDB 8.0.29 开始，对缺少索引的 NDB 表执行的 SQL 查询如果不使用任何缺失的索引，则会成功。否则，查询会被拒绝并显示 `ER_NOT_KEYFILE` 错误。在这种情况下，您可以使用 `ALTER TABLE ... ALTER INDEX ... INVISIBLE` 来防止 MySQL 优化器尝试使用索引，或使用适当的 SQL 语句删除索引（然后可能重新创建它）。
  
  - **NDB API `List::clear()` 方法**。NDB API 字典方法 `listEvents()`、`listIndexes()` 和 `listObjects()` 都需要一个引用空列表对象。以前，由于此原因，重复使用现有列表与这些方法中的任何一个一起使用都是有问题的。NDB 8.0.29 通过实现 `clear()` 方法解决了这一问题，该方法从列表中删除所有数据。
  
    作为此工作的组成部分，列表类析构函数现在在删除列表中的任何元素或属性之前调用 `List::clear()`。
  
  - **`ndbinfo` 中的 NDB 字典表**。NDB 8.0.29 在 `ndbinfo` 数据库中引入了几个新表，提供以前需要使用 `ndb_desc`、`ndb_select_all` 和其他 NDB 实用程序程序获取的 NdbDictionary 信息。
  
    其中两个表实际上是视图。`hash_maps` 表提供 NDB 使用的哈希映射的信息；`files` 表显示有关用于在磁盘上存储数据的文件的信息（参见 [第 25.6.11 节, “NDB Cluster 磁盘数据表”](#)）。
  
    剩下的六个 `ndbinfo` 表是基本表。这些表不隐藏且不以 `ndb$` 前缀命名。列出这些表，并描述每个表中表示的对象：
  
    - `blobs`：用于存储 BLOB 和 TEXT 列的可变大小部分的 BLOB 表
  
    - `dictionary_columns`：NDB 表的列
  
    - `dictionary_tables`：NDB 表
  
    - `events`：NDB API 中的事件订阅
  
    - `foreign_keys`：NDB 表上的外键
  
    - `index_columns`：NDB 表上的索引
  
    NDB 8.0.29 还在 `ndbinfo` 存储引擎中对主键的实现进行了更改，以提高与 `NdbDictionary` 的兼容性。
  
  - **`ndbcluster` 插件和 `Performance Schema`**。从 NDB 8.0.29 开始，`ndbcluster` 插件线程显示在 `Performance Schema` 的 `threads` 和 `setup_threads` 表中，使得可以获取有关这些线程性能的信息。`Performance Schema` 表中暴露的三个线程如下：
  
    - `ndb_binlog`：二进制日志线程
  
    - `ndb_index_stat`：索引统计信息线程
  
    - `ndb_metadata`：元数据线程
  
    有关更多信息和示例，请参见 [ndbcluster 插件线程](#)。
  
    在 NDB 8.0.30 及更高版本中，事务批处理内存使用情况在 `Performance Schema memory_summary_by_thread_by_event_name` 和 `setup_instruments` 表中显示为 `memory/ndbcluster/Thd_ndb::batch_mem_root`。您可以使用此信息查看事务使用的内存量。有关详细信息，请参见 [事务内存使用情况](#)。
  
  - **可配置的 BLOB 内联大小**。从 NDB 8.0.30 开始，可以在 `CREATE TABLE` 或 `ALTER TABLE` 中设置 BLOB 列的内联大小。NDB Cluster 支持的最大内联大小为 29980 字节。
  
    有关更多信息和示例，请参见 [NDB_COLUMN 选项](#) 以及 [字符串类型存储要求](#)。
  
  - **默认启用 `replica_allow_batching`**。副本写入批处理极大地提高了 NDB Cluster 复制性能，特别是在复制 BLOB 类型列（TEXT、BLOB 和 JSON）时，因此在使用 NDB Cluster 进行复制时应尽可能启用。从 NDB 8.0.30 开始，`replica_allow_batching` 系统变量默认启用，设置为 `OFF` 时会发出警告。
  
  - **冲突解决插入操作支持**。在 NDB 8.0.30 之前，对于更新和删除操作的主键冲突，只有两种可用的解决策略，分别实现为函数 `NDB$MAX()` 和 `NDB$MAX_DELETE_WIN()`。除了具有相同主键的写操作总是被拒绝并且仅在没有具有相同主键的操作存在时才被接受和应用之外，这些对写操作没有任何影响。NDB 8.0.30 引入了两个新的冲突解决函数 `NDB$MAX_INS()` 和 `NDB$MAX_DEL_WIN_INS()`，它们处理插入操作之间的主键冲突。这些函数处理冲突的写操作如下：
  
    - 如果没有冲突的写操作，则应用此写操作（与 `NDB$MAX()` 相同）。
  
    - 否则，应用“最大时间戳胜出”冲突解决策略，如下所示：
      - 如果传入写操作的时间戳大于冲突写操作的时间戳，则应用传入操作。
        - 如果传入写操作的时间戳不大于冲突写操作的时间戳，则拒绝传入写操作。
  
    对于冲突的更新和删除操作，`NDB$MAX_INS()` 表现为 `NDB$MAX()`，`NDB$MAX_DEL_WIN_INS()` 表现为 `NDB$MAX_DELETE_WIN()`。
  
    此增强提供了配置冲突检测的支持，以便在处理冲突的复制写操作时，以较高时间戳列值的复制插入操作是幂等的，而较低时间戳列值的复制插入操作被拒绝。
  
    与其他冲突解决函数一样，拒绝的操作可以选择性地记录在异常表中；拒绝的操作会增加计数器（状态变量 `Ndb_conflict_fn_max` 表示“最大时间戳胜出”，`Ndb_conflict_fn_old` 表示“相同时间戳胜出”）。
  
    有关更多信息，请参见新冲突解决函数的说明，以及 [第 25.7.12 节, “NDB Cluster 复制冲突解决”](#)。
  
  - **复制应用程序批处理大小控制**。
  
    以前，用于写入副本 NDB Cluster 的批处理大小由 `--ndb-batch-size` 控制，用于写入 Blob 数据到副本的批处理大小由 `ndb-blob-write-batch-bytes` 决定。此安排的一个问题是副本使用这些变量的全局值，这意味着更改副本的任一值也会影响所有其他会话使用的值。此外，不可能为这些值设置仅限副本的不同默认值，副本的默认值应比其他会话更高。
  
    NDB 8.0.30 增加了两个特定于副本应用程序的新系统变量。`ndb_replica_batch_size` 现在控制副本应用程序使用的批处理大小，`ndb_replica_blob_write_batch_bytes` 变量现在决定用于执行批处理 Blob 写入的 Blob 写入批处理大小。
  
    此更改应改进使用默认设置的 MySQL NDB Cluster 复制行为，并允许用户微调 NDB 复制性能而不影响用户线程，例如那些执行 SQL 查询处理的线程。
  
    有关更多信息，请参见新变量的说明。另请参见 [第 25.7.5 节, “为复制准备 NDB Cluster”](#)。
  
  - **二进制日志事务压缩**。NDB 8.0.31 增加了对使用 ZSTD 压缩的二进制日志事务的支持。要启用此功能，请设置在该版本中引入的 `ndb_log_transaction_compression` 系统变量为 `ON`。使用的压缩级别可以通过同样在该版本中添加的 `ndb_log_transaction_compression_level_zstd` 系统变量控制，默认压缩级别为 3。
  
    尽管 `binlog_transaction_compression` 和 `binlog_transaction_compression_level_zstd` 服务器系统变量对 NDB 表的二进制日志记录没有影响，但以 `--binlog-transaction-compression=ON` 启动 `mysqld` 会自动启用 `ndb_log_transaction_compression`。您可以在服务器启动完成后在 MySQL 客户端会话中使用 `SET @@global.ndb_log_transaction_compression=OFF` 禁用它。
  
    有关更多信息，请参见 `ndb_log_transaction_compression` 以及 [第 7.4.4.5 节, “二进制日志事务压缩”](#)。
  
  - **NDB 复制：多线程应用程序**。从 NDB 8.0.33 开始，NDB Cluster 复制支持 MySQL 多线程应用程序（MTA）在副本服务器上（和非零值的 `replica_parallel_workers`），这使得可以在副本上并行应用二进制日志事务，从而提高吞吐量。（有关 MySQL 服务器中多线程应用程序的更多信息，请参见 [第 19.2.3 节, “复制线程”](#)。）
  
    在副本上启用此功能需要在源上启动时设置 `--ndb-log-transaction-dependency=ON`（此选项也在 NDB 8.0.33 中实现）。源上还需要将 `binlog_transaction_dependency_tracking` 设置为 `WRITESET`。此外，您必须确保副本上的 `replica_parallel_workers` 的值大于 1，因此，副本使用多个工作线程。
  
    有关更多信息和要求，请参见 [第 25.7.11 节, “使用多线程应用程序的 NDB Cluster 复制”](#)。
  
  - **构建选项的更改**。NDB 8.0.31 对用于构建 MySQL Cluster 的 CMake 选项进行了以下更改。
  
    - `WITH_NDBCLUSTER` 选项已弃用，`WITH_PLUGIN_NDBCLUSTER` 被移除。
  
    - 要从源代码构建 MySQL Cluster，请使用新添加的 `WITH_NDB` 选项。
  
    - `WITH_NDBCLUSTER_STORAGE_ENGINE` 继续受支持，但对大多数构建不再需要。
  
    有关更多信息，请参见 [编译 NDB Cluster 的 CMake 选项](#)。
  
  - **文件系统加密**。透明数据加密（TDE）通过加密 NDB 静态数据（即所有 NDB 表数据和日志文件）提供保护。这旨在防止在未经授权访问 NDB Cluster 数据文件（如表空间文件或日志）后恢复数据的风险。
  
    加密由数据节点上的 NDB 文件系统层（NDBFS）透明地实现；数据在从文件读取和写入文件时加密和解密，NDBFS 内部客户端块正常操作文件。
  
    NDBFS 可以直接使用用户提供的密码透明地加密文件，但将单个文件的加密和解密与用户提供的密码分离在效率、可用性、安全性和灵活性方面可能是有利的。参见 [第 25.6.14.2 节, “NDB 文件系统加密实现”](#)。
  
    TDE 使用两种类型的密钥。一个密钥用于加密实际存储在磁盘上的数据和日志文件（包括 LCP、重做、撤消和表空间文件）。一个主密钥用于加密该密钥。
  
    从 NDB 8.0.29 开始，数据节点配置参数 `EncryptedFileSystem` 设置为 1 时，强制对存储表数据的文件进行加密。这包括 LCP 数据文件、重做日志文件、表空间文件和撤消日志文件。
  
    启动或重新启动数据节点时还需要提供密码，使用 `--filesystem-password` 或 `--filesystem-password-from-stdin` 选项。参见 [第 25.6.14.1 节, “NDB 文件系统加密设置和使用”](#)。此密码的格式与加密 NDB 备份使用的密码相同，并受相同约束；有关详细信息，请参见 `ndb_restore --backup-password` 选项的说明。
  
    只有使用 NDB 存储引擎的表受此功能的加密；参见 [第 25.6.14.3 节, “NDB 文件系统加密限制”](#)。其他表（如用于 NDB 模式分发、复制和二进制日志记录的表）通常使用 InnoDB；参见 [第 17.13 节, “InnoDB 静态数据加密”](#)。有关二进制日志文件加密的信息，请参见 [第 19.3.2 节, “加密二进制日志文件和中继日志文件”](#)。
  
    NDB 进程生成或使用的文件（如操作系统日志、崩溃日志和核心转储）不加密。NDB 使用但不包含任何用户表数据的文件也不加密；这些文件包括 LCP 控制文件、模式文件和系统文件（参见 NDB Cluster 数据节点文件系统）。管理服务器配置缓存也不加密。
  
    此外，NDB 8.0.31 增加了一个新实用程序 `ndb_secretsfile_reader`，用于从秘密文件（S0.sysfile）中提取密钥信息。
  
    此增强基于 NDB 8.0.22 中实施的加密 NDB 备份的工作。有关加密备份的更多信息，请参见 `RequireEncryptedBackup` 配置参数的说明，以及 [第 25.6.8.2 节, “使用 NDB Cluster 管理客户端创建备份”](#)。

- **移除不需要的程序选项**。NDB Cluster 8.0.31 中删除了许多从未实现的“垃圾”命令行选项。这些选项及其从中删除的程序列表如下：

  - `--ndb-optimized-node-selection`：

    `ndbd`, `ndbmtd`, `ndb_mgm`, `ndb_delete_all`, `ndb_desc`, `ndb_drop_index`, `ndb_drop_table`, `ndb_show_table`, `ndb_blob_tool`, `ndb_config`, `ndb_index_stat`, `ndb_move_data`, `ndbinfo_select_all`, `ndb_select_count`
  - `--character-sets-dir`：

    `ndb_mgm`, `ndb_mgmd`, `ndb_config`, `ndb_delete_all`, `ndb_desc`, `ndb_drop_index`, `ndb_drop_table`, `ndb_show_table`, `ndb_blob_tool`, `ndb_config`, `ndb_index_stat`, `ndb_move_data`, `ndbinfo_select_all`, `ndb_select_count`, `ndb_waiter`

  - `--core-file`：

    `ndb_mgm`, `ndb_mgmd`, `ndb_config`, `ndb_delete_all`, `ndb_desc`, `ndb_drop_index`, `ndb_drop_table`, `ndb_show_table`, `ndb_blob_tool`, `ndb_config`, `ndb_index_stat`, `ndb_move_data`, `ndbinfo_select_all`, `ndb_select_count`, `ndb_waiter`

  - `--connect-retries` 和 `--connect-retry-delay`：

    `ndb_mgmd`

  - `--ndb-nodeid`：
    
    `ndb_config`

  有关更多信息，请参见相关程序和选项说明，位于 [第 25.5 节, “NDB Cluster 程序”](#)。

- **读取配置缓存文件**。从 NDB 8.0.32 开始，可以使用该版本中引入的 `ndb_config` 选项 `--config-binary-file` 读取由 `ndb_mgmd` 创建的二进制配置缓存文件。这可以简化确定是否已将给定配置文件中的设置应用于集群的过程，或者在 `config.ini` 文件因某种原因损坏或丢失后从二进制缓存中恢复设置的过程。

  有关更多信息和示例，请参见 [第 25.5.7 节, “ndb_config — 提取 NDB Cluster 配置信息”](#) 中该选项的说明。

- **`ndbinfo` `transporter_details` 表**。此 `ndbinfo` 表提供有关 NDB 集群中使用的各个传输器的信息。添加于 NDB 8.0.37，除此之外，它与 `ndbinfo` `transporters` 表类似。

  有关更多信息，请参见 [第 25.6.16.64 节, “ndbinfo.transporter_details 表”](#)。

MySQL Cluster Manager 提供对 NDB Cluster 8.0 的支持。MySQL Cluster Manager 具有高级命令行界面，可以简化许多复杂的 NDB Cluster 管理任务。有关更多信息，请参见 [MySQL Cluster Manager 8.0.36 用户手册](#)。