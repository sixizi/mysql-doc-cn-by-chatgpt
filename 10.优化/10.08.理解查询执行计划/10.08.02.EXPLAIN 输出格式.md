## 10.8.2 EXPLAIN 输出格式

`EXPLAIN` 语句提供有关 MySQL 如何执行语句的信息。`EXPLAIN` 适用于 `SELECT`、`DELETE`、`INSERT`、`REPLACE` 和 `UPDATE` 语句。

`EXPLAIN` 为 `SELECT` 语句中使用的每个表返回一行信息。它按 MySQL 处理语句时读取表的顺序列出输出中的表。这意味着 MySQL 从第一个表读取一行，然后在第二个表中找到匹配的行，然后在第三个表中找到匹配的行，依此类推。当所有表都处理完后，MySQL 输出选定的列，并回溯表列表，直到找到一个有更多匹配行的表。从该表读取下一行，并继续处理下一个表。

> **注意**
>
> MySQL Workbench 提供可视化 EXPLAIN 功能，以图形方式展示 EXPLAIN 输出。详见教程：“使用 EXPLAIN 改善查询性能”。

### EXPLAIN 输出列

#### EXPLAIN 连接类型

#### EXPLAIN 额外信息

#### EXPLAIN 输出解释

### EXPLAIN 输出列

本节描述了 EXPLAIN 生成的输出列。后面的章节提供有关 `type` 和 `Extra` 列的更多信息。

`EXPLAIN` 的每个输出行提供有关一个表的信息。每行包含表 10.1“EXPLAIN 输出列”中总结的值，并在表后更详细地描述。列名显示在表的第一列中；第二列提供使用 `FORMAT=JSON` 时输出中显示的等效属性名称。

#### 表 10.1 EXPLAIN 输出列

| 列名            | JSON 名称       | 含义                     |
| --------------- | --------------- | ------------------------ |
| `id`            | `select_id`     | `SELECT` 标识符          |
| `select_type`   | None            | `SELECT` 类型            |
| `table`         | `table_name`    | 输出行的表               |
| `partitions`    | `partitions`    | 匹配的分区               |
| `type`          | `access_type`   | 连接类型                 |
| `possible_keys` | `possible_keys` | 可能选择的索引           |
| `key`           | `key`           | 实际选择的索引           |
| `key_len`       | `key_length`    | 所选键的长度             |
| `ref`           | `ref`           | 与索引比较的列           |
| `rows`          | `rows`          | 估计要检查的行数         |
| `filtered`      | `filtered`      | 由表条件过滤的行的百分比 |
| `Extra`         | None            | 额外信息                 |

> **注意**
>
> 在 JSON 格式化的 EXPLAIN 输出中，属性为 `NULL` 的 JSON 属性不会显示。

#### id (`JSON 名称：select_id`)

`SELECT` 标识符。这是查询中 `SELECT` 的顺序编号。如果行引用其他行的联合结果，则值可以为 `NULL`。在这种情况下，`table` 列显示类似 `<unionM,N>` 的值，表示该行引用 ID 值为 `M` 和 `N` 的行的联合。

#### select_type (`JSON 名称：none`)

`SELECT` 类型，可以是以下任意一种。JSON 格式的 EXPLAIN 将 `SELECT` 类型作为 `query_block` 的属性公开，除非它是 `SIMPLE` 或 `PRIMARY`。表中还显示了 JSON 名称（如适用）。

| select_type 值       | JSON 名称                    | 含义                                                        |
| -------------------- | ---------------------------- | ----------------------------------------------------------- |
| SIMPLE               | None                         | 简单 `SELECT`（不使用 `UNION` 或子查询）                    |
| PRIMARY              | None                         | 最外层 `SELECT`                                             |
| UNION                | None                         | `UNION` 中的第二个或后续 `SELECT` 语句                      |
| DEPENDENT UNION      | `dependent (true)`           | 依赖于外部查询的 `UNION` 中的第二个或后续 `SELECT` 语句     |
| UNION RESULT         | `union_result`               | `UNION` 的结果                                              |
| SUBQUERY             | None                         | 子查询中的第一个 `SELECT`                                   |
| DEPENDENT SUBQUERY   | `dependent (true)`           | 依赖于外部查询的子查询中的第一个 `SELECT`                   |
| DERIVED              | None                         | 派生表                                                      |
| DEPENDENT DERIVED    | `dependent (true)`           | 依赖于另一个表的派生表                                      |
| MATERIALIZED         | `materialized_from_subquery` | 物化子查询                                                  |
| UNCACHEABLE SUBQUERY | `cacheable (false)`          | 结果无法缓存且必须为外部查询的每一行重新评估的子查询        |
| UNCACHEABLE UNION    | `cacheable (false)`          | 属于不可缓存子查询的 `UNION` 中的第二个或后续 `SELECT` 语句 |

`DEPENDENT` 通常表示使用相关子查询。详见第 15.2.15.7 节，“`相关子查询`”。

`DEPENDENT SUBQUERY` 的评估与 `UNCACHEABLE SUBQUERY` 的评估不同。对于 `DEPENDENT SUBQUERY`，子查询仅在其外部上下文的变量值不同的每组值时重新评估一次。对于 `UNCACHEABLE SUBQUERY`，子查询对于外部上下文的每一行重新评估。

当使用 `FORMAT=JSON` 与 `EXPLAIN` 一起指定时，输出没有直接等同于 `select_type` 的单一属性；`query_block` 属性对应于给定的 `SELECT`。大多数 `SELECT` 子查询类型的等效属性是可用的（例如 `materialized_from_subquery` 对于 `MATERIALIZED`），并在适当时显示。没有 JSON 等效于 `SIMPLE` 或 `PRIMARY`。

对于非 `SELECT` 语句，`select_type` 值显示受影响表的语句类型。例如，对于 `DELETE` 语句，`select_type` 为 `DELETE`。

#### table (`JSON 名称：table_name`)

输出行所指的表的名称。这也可以是以下值之一：

- `<unionM,N>`：该行引用 ID 值为 `M` 和 `N` 的行的联合。
- `<derivedN>`：该行引用 ID 值为 `N` 的行的派生表结果。例如，派生表可以由 `FROM` 子句中的子查询生成。
- `<subqueryN>`：该行引用 ID 值为 `N` 的行的物化子查询结果。详见第 10.2.2.2 节，“`使用物化优化子查询`”。

#### partitions (`JSON 名称：partitions`)

查询匹配的分区。对于非分区表，该值为 `NULL`。详见第 26.3.5 节，“`获取分区信息`”。

#### type (`JSON 名称：access_type`)

连接类型。有关不同类型的描述，请参见“EXPLAIN 连接类型”。

#### possible_keys (`JSON 名称：possible_keys`)

`possible_keys` 列指示 MySQL 可以选择使用哪些索引来查找该表中的行。请注意，此列与输出中显示的表的顺序完全独立。这意味着在生成的表顺序中，`possible_keys` 中的某些键可能实际上不可用。

如果此列为 `NULL`（或在 JSON 格式输出中未定义），则没有相关索引。在这种情况下，您可以通过检查 `WHERE` 子句来改进查询性能，查看它是否引用了一些适合索引的列。如果是，请创建适当的索引，然后再次使用 `EXPLAIN` 检查查询。详见第 15.1.9 节，“`ALTER TABLE 语句`”。

要查看表有哪些索引，请使用 `SHOW INDEX FROM tbl_name`。

#### key (`JSON 名称：key`)

`key` 列指示 MySQL 实际决定使用的索引。如果 MySQL 决定使用 `possible_keys` 索引之一来查找行，则该索引列为 `key` 值。

`key` 可能列出一个在 `possible_keys` 中不存在的索引。这可能发生在 `possible_keys` 索引都不适合查找行的情况下，但查询选择的所有列都属于某个其他索引。也就是说，命名的索引覆盖了选定的列，因此虽然不用于确定要检索的行，但索引扫描比数据行扫描更有效。

对于 InnoDB，即使查询还选择了主键，因为 InnoDB 将主键值存储在每个二级索引中，二级索引也可以覆盖选定的列。如果 `key` 为 `NULL`，则 MySQL 没有找到更高效地执行查询的索引。

要强制 MySQL 使用或忽略 `possible_keys