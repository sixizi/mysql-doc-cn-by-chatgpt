## 10.12.3.1 MySQL 如何使用内存

MySQL 分配缓冲区和缓存以提高数据库操作的性能。默认配置设计允许 MySQL 服务器在大约 512MB 内存的虚拟机上启动。你可以通过增加某些缓存和缓冲区相关系统变量的值来提高 MySQL 的性能。你还可以修改默认配置以在内存有限的系统上运行 MySQL。

以下列表描述了 MySQL 使用内存的一些方式。相关系统变量在适用时被引用。某些项目是特定于存储引擎或功能的。

- InnoDB 缓冲池是一个内存区域，用于缓存 InnoDB 表的数据、索引和其他辅助缓冲区。为了提高大容量读取操作的效率，缓冲池被划分为可以包含多个行的页面。为了提高缓存管理效率，缓冲池实现为页面的链表；使用一种 LRU 算法的变体，将很少使用的数据从缓存中淘汰。有关详细信息，请参阅[第 17.5.1 节 “缓冲池”](#17.5.1-缓冲池)。

- 缓冲池的大小对于系统性能很重要：
  - InnoDB 在服务器启动时通过 `malloc()` 操作分配整个缓冲池的内存。`innodb_buffer_pool_size` 系统变量定义缓冲池的大小。通常，推荐的 `innodb_buffer_pool_size` 值为系统内存的 50% 到 75%。`innodb_buffer_pool_size` 可以在服务器运行时动态配置。有关详细信息，请参阅[第 17.8.3.1 节 “配置 InnoDB 缓冲池大小”](#17.8.3.1-配置-InnoDB-缓冲池大小)。
  - 在拥有大量内存的系统上，可以通过将缓冲池划分为多个缓冲池实例来提高并发性。`innodb_buffer_pool_instances` 系统变量定义缓冲池实例的数量。
  - 缓冲池过小可能会导致页面频繁刷新，使得刚被刷新出去的数据很快又需要再次加载。
  - 缓冲池过大可能会因为内存竞争而导致交换。

- 存储引擎接口使优化器能够提供有关用于扫描的记录缓冲区大小的信息，优化器估计这些扫描可能会读取多行。缓冲区大小可以根据估计值的大小而变化。InnoDB 使用这种可变大小的缓冲能力来利用行预取，并减少锁定和 B 树导航的开销。

- 所有线程共享 MyISAM 键缓冲区。`key_buffer_size` 系统变量决定其大小。

- 对于服务器打开的每个 MyISAM 表，索引文件只打开一次；数据文件则为每个并发运行的访问该表的线程打开一次。对于每个并发线程，分配一个表结构、每个列的列结构以及大小为 3 * N 的缓冲区（其中 N 是最大行长度，不包括 BLOB 列）。BLOB 列需要五到八个字节加上 BLOB 数据的长度。MyISAM 存储引擎维护一个额外的行缓冲区供内部使用。

- `myisam_use_mmap` 系统变量可以设置为 1，以启用所有 MyISAM 表的内存映射。

- 如果内部内存临时表变得太大（根据 `tmp_table_size` 和 `max_heap_table_size` 系统变量确定），MySQL 会自动将表从内存格式转换为磁盘格式。从 MySQL 8.0.16 开始，磁盘上的临时表总是使用 InnoDB 存储引擎。（以前，用于此目的的存储引擎由 `internal_tmp_disk_storage_engine` 系统变量决定，该变量不再支持。）你可以增加允许的临时表大小，如[第 10.4.4 节 “MySQL 中的内部临时表使用”](#10.4.4-MySQL-中的内部临时表使用)中所述。

- 对于用 `CREATE TABLE` 显式创建的 MEMORY 表，只有 `max_heap_table_size` 系统变量决定表的最大增长大小，并且不会转换为磁盘格式。

- MySQL Performance Schema 是一个用于低级别监控 MySQL 服务器执行情况的功能。Performance Schema 动态增量分配内存，根据实际服务器负载调整内存使用，而不是在服务器启动期间分配所需内存。一旦分配了内存，直到服务器重启之前不会释放。有关详细信息，请参阅[第 29.17 节 “Performance Schema 内存分配模型”](#29.17-Performance-Schema-内存分配模型)。

- 服务器用于管理客户端连接的每个线程需要一些特定于线程的空间。以下列表指示了这些空间以及哪些系统变量控制它们的大小：
  - 一个栈（`thread_stack`）
  - 一个连接缓冲区（`net_buffer_length`）
  - 一个结果缓冲区（`net_buffer_length`）

  连接缓冲区和结果缓冲区的初始大小均为 `net_buffer_length` 字节，但根据需要动态扩大到 `max_allowed_packet` 字节。结果缓冲区在每个 SQL 语句执行后收缩到 `net_buffer_length` 字节。当语句正在运行时，还会分配当前语句字符串的副本。

- 每个连接线程使用内存来计算语句摘要。服务器为每个会话分配 `max_digest_length` 字节。参见[第 29.10 节 “Performance Schema 语句摘要和采样”](#29.10-Performance-Schema-语句摘要和采样)。

- 所有线程共享相同的基本内存。

- 当不再需要某个线程时，分配给它的内存将被释放并返回系统，除非该线程返回线程缓存。在这种情况下，内存仍然保持分配状态。

- 执行对表的顺序扫描的每个请求分配一个读取缓冲区。`read_buffer_size` 系统变量决定缓冲区大小。

- 以任意顺序读取行时（例如，排序后），可能会分配一个随机读取缓冲区以避免磁盘寻道。`read_rnd_buffer_size` 系统变量决定缓冲区大小。

- 所有连接都在单次通过中执行，并且大多数连接可以在不使用临时表的情况下完成。大多数临时表是基于内存的哈希表。具有较大行长度（计算为所有列长度的总和）或包含 BLOB 列的临时表存储在磁盘上。

- 执行排序的多数请求分配一个排序缓冲区和零到两个临时文件，具体取决于结果集大小。参见[第 B.3.3.5 节 “MySQL 存储临时文件的位置”](#B.3.3.5-MySQL-存储临时文件的位置)。

- 几乎所有解析和计算都在线程本地和可重用的内存池中进行。小项目不需要内存开销，从而避免了通常缓慢的内存分配和释放。仅为意外的大字符串分配内存。

- 对于每个包含 BLOB 列的表，缓冲区动态扩展以读取较大的 BLOB 值。如果扫描表，缓冲区会增长到最大 BLOB 值的大小。

- MySQL 需要内存和描述符用于表缓存。所有正在使用的表的处理结构都保存在表缓存中，并按“先进先出”（FIFO）方式管理。`table_open_cache` 系统变量定义初始表缓存大小；参见[第 10.4.3.1 节 “MySQL 如何打开和关闭表”](#10.4.3.1-MySQL-如何打开和关闭表)。

- MySQL 还需要内存用于表定义缓存。`table_definition_cache` 系统变量定义可以存储在表定义缓存中的表定义数量。如果你使用大量表，可以创建一个大的表定义缓存以加快表的打开速度。与表缓存不同，表定义缓存占用的空间较少，不使用文件描述符。

- `FLUSH TABLES` 语句或 `mysqladmin flush-tables` 命令一次关闭所有未使用的表，并标记所有正在使用的表，以便在当前执行的线程完成时关闭。这有效地释放了大部分正在使用的内存。`FLUSH TABLES` 不会返回，直到所有表都关闭为止。

- 由于 `GRANT`、`CREATE USER`、`CREATE SERVER` 和 `INSTALL PLUGIN` 语句，服务器会将信息缓存到内存中。这些内存不会被相应的 `REVOKE`、`DROP USER`、`DROP SERVER` 和 `UNINSTALL PLUGIN` 语句释放，因此对于执行许多会导致缓存的语句的服务器，除非使用 `FLUSH PRIVILEGES` 释放，否则缓存内存使用量会增加。

- 在复制拓扑中，以下设置会