## 10.3.14 从 TIMESTAMP 列进行索引查找

时间值存储在 `TIMESTAMP` 列中作为 UTC 值，并且插入和从 `TIMESTAMP` 列检索的值在会话时区和 UTC 之间转换。（这与 `CONVERT_TZ()` 函数执行的转换类型相同。如果会话时区是 UTC，则实际上没有时区转换。）

由于本地时区变化（例如夏令时）的惯例，UTC 和非 UTC 时区之间的转换在两个方向上都不是一对一的。在 UTC 中不同的值在另一个时区中可能不不同。以下示例显示了在非 UTC 时区变得相同的不同 UTC 值：

```sql
mysql> CREATE TABLE tstable (ts TIMESTAMP);
mysql> SET time_zone = 'UTC'; -- 插入 UTC 值
mysql> INSERT INTO tstable VALUES
       ('2018-10-28 00:30:00'),
       ('2018-10-28 01:30:00');
mysql> SELECT ts FROM tstable;
+---------------------+
| ts                  |
+---------------------+
| 2018-10-28 00:30:00 |
| 2018-10-28 01:30:00 |
+---------------------+
mysql> SET time_zone = 'MET'; -- 检索非 UTC 值
mysql> SELECT ts FROM tstable;
+---------------------+
| ts                  |
+---------------------+
| 2018-10-28 02:30:00 |
| 2018-10-28 02:30:00 |
+---------------------+
```

> 注意：要使用命名时区（如 'MET' 或 'Europe/Amsterdam'），必须正确设置时区表。有关说明，请参见[第 7.1.15 节，“MySQL 服务器时区支持”](https://dev.mysql.com/doc/refman/8.0/en/time-zone-support.html)。

可以看到，当转换为 'MET' 时区时，这两个不同的 UTC 值是相同的。这种现象可能会导致给定 `TIMESTAMP` 列查询的不同结果，具体取决于优化器是否使用索引执行查询。

假设查询使用 `WHERE` 子句从前面显示的表中选择值，以在 `ts` 列中搜索单个特定值，例如用户提供的时间戳字面量：

```sql
SELECT ts FROM tstable WHERE ts = 'literal';
```

进一步假设查询在以下条件下执行：

- 会话时区不是 UTC 并且有夏令时变化。例如：

  ```sql
  SET time_zone = 'MET';
  ```

- 存储在 `TIMESTAMP` 列中的唯一 UTC 值由于夏令时变化在会话时区中不是唯一的。（前面示例说明了这种情况如何发生。）

- 查询指定的搜索值在会话时区进入夏令时的小时内。

在这些条件下，`WHERE` 子句中的比较在非索引和索引查找中以不同方式发生，并导致不同的结果：

- 如果没有索引或优化器不能使用索引，比较发生在会话时区。优化器执行表扫描，检索每个 `ts` 列值，将其从 UTC 转换为会话时区，并将其与搜索值（也在会话时区中解释）进行比较：

  ```sql
  mysql> SELECT ts FROM tstable
         WHERE ts = '2018-10-28 02:30:00';
  +---------------------+
  | ts                  |
  +---------------------+
  | 2018-10-28 02:30:00 |
  | 2018-10-28 02:30:00 |
  +---------------------+
  ```

  因为存储的 `ts` 值被转换为会话时区，所以查询可能返回在 UTC 值中不同但在会话时区中相等的两个时间戳值：一个在夏令时变化前发生，另一个在夏令时变化后发生。

- 如果有可用索引，比较发生在 UTC。优化器执行索引扫描，首先将搜索值从会话时区转换为 UTC，然后将结果与 UTC 索引条目进行比较：

  ```sql
  mysql> ALTER TABLE tstable ADD INDEX (ts);
  mysql> SELECT ts FROM tstable
         WHERE ts = '2018-10-28 02:30:00';
  +---------------------+
  | ts                  |
  +---------------------+
  | 2018-10-28 02:30:00 |
  +---------------------+
  ```

  在这种情况下，（转换后的）搜索值仅与索引条目匹配，因为存储的唯一 UTC 值的索引条目也是唯一的，因此搜索值只能匹配其中一个。

由于非索引和索引查找的优化器操作不同，查询在每种情况下产生不同的结果。非索引查找的结果返回在会话时区中匹配的所有值。索引查找不能这样做：

- 它在存储引擎内执行，该引擎只知道 UTC 值。
- 对于映射到相同 UTC 值的两个不同会话时区值，索引查找仅匹配相应的 UTC 索引条目并返回单行。

在上述讨论中，存储在 `tstable` 中的数据集恰好由不同的 UTC 值组成。在这种情况下，所有形式的索引使用查询最多匹配一个索引条目。

如果索引不是唯一的，则表（和索引）可能存储给定 UTC 值的多个实例。例如，`ts` 列可能包含多个 `2018-10-28 00:30:00` 的实例。在这种情况下，索引使用查询将返回每个实例（在结果集中转换为 `2018-10-28 02:30:00` 的 `MET` 值）。依然如此，即索引使用查询将转换后的搜索值与 UTC 索引条目中的单个值匹配，而不是匹配转换为会话时区中的搜索值的多个 UTC 值。

如果重要的是返回会话时区中匹配的所有 `ts` 值，则解决方法是使用 `IGNORE INDEX` 提示来抑制索引的使用：

```sql
mysql> SELECT ts FROM tstable
       IGNORE INDEX (ts)
       WHERE ts = '2018-10-28 02:30:00';
+---------------------+
| ts                  |
+---------------------+
| 2018-10-28 02:30:00 |
| 2018-10-28 02:30:00 |
+---------------------+
```

在其他上下文中也会发生时区转换的这种一对一映射缺失的现象，例如使用 `FROM_UNIXTIME()` 和 `UNIX_TIMESTAMP()` 函数执行的转换。详见[第 14.7 节，“日期和时间函数”](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html)。