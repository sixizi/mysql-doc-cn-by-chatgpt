## 10.3.1 MySQL 如何使用索引

索引用于快速查找具有特定列值的行。如果没有索引，MySQL 必须从第一行开始，然后读取整个表以找到相关行。表越大，成本越高。如果表对相关列有索引，MySQL 可以快速确定在数据文件中间要查找的位置，而不必查看所有数据。这比顺序读取每一行快得多。

大多数 MySQL 索引（`PRIMARY KEY`、`UNIQUE`、`INDEX` 和 `FULLTEXT`）存储在 B 树中。例外情况：空间数据类型上的索引使用 R 树；`MEMORY` 表也支持哈希索引；`InnoDB` 使用倒排列表来进行 `FULLTEXT` 索引。

一般来说，索引用于以下操作中，关于哈希索引（在 `MEMORY` 表中使用）的特性将在 [第 10.3.9 节, “B-Tree 和 Hash 索引的比较”](#10.3.9-比较-b-tree-和-hash-索引) 中描述。

MySQL 使用索引进行以下操作：

- 快速找到匹配 `WHERE` 子句的行。

- 排除不需要考虑的行。如果在多个索引之间选择，MySQL 通常使用查找行数最少的索引（选择性最高的索引）。

- 如果表有多列索引，优化器可以使用索引的任何最左前缀来查找行。例如，如果您在 `(col1, col2, col3)` 上有一个三列索引，则您可以在 `(col1)`、`(col1, col2)` 和 `(col1, col2, col3)` 上进行索引搜索。更多信息请参见 [第 10.3.6 节, “多列索引”](#10.3.6-多列索引)。

- 在执行连接时，从其他表中检索行。如果列声明为相同类型和大小，MySQL 可以更有效地使用这些列上的索引。在这种情况下，如果声明为相同大小，`VARCHAR` 和 `CHAR` 被认为是相同的。例如，`VARCHAR(10)` 和 `CHAR(10)` 是相同大小，但 `VARCHAR(10)` 和 `CHAR(15)` 不是。

- 对于非二进制字符串列之间的比较，两列应使用相同的字符集。例如，将 `utf8mb4` 列与 `latin1` 列进行比较将排除使用索引的可能性。

- 不同列之间的比较（例如将字符串列与时间列或数值列进行比较）可能会阻止使用索引，如果值在没有转换的情况下无法直接比较。例如，在数值列中的值 `1` 可能与字符串列中的多个值相等，如 `'1'`、`' 1'`、`'00001'` 或 `'01.e1'`。这排除了对字符串列使用任何索引的可能性。

- 查找特定索引列 `key_col` 的 `MIN()` 或 `MAX()` 值。这通过预处理器进行优化，检查是否在索引中 `key_col` 之前的所有键部分上使用了 `WHERE key_part_N = constant`。在这种情况下，MySQL 为每个 `MIN()` 或 `MAX()` 表达式进行一次键查找，并将其替换为常量。如果所有表达式都替换为常量，查询会立即返回。例如：

  ```sql
  SELECT MIN(key_part2), MAX(key_part2)
  FROM tbl_name
  WHERE key_part1 = 10;
  ```

- 对表进行排序或分组，如果排序或分组是在可用索引的最左前缀上完成的（例如，`ORDER BY key_part1, key_part2`）。如果所有键部分后面都跟着 `DESC`，则按相反顺序读取键。（或者，如果索引是降序索引，则按正序读取键。）参见 [第 10.2.1.16 节, “ORDER BY 优化”](#10.2.1.16-order-by-优化)、[第 10.2.1.17 节, “GROUP BY 优化”](#10.2.1.17-group-by-优化) 和 [第 10.3.13 节, “降序索引”](#10.3.13-降序索引)。

- 在某些情况下，可以优化查询以在不查询数据行的情况下检索值。（提供查询所有必要结果的索引称为覆盖索引。）如果查询只使用某个索引中包含的列，则可以从索引树中检索选定的值，以提高速度：

  ```sql
  SELECT key_part3
  FROM tbl_name
  WHERE key_part1 = 1;
  ```

对于小表上的查询，或报告查询处理大多数或所有行的大表，索引不那么重要。当查询需要访问大多数行时，顺序读取比通过索引更快。顺序读取最小化磁盘寻道，即使查询不需要所有行。详见 [第 10.2.1.23 节, “避免全表扫描”](#10.2.1.23-避免全表扫描)。