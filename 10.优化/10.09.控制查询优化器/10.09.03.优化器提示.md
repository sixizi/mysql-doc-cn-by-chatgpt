### 10.9.3 优化器提示

一种控制优化器策略的方法是设置 `optimizer_switch` 系统变量（请参阅 10.9.2 节，“可切换的优化”）。对该变量的更改会影响所有后续查询的执行；要使一个查询与另一个查询不同，必须在每个查询之前更改 `optimizer_switch`。

另一种控制优化器的方法是使用优化器提示，可以在单个语句中指定优化器提示。由于优化器提示应用于每个语句，因此它们比使用 `optimizer_switch` 更能精细地控制语句执行计划。例如，您可以为语句中的一个表启用某个优化，而为另一个表禁用该优化。语句中的提示优先于 `optimizer_switch` 标志。

示例：

```sql
SELECT /*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY, f2_idx) */ f1
  FROM t3 WHERE f1 > 30 AND f1 < 33;
SELECT /*+ BKA(t1) NO_BKA(t2) */ * FROM t1 INNER JOIN t2 WHERE ...;
SELECT /*+ NO_ICP(t1, t2) */ * FROM t1 INNER JOIN t2 WHERE ...;
SELECT /*+ SEMIJOIN(FIRSTMATCH, LOOSESCAN) */ * FROM t1 ...;
EXPLAIN SELECT /*+ NO_ICP(t1) */ * FROM t1 WHERE ...;
SELECT /*+ MERGE(dt) */ * FROM (SELECT * FROM t1) AS dt;
INSERT /*+ SET_VAR(foreign_key_checks=OFF) */ INTO t2 VALUES(2);
```

这里描述的优化器提示不同于 10.9.4 节，“索引提示” 中描述的索引提示。优化器和索引提示可以分别或一起使用。

- [优化器提示概述](#优化器提示概述)
- [优化器提示语法](#优化器提示语法)
- [连接顺序优化器提示](#连接顺序优化器提示)
- [表级优化器提示](#表级优化器提示)
- [索引级优化器提示](#索引级优化器提示)
- [子查询优化器提示](#子查询优化器提示)
- [语句执行时间优化器提示](#语句执行时间优化器提示)
- [变量设置提示语法](#变量设置提示语法)
- [资源组提示语法](#资源组提示语法)
- [用于命名查询块的优化器提示](#用于命名查询块的优化器提示)

#### 优化器提示概述

优化器提示适用于不同的作用范围：

- **全局范围**：提示影响整个语句
- **查询块范围**：提示影响语句中的特定查询块
- **表级范围**：提示影响查询块中的特定表
- **索引级范围**：提示影响表中的特定索引

下表总结了可用的优化器提示、它们影响的优化器策略以及适用的范围。更多详细信息将在后文提供。

**表 10.2 优化器提示**

| 提示名称                                                     | 描述                                                         | 适用范围   |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---------- |
| `BKA`, `NO_BKA`                                              | 影响批量键访问（Batched Key Access）连接处理                 | 查询块，表 |
| `BNL`, `NO_BNL`                                              | MySQL 8.0.20 之前：影响块嵌套循环（Block Nested-Loop）连接处理；MySQL 8.0.18 及以后：也影响哈希连接优化；MySQL 8.0.20 及以后：仅影响哈希连接优化 | 查询块，表 |
| `DERIVED_CONDITION_PUSHDOWN`, `NO_DERIVED_CONDITION_PUSHDOWN` | 对物化派生表使用或忽略派生条件下推优化（MySQL 8.0.22 新增）  | 查询块，表 |
| `GROUP_INDEX`, `NO_GROUP_INDEX`                              | 在 `GROUP BY` 操作中使用或忽略指定的索引（MySQL 8.0.20 新增） | 索引       |
| `HASH_JOIN`, `NO_HASH_JOIN`                                  | 影响哈希连接优化（仅 MySQL 8.0.18）                          | 查询块，表 |
| `INDEX`, `NO_INDEX`                                          | 作为 `JOIN_INDEX`、`GROUP_INDEX` 和 `ORDER_INDEX` 的组合，或作为 `NO_JOIN_INDEX`、`NO_GROUP_INDEX` 和 `NO_ORDER_INDEX` 的组合（MySQL 8.0.20 新增） | 索引       |
| `INDEX_MERGE`, `NO_INDEX_MERGE`                              | 影响索引合并优化                                             | 表，索引   |
| `JOIN_FIXED_ORDER`                                           | 在连接顺序中使用 `FROM` 子句中指定的表顺序                   | 查询块     |
| `JOIN_INDEX`, `NO_JOIN_INDEX`                                | 使用或忽略指定的索引（MySQL 8.0.20 新增）                    | 索引       |
| `JOIN_ORDER`                                                 | 在连接顺序中使用提示中指定的表顺序                           | 查询块     |
| `JOIN_PREFIX`                                                | 在连接顺序的前几个表中使用提示中指定的表顺序                 | 查询块     |
| `JOIN_SUFFIX`                                                | 在连接顺序的最后几个表中使用提示中指定的表顺序               | 查询块     |
| `MAX_EXECUTION_TIME`                                         | 限制语句执行时间                                             | 全局       |
| `MERGE`, `NO_MERGE`                                          | 影响派生表/视图合并到外部查询块                              | 表         |
| `MRR`, `NO_MRR`                                              | 影响多范围读取（Multi-Range Read）优化                       | 表，索引   |
| `NO_ICP`                                                     | 影响索引条件下推优化                                         | 表，索引   |
| `NO_RANGE_OPTIMIZATION`                                      | 影响范围优化                                                 | 表，索引   |
| `ORDER_INDEX`, `NO_ORDER_INDEX`                              | 对行排序使用或忽略指定的索引（MySQL 8.0.20 新增）            | 索引       |
| `QB_NAME`                                                    | 为查询块分配名称                                             | 查询块     |
| `RESOURCE_GROUP`                                             | 在语句执行期间设置资源组                                     | 全局       |
| `SEMIJOIN`, `NO_SEMIJOIN`                                    | 影响半连接策略；从 MySQL 8.0.17 开始，也适用于反连接         | 查询块     |
| `SKIP_SCAN`, `NO_SKIP_SCAN`                                  | 影响跳过扫描优化                                             | 表，索引   |
| `SET_VAR`                                                    | 在语句执行期间设置变量                                       | 全局       |
| `SUBQUERY`                                                   | 影响物化、IN-to-EXISTS 子查询策略                            | 查询块     |

禁用优化会阻止优化器使用它。启用优化意味着优化器可以自由使用该策略（如果它适用于语句执行），而不是优化器必然使用它。

#### 优化器提示语法

MySQL 支持如11.7 节，“注释”中描述的在 SQL 语句中使用注释。优化器提示必须在 `/*+ ... */` 注释中指定。即，优化器提示使用 `/* ... */` C 风格注释语法的变体，注释开头的 `/*` 后面紧跟一个 `+` 字符。示例：

```sql
/*+ BKA(t1) */
/*+ BNL(t1, t2) */
/*+ NO_RANGE_OPTIMIZATION(t4 PRIMARY) */
/*+ QB_NAME(qb2) */
```

`+` 字符后允许有空格。

解析器在 `SELECT`、`UPDATE`、`INSERT`、`REPLACE` 和 `DELETE` 语句的初始关键字之后识别优化器提示注释。提示允许在以下上下文中使用：

- 在查询和数据更改语句的开头：

  ```sql
  SELECT /*+ ... */ ...
  INSERT /*+ ... */ ...
  REPLACE /*+ ... */ ...
  UPDATE /*+ ... */ ...
  DELETE /*+ ... */ ...
  ```

- 在查询块的开头：

  ```sql
  (SELECT /*+ ... */ ... )
  (SELECT ... ) UNION (SELECT /*+ ... */ ... )
  (SELECT /*+ ... */ ... ) UNION (SELECT /*+ ... */ ... )
  UPDATE ... WHERE x IN (SELECT /*+ ... */ ...)
  INSERT ... SELECT /*+ ... */ ...
  ```

- 在 EXPLAIN 前缀的可提示语句中。例如：

  ```sql
  EXPLAIN SELECT /*+ ... */ ...
  EXPLAIN UPDATE ... WHERE x IN (SELECT /*+ ... */ ...)
  ```

  这意味着可以使用 EXPLAIN 查看优化器提示如何影响执行计划。在 EXPLAIN 之后立即使用 `SHOW WARNINGS` 可以看到提示是如何使用的。紧随其后的 `SHOW WARNINGS` 显示的扩展 EXPLAIN 输出指示哪些提示被使用。被忽略的提示不会显示。

一个提示注释可以包含多个提示，但一个查询块不能包含多个提示注释。以下是有效的示例：

```sql
SELECT /*+ BNL(t1) BKA(t2) */ ...
```

但以下示例无效：

```sql
SELECT /*+ BNL(t1) */ /* BKA(t2) */ ...
```

当一个提示注释包含多个提示时，可能会存在重复和冲突。以下是适用的一般指导原则。对于特定提示类型，可能会有额外规则，如提示描述中所示。

- **重复提示**：对于类似 `/*+ MRR(idx1) MRR(idx1) */` 的提示，MySQL 使用第一个提示并发出关于重复提示的警告。
- **冲突提示**：对于类似 `/*+ MRR(idx1) NO_MRR(idx1) */` 的提示，MySQL 使用第一个提示并发出关于第二个冲突提示的警告。

查询块名称是标识符，并遵循关于名称有效性和如何引用它们的常规规则（参见[11.2 节，“模式对象名称”](#)）。

提示名称、查询块名称和策略名称不区分大小写。对表和索引名称的引用遵循通常的标识符大小写规则（参见11.2.3 节，“标识符大小写敏感性”）。

#### 连接顺序优化提示

连接顺序提示影响优化器连接表的顺序。

`JOIN_FIXED_ORDER` 提示的语法：

```sql
hint_name([@query_block_name])
```

其他连接顺序提示的语法：

```sql
hint_name([@query_block_name] tbl_name [, tbl_name] ...)
hint_name(tbl_name[@query_block_name] [, tbl_name[@query_block_name]] ...)
```

语法中的术语解释如下：

- **hint_name**: 允许的提示名称如下：
  - `JOIN_FIXED_ORDER`: 强制优化器按 `FROM` 子句中表的顺序进行连接。这相当于指定 `SELECT STRAIGHT_JOIN`。
  - `JOIN_ORDER`: 指示优化器按指定的表顺序进行连接。提示适用于命名的表。优化器可以将未命名的表放在连接顺序中的任何位置，包括在指定表之间。
  - `JOIN_PREFIX`: 指示优化器在连接执行计划的前几个表中使用指定的表顺序。提示适用于命名的表。优化器将所有其他表放在命名的表之后。
  - `JOIN_SUFFIX`: 指示优化器在连接执行计划的最后几个表中使用指定的表顺序。提示适用于命名的表。优化器将所有其他表放在命名的表之前。

- **tbl_name**: 语句中使用的表的名称。命名表的提示适用于它命名的所有表。`JOIN_FIXED_ORDER` 提示不命名表，适用于它出现的查询块的 `FROM` 子句中的所有表。

  如果一个表有别名，提示必须引用别名而不是表名。

  提示中的表名不能加上模式名称。

- **query_block_name**: 提示适用的查询块名称。如果提示中不包含前导的 `@query_block_name`，则提示适用于它出现的查询块。对于 `tbl_name@query_block_name` 语法，提示适用于命名查询块中的命名表。有关给查询块命名的信息，请参见“给查询块命名的优化器提示”一节。

示例：

```sql
SELECT
/*+ JOIN_PREFIX(t2, t5@subq2, t4@subq1)
    JOIN_ORDER(t4@subq1, t3)
    JOIN_SUFFIX(t1) */
COUNT(*) FROM t1 JOIN t2 JOIN t3
           WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4)
             AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5);
```

提示控制半连接表合并到外部查询块的行为。如果子查询 `subq1` 和 `subq2` 转换为半连接，表 `t4@subq1` 和 `t5@subq2` 合并到外部查询块。在这种情况下，外部查询块中指定的提示控制 `t4@subq1` 和 `t5@subq2` 表的行为。

优化器根据以下原则解析连接顺序提示：

- **多个提示实例**

  只应用一个 `JOIN_PREFIX` 和一个 `JOIN_SUFFIX` 提示。忽略同类的后续提示并发出警告。可以多次指定 `JOIN_ORDER`。

  示例：

  ```sql
  /*+ JOIN_PREFIX(t1) JOIN_PREFIX(t2) */
  ```

  第二个 `JOIN_PREFIX` 提示被忽略并发出警告。

  ```sql
  /*+ JOIN_PREFIX(t1) JOIN_SUFFIX(t2) */
  ```

  两个提示都适用。没有警告。

  ```sql
  /*+ JOIN_ORDER(t1, t2) JOIN_ORDER(t2, t3) */
  ```

  两个提示都适用。没有警告。

- **冲突提示**

  在某些情况下，提示可能会冲突，例如当 `JOIN_ORDER` 和 `JOIN_PREFIX` 的表顺序无法同时应用时：

  ```sql
  SELECT /*+ JOIN_ORDER(t1, t2) JOIN_PREFIX(t2, t1) */ ... FROM t1, t2;
  ```

  在这种情况下，应用第一个指定的提示，忽略后续冲突提示且不发出警告。无法应用的有效提示将被静默忽略且不发出警告。

- **被忽略的提示**

  如果提示中指定的表存在循环依赖，则忽略提示。

  示例：

  ```sql
  /*+ JOIN_ORDER(t1, t2) JOIN_PREFIX(t2, t1) */
  ```

  `JOIN_ORDER` 提示将表 `t2` 设为依赖于 `t1`。由于 `t1` 不能依赖于 `t2`，`JOIN_PREFIX` 提示被忽略。被忽略的提示不会显示在扩展的 `EXPLAIN` 输出中。

- **与 const 表的交互**

  MySQL 优化器将 `const` 表放在连接顺序的首位，`const` 表的位置不能被提示影响。提示中对 `const` 表的引用将被忽略，但提示仍适用。例如，这两者是等效的：

  ```sql
  JOIN_ORDER(t1, const_tbl, t2)
  JOIN_ORDER(t1, t2)
  ```

  接受的提示在扩展的 `EXPLAIN` 输出中显示为指定的 `const` 表。

- **与连接操作类型的交互**

  MySQL 支持几种类型的连接：`LEFT`、`RIGHT`、`INNER`、`CROSS`、`STRAIGHT_JOIN`。与指定的连接类型冲突的提示将被忽略且不发出警告。

  示例：

  ```sql
  SELECT /*+ JOIN_PREFIX(t1, t2) */FROM t2 LEFT JOIN t1;
  ```

  这里提示要求的连接顺序与 `LEFT JOIN` 要求的顺序冲突。提示将被忽略且不发出警告。

#### 表级优化器提示

表级提示影响以下内容：

- 块嵌套循环 (BNL) 和批量键访问 (BKA) 连接处理算法的使用（参见第 10.2.1.12 节《块嵌套循环和批量键访问连接》）。
- 是否将派生表、视图引用或公用表表达式合并到外部查询块中，或使用内部临时表进行物化。
- 派生表条件下推优化的使用（MySQL 8.0.22 中添加）。参见第 10.2.2.5 节《派生条件下推优化》。

这些提示类型适用于特定表或查询块中的所有表。

表级提示的语法：

```sql
hint_name([@query_block_name] [tbl_name [, tbl_name] ...])
hint_name([tbl_name@query_block_name [, tbl_name@query_block_name] ...])
```

语法中的术语解释如下：

- **hint_name**: 允许的提示名称如下：
  - `BKA`, `NO_BKA`: 启用或禁用指定表的批量键访问。
  
  - `BNL`, `NO_BNL`: 启用或禁用指定表的块嵌套循环。从 MySQL 8.0.18 开始，这些提示还启用和禁用哈希连接优化。
  
    > **注意**
    >
    > 块嵌套循环优化在 MySQL 8.0.20 及更高版本中被移除，但 `BNL` 和 `NO_BNL` 继续支持启用和禁用哈希连接。
  
  - `DERIVED_CONDITION_PUSHDOWN`, `NO_DERIVED_CONDITION_PUSHDOWN`: 启用或禁用指定表的派生表条件下推（MySQL 8.0.22 中添加）。详见第 10.2.2.5 节《派生条件下推优化》。
  
  - `HASH_JOIN`, `NO_HASH_JOIN`: 仅在 MySQL 8.0.18 中，启用或禁用指定表的哈希连接。这些提示在 MySQL 8.0.19 或更高版本中无效，应使用 `BNL` 或 `NO_BNL`。
  
  - `MERGE`, `NO_MERGE`: 启用指定表、视图引用或公用表表达式的合并；或禁用合并并改用物化。
  
    > **注意**
    >
    > 要使用块嵌套循环或批量键访问提示启用外连接的任何内部表的连接缓冲，必须为外连接的所有内部表启用连接缓冲。
  
- **tbl_name**: 语句中使用的表的名称。提示适用于它命名的所有表。如果提示不命名表，则适用于它出现的查询块中的所有表。

  如果一个表有别名，提示必须引用别名而不是表名。

  提示中的表名不能加上模式名称。

- **query_block_name**: 提示适用的查询块名称。如果提示中不包含前导的 `@query_block_name`，则提示适用于它出现的查询块。对于 `tbl_name@query_block_name` 语法，提示适用于命名查询块中的命名表。有关给查询块命名的信息，请参见《给查询块命名的优化器提示》。

示例：

```sql
SELECT /*+ NO_BKA(t1, t2) */ t1.* FROM t1 INNER JOIN t2 INNER JOIN t3;
SELECT /*+ NO_BNL() BKA(t1) */ t1.* FROM t1 INNER JOIN t2 INNER JOIN t3;
SELECT /*+ NO_MERGE(dt) */ * FROM (SELECT * FROM t1) AS dt;
```

表级提示适用于接收来自先前表的记录的表，而不是发送者表。考虑以下语句：

```sql
SELECT /*+ BNL(t2) */ FROM t1, t2;
```

如果优化器选择首先处理 `t1`，它会通过在开始读取 `t2` 之前缓冲 `t1` 的行来对 `t2` 应用块嵌套循环连接。如果优化器选择首先处理 `t2`，则提示无效，因为 `t2` 是发送者表。

对于 `MERGE` 和 `NO_MERGE` 提示，适用以下优先级规则：

- 提示优先于任何非技术约束的优化器启发式方法。（如果作为建议提供的提示无效，则优化器有理由忽略它。）
- 提示优先于 `optimizer_switch` 系统变量的 `derived_merge` 标志。
- 对于视图引用，视图定义中的 `ALGORITHM={MERGE|TEMPTABLE}` 子句优先于查询中指定的提示。

#### 索引级优化器提示

索引级提示影响优化器对特定表或索引使用的索引处理策略。这些提示类型影响索引条件下推 (ICP)、多范围读取 (MRR)、索引合并以及范围优化的使用（参见第 10.2.1 节《优化 SELECT 语句》）。

索引级提示的语法：

```sql
hint_name([@query_block_name] tbl_name [index_name [, index_name] ...])
hint_name(tbl_name@query_block_name [index_name [, index_name] ...])
```

语法中的术语解释如下：

- **hint_name**: 允许的提示名称如下：
  - `GROUP_INDEX`, `NO_GROUP_INDEX`: 启用或禁用指定索引用于 `GROUP BY` 操作的索引扫描。等效于 `FORCE INDEX FOR GROUP BY` 和 `IGNORE INDEX FOR GROUP BY` 提示。从 MySQL 8.0.20 开始可用。
  
  - `INDEX`, `NO_INDEX`: 作为 `JOIN_INDEX`、`GROUP_INDEX` 和 `ORDER_INDEX` 的组合，强制服务器使用指定的索引用于任何和所有范围，或作为 `NO_JOIN_INDEX`、`NO_GROUP_INDEX` 和 `NO_ORDER_INDEX` 的组合，使服务器忽略指定的索引用于任何和所有范围。等效于 `FORCE INDEX` 和 `IGNORE INDEX`。从 MySQL 8.0.20 开始可用。
  
  - `INDEX_MERGE`, `NO_INDEX_MERGE`: 启用或禁用指定表或索引的索引合并访问方法。有关此访问方法的信息，请参见第 10.2.1.3 节《索引合并优化》。这些提示适用于所有三种索引合并算法。
  
    `INDEX_MERGE` 提示强制优化器使用指定表的索引合并，并使用指定的一组索引。如果未指定索引，优化器会考虑所有可能的索引组合并选择成本最低的组合。如果索引组合不适用于给定的语句，则可能会忽略提示。
  
    `NO_INDEX_MERGE` 提示禁用涉及任何指定索引的索引合并组合。如果提示未指定索引，则不允许对表进行索引合并。
  
  - `JOIN_INDEX`, `NO_JOIN_INDEX`: 强制 MySQL 使用或忽略指定索引用于任何访问方法，例如 `ref`、`range`、`index_merge` 等。等效于 `FORCE INDEX FOR JOIN` 和 `IGNORE INDEX FOR JOIN`。从 MySQL 8.0.20 开始可用。
  
  - `MRR`, `NO_MRR`: 启用或禁用指定表或索引的 MRR。MRR 提示仅适用于 InnoDB 和 MyISAM 表。有关此访问方法的信息，请参见第 10.2.1.11 节《多范围读取优化》。
  
  - `NO_ICP`: 禁用指定表或索引的 ICP。默认情况下，ICP 是候选优化策略，因此没有启用它的提示。有关此访问方法的信息，请参见第 10.2.1.6 节《索引条件下推优化》。
  
  - `NO_RANGE_OPTIMIZATION`: 禁用指定表或索引的索引范围访问。此提示还禁用表或索引的索引合并和松散索引扫描。默认情况下，范围访问是候选优化策略，因此没有启用它的提示。
  
    当范围数量可能很大且范围优化需要大量资源时，此提示可能很有用。
  
  - `ORDER_INDEX`, `NO_ORDER_INDEX`: 使 MySQL 使用或忽略指定索引用于排序行。等效于 `FORCE INDEX FOR ORDER BY` 和 `IGNORE INDEX FOR ORDER BY`。从 MySQL 8.0.20 开始可用。
  
  - `SKIP_SCAN`, `NO_SKIP_SCAN`: 启用或禁用指定表或索引的跳跃扫描访问方法。有关此访问方法的信息，请参见跳跃扫描范围访问方法。从 MySQL 8.0.13 开始提供这些提示。
  
    `SKIP_SCAN` 提示强制优化器使用指定表的跳跃扫描，并使用指定的一组索引。如果未指定索引，优化器会考虑所有可能的索引并选择成本最低的索引。如果索引不适用于给定的语句，则可能会忽略提示。
  
    `NO_SKIP_SCAN` 提示禁用指定索引的跳跃扫描。如果提示未指定索引，则不允许对表进行跳跃扫描。
  
- **tbl_name**: 提示适用的表名称。

- **index_name**: 命名表中的索引名称。提示适用于它命名的所有索引。如果提示不命名索引，则适用于表中的所有索引。
  
  要引用主键，请使用名称 `PRIMARY`。要查看表的索引名称，请使用 `SHOW INDEX`。
  
- **query_block_name**: 提示适用的查询块名称。如果提示中不包含前导的 `@query_block_name`，则提示适用于它出现的查询块。对于 `tbl_name@query_block_name` 语法，提示适用于命名查询块中的命名表。有关给查询块命名的信息，请参见《给查询块命名的优化器提示》。

示例：

```sql
SELECT /*+ INDEX_MERGE(t1 f3, PRIMARY) */ f2 FROM t1
  WHERE f1 = 'o' AND f2 = f3 AND f3 <= 4;
SELECT /*+ MRR(t1) */ * FROM t1 WHERE f2 <= 3 AND 3 <= f3;
SELECT /*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY, f2_idx) */ f1
  FROM t3 WHERE f1 > 30 AND f1 < 33;
INSERT INTO t3(f1, f2, f3)
  (SELECT /*+ NO_ICP(t2) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
   WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1
   AND t1.f2 AND t2.f2 + 1 >= t1.f1 + 1);
SELECT /*+ SKIP_SCAN(t1 PRIMARY) */ f1, f2
  FROM t1 WHERE f2 > 40;
```

以下示例使用索引合并提示，但其他索引级提示遵循相同的原则，关于提示忽略和优化器提示相对于 `optimizer_switch` 系统变量或索引提示的优先级。

假设表 `t1` 有列 `a`、`b`、`c` 和 `d`，并且在 `a`、`b` 和 `c` 上存在名为 `i_a`、`i_b` 和 `i_c` 的索引：

```sql
SELECT /*+ INDEX_MERGE(t1 i_a, i_b, i_c)*/ * FROM t1
  WHERE a = 1 AND b = 2 AND c = 3 AND d = 4;
```

在这种情况下，索引合并用于 `(i_a, i_b, i_c)`。

```sql
SELECT /*+ INDEX_MERGE(t1 i_a, i_b, i_c)*/ * FROM t1
  WHERE b = 1 AND c = 2 AND d = 3;
```

在这种情况下，索引合并用于 `(i_b, i_c)`。

```sql
/*+ INDEX_MERGE(t1 i_a, i_b) NO_INDEX_MERGE(t1 i_b) */
```

`NO_INDEX_MERGE` 被忽略，因为对同一表存在前面的提示。

```sql
/*+ NO_INDEX_MERGE(t1 i_a, i_b) INDEX_MERGE(t1 i_b) */
```

`INDEX_MERGE` 被忽略，因为对同一表存在前面的提示。

对于 `INDEX_MERGE` 和 `NO_INDEX_MERGE` 优化器提示，适用以下优先级规则：

- 如果指定并适用优化器提示，则它优先于 `optimizer_switch` 系统变量的索引合并相关标志。

  ```sql
  SET optimizer_switch='index_merge_intersection=off';
  SELECT /*+ INDEX_MERGE(t1 i_b, i_c) */ * FROM t1
  WHERE b = 1 AND c = 2 AND d = 3;
  ```

  在这种情况下，提示优先于 `optimizer_switch`。索引合并用于 `(i_b, i_c)`。

  ```sql
  SET optimizer_switch='index_merge_intersection=on';
  SELECT /*+ INDEX_MERGE(t1 i_b) */ * FROM t1
  WHERE b = 1 AND c = 2 AND d = 3;
  ```

  提示仅指定一个索引，因此不适用，`optimizer_switch` 标志（开启）适用。如果优化器认为索引合并成本低，则使用索引合并。

  ```sql
  SET optimizer_switch='index_merge_intersection=off';
  SELECT /*+ INDEX_MERGE(t1 i_b) */ * FROM t1
  WHERE b = 1 AND c = 2 AND d = 3;
  ```

  提示仅指定一个索引，因此不适用，`optimizer_switch` 标志（关闭）适用。不使用索引合并。

- 索引级优化器提示 `GROUP_INDEX`、`INDEX`、`JOIN_INDEX` 和 `ORDER_INDEX` 都优先于等效的 `FORCE INDEX` 提示；即它们导致 `FORCE INDEX` 提示被忽略。同样，`NO_GROUP_INDEX`、`NO_INDEX`、`NO_JOIN_INDEX` 和 `NO_ORDER_INDEX` 提示都优先于任何 `IGNORE INDEX` 等效提示，也导致它们被忽略。

  索引级优化器提示 `GROUP_INDEX`、`NO_GROUP_INDEX`、`INDEX`、`NO_INDEX`、`JOIN_INDEX`、`NO_JOIN_INDEX`、`ORDER_INDEX` 和 `NO_ORDER_INDEX` 提示都优先于所有其他优化器提示，包括其他索引级优化器提示。其他优化器提示仅适用于这些提示允许的索引。

  `GROUP_INDEX`、`INDEX`、`JOIN_INDEX` 和 `ORDER_INDEX` 提示都等效于 `FORCE INDEX` 而不是 `USE INDEX`。这是因为使用这些提示之一意味着仅当没有办法使用命名索引之一查找表中的行时才使用表扫描。要使 MySQL 使用与给定 `USE INDEX` 实例相同的索引或索引集，可以使用 `NO_INDEX`、`NO_JOIN_INDEX`、`NO_GROUP_INDEX`、`NO_ORDER_INDEX` 或这些的某些组合。

  要复制 `USE INDEX` 在查询 `SELECT a,c FROM t1 USE INDEX FOR ORDER BY (i_a) ORDER BY a` 中的效果，可以使用 `NO_ORDER_INDEX` 优化器提示覆盖表上的所有索引，除了想要的那个，如下所示：

  ```sql
  SELECT /*+ NO_ORDER_INDEX(t1 i_b,i_c) */ a,c
      FROM t1
      ORDER BY a;
  ```

  尝试将表的 `NO_ORDER_INDEX` 与 `USE INDEX FOR ORDER BY` 结合使用不起作用，因为 `NO_ORDER_BY` 导致 `USE INDEX` 被忽略，如下所示：

  ```sql
  mysql> EXPLAIN SELECT /*+ NO_ORDER_INDEX(t1) */ a,c FROM t1
      ->     USE INDEX FOR ORDER BY (i_a) ORDER BY a\G
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: t1
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 256
       filtered: 100.00
          Extra: Using filesort
  ```

- `USE INDEX`、`FORCE INDEX` 和 `IGNORE INDEX` 索引提示优先于 `INDEX_MERGE` 和 `NO_INDEX_MERGE` 优化器提示。

  ```sql
  /*+ INDEX_MERGE(t1 i_a, i_b, i_c) */ ... IGNORE INDEX i_a
  ```

  `IGNORE INDEX` 优先于 `INDEX_MERGE`，因此索引 `i_a` 被排除在索引合并的可能范围之外。

  ```sql
  /*+ NO_INDEX_MERGE(t1 i_a, i_b) */ ... FORCE INDEX i_a, i_b
  ```

  由于 `FORCE INDEX` 的缘故，索引合并不允许用于 `i_a` 和 `i_b`，但优化器被强制使用 `i_a` 或 `i_b` 进行范围或 `ref` 访问。没有冲突；两个提示都适用。

- 如果 `IGNORE INDEX` 提示命名多个索引，则这些索引对于索引合并不可用。


- `FORCE INDEX` 和 `USE INDEX` 提示使只有命名索引可用于索引合并。

  ```sql
  SELECT /*+ INDEX_MERGE(t1 i_a, i_b, i_c) */ a FROM t1
  FORCE INDEX (i_a, i_b) WHERE c = 'h' AND a = 2 AND b = 'b';
  ```

  索引合并交叉访问算法用于 `(i_a, i_b)`。如果将 `FORCE INDEX` 更改为 `USE INDEX`，情况相同。