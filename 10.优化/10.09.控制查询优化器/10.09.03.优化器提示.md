### 10.9.3 优化器提示

一种控制优化器策略的方法是设置 `optimizer_switch` 系统变量（请参阅 10.9.2 节，“可切换的优化”）。对该变量的更改会影响所有后续查询的执行；要使一个查询与另一个查询不同，必须在每个查询之前更改 `optimizer_switch`。

另一种控制优化器的方法是使用优化器提示，可以在单个语句中指定优化器提示。由于优化器提示应用于每个语句，因此它们比使用 `optimizer_switch` 更能精细地控制语句执行计划。例如，您可以为语句中的一个表启用某个优化，而为另一个表禁用该优化。语句中的提示优先于 `optimizer_switch` 标志。

示例：

```sql
SELECT /*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY, f2_idx) */ f1
  FROM t3 WHERE f1 > 30 AND f1 < 33;
SELECT /*+ BKA(t1) NO_BKA(t2) */ * FROM t1 INNER JOIN t2 WHERE ...;
SELECT /*+ NO_ICP(t1, t2) */ * FROM t1 INNER JOIN t2 WHERE ...;
SELECT /*+ SEMIJOIN(FIRSTMATCH, LOOSESCAN) */ * FROM t1 ...;
EXPLAIN SELECT /*+ NO_ICP(t1) */ * FROM t1 WHERE ...;
SELECT /*+ MERGE(dt) */ * FROM (SELECT * FROM t1) AS dt;
INSERT /*+ SET_VAR(foreign_key_checks=OFF) */ INTO t2 VALUES(2);
```

这里描述的优化器提示不同于 10.9.4 节，“索引提示” 中描述的索引提示。优化器和索引提示可以分别或一起使用。

- [优化器提示概述](#优化器提示概述)
- [优化器提示语法](#优化器提示语法)
- [连接顺序优化器提示](#连接顺序优化器提示)
- [表级优化器提示](#表级优化器提示)
- [索引级优化器提示](#索引级优化器提示)
- [子查询优化器提示](#子查询优化器提示)
- [语句执行时间优化器提示](#语句执行时间优化器提示)
- [变量设置提示语法](#变量设置提示语法)
- [资源组提示语法](#资源组提示语法)
- [用于命名查询块的优化器提示](#用于命名查询块的优化器提示)

#### 优化器提示概述

优化器提示适用于不同的作用范围：

- **全局范围**：提示影响整个语句
- **查询块范围**：提示影响语句中的特定查询块
- **表级范围**：提示影响查询块中的特定表
- **索引级范围**：提示影响表中的特定索引

下表总结了可用的优化器提示、它们影响的优化器策略以及适用的范围。更多详细信息将在后文提供。

**表 10.2 优化器提示**

| 提示名称                                                     | 描述                                                         | 适用范围   |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---------- |
| `BKA`, `NO_BKA`                                              | 影响批量键访问（Batched Key Access）连接处理                 | 查询块，表 |
| `BNL`, `NO_BNL`                                              | MySQL 8.0.20 之前：影响块嵌套循环（Block Nested-Loop）连接处理；MySQL 8.0.18 及以后：也影响哈希连接优化；MySQL 8.0.20 及以后：仅影响哈希连接优化 | 查询块，表 |
| `DERIVED_CONDITION_PUSHDOWN`, `NO_DERIVED_CONDITION_PUSHDOWN` | 对物化派生表使用或忽略派生条件下推优化（MySQL 8.0.22 新增）  | 查询块，表 |
| `GROUP_INDEX`, `NO_GROUP_INDEX`                              | 在 `GROUP BY` 操作中使用或忽略指定的索引（MySQL 8.0.20 新增） | 索引       |
| `HASH_JOIN`, `NO_HASH_JOIN`                                  | 影响哈希连接优化（仅 MySQL 8.0.18）                          | 查询块，表 |
| `INDEX`, `NO_INDEX`                                          | 作为 `JOIN_INDEX`、`GROUP_INDEX` 和 `ORDER_INDEX` 的组合，或作为 `NO_JOIN_INDEX`、`NO_GROUP_INDEX` 和 `NO_ORDER_INDEX` 的组合（MySQL 8.0.20 新增） | 索引       |
| `INDEX_MERGE`, `NO_INDEX_MERGE`                              | 影响索引合并优化                                             | 表，索引   |
| `JOIN_FIXED_ORDER`                                           | 在连接顺序中使用 `FROM` 子句中指定的表顺序                   | 查询块     |
| `JOIN_INDEX`, `NO_JOIN_INDEX`                                | 使用或忽略指定的索引（MySQL 8.0.20 新增）                    | 索引       |
| `JOIN_ORDER`                                                 | 在连接顺序中使用提示中指定的表顺序                           | 查询块     |
| `JOIN_PREFIX`                                                | 在连接顺序的前几个表中使用提示中指定的表顺序                 | 查询块     |
| `JOIN_SUFFIX`                                                | 在连接顺序的最后几个表中使用提示中指定的表顺序               | 查询块     |
| `MAX_EXECUTION_TIME`                                         | 限制语句执行时间                                             | 全局       |
| `MERGE`, `NO_MERGE`                                          | 影响派生表/视图合并到外部查询块                              | 表         |
| `MRR`, `NO_MRR`                                              | 影响多范围读取（Multi-Range Read）优化                       | 表，索引   |
| `NO_ICP`                                                     | 影响索引条件下推优化                                         | 表，索引   |
| `NO_RANGE_OPTIMIZATION`                                      | 影响范围优化                                                 | 表，索引   |
| `ORDER_INDEX`, `NO_ORDER_INDEX`                              | 对行排序使用或忽略指定的索引（MySQL 8.0.20 新增）            | 索引       |
| `QB_NAME`                                                    | 为查询块分配名称                                             | 查询块     |
| `RESOURCE_GROUP`                                             | 在语句执行期间设置资源组                                     | 全局       |
| `SEMIJOIN`, `NO_SEMIJOIN`                                    | 影响半连接策略；从 MySQL 8.0.17 开始，也适用于反连接         | 查询块     |
| `SKIP_SCAN`, `NO_SKIP_SCAN`                                  | 影响跳过扫描优化                                             | 表，索引   |
| `SET_VAR`                                                    | 在语句执行期间设置变量                                       | 全局       |
| `SUBQUERY`                                                   | 影响物化、IN-to-EXISTS 子查询策略                            | 查询块     |

禁用优化会阻止优化器使用它。启用优化意味着优化器可以自由使用该策略（如果它适用于语句执行），而不是优化器必然使用它。

#### 优化器提示语法

MySQL 支持如11.7 节，“注释”中描述的在 SQL 语句中使用注释。优化器提示必须在 `/*+ ... */` 注释中指定。即，优化器提示使用 `/* ... */` C 风格注释语法的变体，注释开头的 `/*` 后面紧跟一个 `+` 字符。示例：

```sql
/*+ BKA(t1) */
/*+ BNL(t1, t2) */
/*+ NO_RANGE_OPTIMIZATION(t4 PRIMARY) */
/*+ QB_NAME(qb2) */
```

`+` 字符后允许有空格。

解析器在 `SELECT`、`UPDATE`、`INSERT`、`REPLACE` 和 `DELETE` 语句的初始关键字之后识别优化器提示注释。提示允许在以下上下文中使用：

- 在查询和数据更改语句的开头：

  ```sql
  SELECT /*+ ... */ ...
  INSERT /*+ ... */ ...
  REPLACE /*+ ... */ ...
  UPDATE /*+ ... */ ...
  DELETE /*+ ... */ ...
  ```

- 在查询块的开头：

  ```sql
  (SELECT /*+ ... */ ... )
  (SELECT ... ) UNION (SELECT /*+ ... */ ... )
  (SELECT /*+ ... */ ... ) UNION (SELECT /*+ ... */ ... )
  UPDATE ... WHERE x IN (SELECT /*+ ... */ ...)
  INSERT ... SELECT /*+ ... */ ...
  ```

- 在 EXPLAIN 前缀的可提示语句中。例如：

  ```sql
  EXPLAIN SELECT /*+ ... */ ...
  EXPLAIN UPDATE ... WHERE x IN (SELECT /*+ ... */ ...)
  ```

  这意味着可以使用 EXPLAIN 查看优化器提示如何影响执行计划。在 EXPLAIN 之后立即使用 `SHOW WARNINGS` 可以看到提示是如何使用的。紧随其后的 `SHOW WARNINGS` 显示的扩展 EXPLAIN 输出指示哪些提示被使用。被忽略的提示不会显示。

一个提示注释可以包含多个提示，但一个查询块不能包含多个提示注释。以下是有效的示例：

```sql
SELECT /*+ BNL(t1) BKA(t2) */ ...
```

但以下示例无效：

```sql
SELECT /*+ BNL(t1) */ /* BKA(t2) */ ...
```

当一个提示注释包含多个提示时，可能会存在重复和冲突。以下是适用的一般指导原则。对于特定提示类型，可能会有额外规则，如提示描述中所示。

- **重复提示**：对于类似 `/*+ MRR(idx1) MRR(idx1) */` 的提示，MySQL 使用第一个提示并发出关于重复提示的警告。
- **冲突提示**：对于类似 `/*+ MRR(idx1) NO_MRR(idx1) */` 的提示，MySQL 使用第一个提示并发出关于第二个冲突提示的警告。

查询块名称是标识符，并遵循关于名称有效性和如何引用它们的常规规则（参见[11.2 节，“模式对象名称”](#)）。

提示名称、查询块名称和策略名称不区分大小写。对表和索引名称的引用遵循通常的标识符大小写规则（参见11.2.3 节，“标识符大小写敏感性”）。

#### 连接顺序优化提示

连接顺序提示影响优化器连接表的顺序。

`JOIN_FIXED_ORDER` 提示的语法：

```sql
hint_name([@query_block_name])
```

其他连接顺序提示的语法：

```sql
hint_name([@query_block_name] tbl_name [, tbl_name] ...)
hint_name(tbl_name[@query_block_name] [, tbl_name[@query_block_name]] ...)
```

语法中的术语解释如下：

- **hint_name**: 允许的提示名称如下：
  - `JOIN_FIXED_ORDER`: 强制优化器按 `FROM` 子句中表的顺序进行连接。这相当于指定 `SELECT STRAIGHT_JOIN`。
  - `JOIN_ORDER`: 指示优化器按指定的表顺序进行连接。提示适用于命名的表。优化器可以将未命名的表放在连接顺序中的任何位置，包括在指定表之间。
  - `JOIN_PREFIX`: 指示优化器在连接执行计划的前几个表中使用指定的表顺序。提示适用于命名的表。优化器将所有其他表放在命名的表之后。
  - `JOIN_SUFFIX`: 指示优化器在连接执行计划的最后几个表中使用指定的表顺序。提示适用于命名的表。优化器将所有其他表放在命名的表之前。

- **tbl_name**: 语句中使用的表的名称。命名表的提示适用于它命名的所有表。`JOIN_FIXED_ORDER` 提示不命名表，适用于它出现的查询块的 `FROM` 子句中的所有表。

  如果一个表有别名，提示必须引用别名而不是表名。

  提示中的表名不能加上模式名称。

- **query_block_name**: 提示适用的查询块名称。如果提示中不包含前导的 `@query_block_name`，则提示适用于它出现的查询块。对于 `tbl_name@query_block_name` 语法，提示适用于命名查询块中的命名表。有关给查询块命名的信息，请参见“给查询块命名的优化器提示”一节。

示例：

```sql
SELECT
/*+ JOIN_PREFIX(t2, t5@subq2, t4@subq1)
    JOIN_ORDER(t4@subq1, t3)
    JOIN_SUFFIX(t1) */
COUNT(*) FROM t1 JOIN t2 JOIN t3
           WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4)
             AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5);
```

提示控制半连接表合并到外部查询块的行为。如果子查询 `subq1` 和 `subq2` 转换为半连接，表 `t4@subq1` 和 `t5@subq2` 合并到外部查询块。在这种情况下，外部查询块中指定的提示控制 `t4@subq1` 和 `t5@subq2` 表的行为。

优化器根据以下原则解析连接顺序提示：

- **多个提示实例**

  只应用一个 `JOIN_PREFIX` 和一个 `JOIN_SUFFIX` 提示。忽略同类的后续提示并发出警告。可以多次指定 `JOIN_ORDER`。

  示例：

  ```sql
  /*+ JOIN_PREFIX(t1) JOIN_PREFIX(t2) */
  ```

  第二个 `JOIN_PREFIX` 提示被忽略并发出警告。

  ```sql
  /*+ JOIN_PREFIX(t1) JOIN_SUFFIX(t2) */
  ```

  两个提示都适用。没有警告。

  ```sql
  /*+ JOIN_ORDER(t1, t2) JOIN_ORDER(t2, t3) */
  ```

  两个提示都适用。没有警告。

- **冲突提示**

  在某些情况下，提示可能会冲突，例如当 `JOIN_ORDER` 和 `JOIN_PREFIX` 的表顺序无法同时应用时：

  ```sql
  SELECT /*+ JOIN_ORDER(t1, t2) JOIN_PREFIX(t2, t1) */ ... FROM t1, t2;
  ```

  在这种情况下，应用第一个指定的提示，忽略后续冲突提示且不发出警告。无法应用的有效提示将被静默忽略且不发出警告。

- **被忽略的提示**

  如果提示中指定的表存在循环依赖，则忽略提示。

  示例：

  ```sql
  /*+ JOIN_ORDER(t1, t2) JOIN_PREFIX(t2, t1) */
  ```

  `JOIN_ORDER` 提示将表 `t2` 设为依赖于 `t1`。由于 `t1` 不能依赖于 `t2`，`JOIN_PREFIX` 提示被忽略。被忽略的提示不会显示在扩展的 `EXPLAIN` 输出中。

- **与 const 表的交互**

  MySQL 优化器将 `const` 表放在连接顺序的首位，`const` 表的位置不能被提示影响。提示中对 `const` 表的引用将被忽略，但提示仍适用。例如，这两者是等效的：

  ```sql
  JOIN_ORDER(t1, const_tbl, t2)
  JOIN_ORDER(t1, t2)
  ```

  接受的提示在扩展的 `EXPLAIN` 输出中显示为指定的 `const` 表。

- **与连接操作类型的交互**

  MySQL 支持几种类型的连接：`LEFT`、`RIGHT`、`INNER`、`CROSS`、`STRAIGHT_JOIN`。与指定的连接类型冲突的提示将被忽略且不发出警告。

  示例：

  ```sql
  SELECT /*+ JOIN_PREFIX(t1, t2) */FROM t2 LEFT JOIN t1;
  ```

  这里提示要求的连接顺序与 `LEFT JOIN` 要求的顺序冲突。提示将被忽略且不发出警告。