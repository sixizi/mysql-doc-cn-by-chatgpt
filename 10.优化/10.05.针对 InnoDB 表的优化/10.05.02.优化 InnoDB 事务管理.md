### 10.5.2 优化 InnoDB 事务管理

要优化 InnoDB 事务处理，需要在事务特性的性能开销和服务器的工作负载之间找到理想的平衡。例如，如果应用程序每秒提交数千次，会遇到性能问题，而如果每2-3小时才提交一次，也会遇到不同的性能问题。

- 默认的 MySQL 设置 `AUTOCOMMIT=1` 可能会对繁忙的数据库服务器产生性能限制。在可行的情况下，通过发出 `SET AUTOCOMMIT=0` 或 `START TRANSACTION` 语句，将几个相关的数据更改操作包装到一个事务中，并在进行所有更改后发出 `COMMIT` 语句。

  如果事务对数据库进行了修改，InnoDB 必须在每次事务提交时将日志刷新到磁盘。当每次更改后都跟随一个提交（如默认的自动提交设置），存储设备的 I/O 吞吐量限制了每秒可能的操作次数。

- 或者，对于仅包含单个 `SELECT` 语句的事务，启用 `AUTOCOMMIT` 有助于 InnoDB 识别只读事务并优化它们。请参见第 10.5.3 节，“`Optimizing InnoDB Read-Only Transactions`”了解相关要求。


- 避免在插入、更新或删除大量行后执行回滚。如果一个大事务正在减慢服务器性能，回滚它可能会使问题更糟，执行回滚可能需要的时间是原始数据更改操作的几倍。终止数据库进程无济于事，因为回滚会在服务器启动时重新开始。

  要最大限度地减少这种问题发生的可能性：

  - 增加缓冲池的大小，以便所有数据更改都可以被缓存，而不是立即写入磁盘。

  - 设置 `innodb_change_buffering=all`，以便插入、更新和删除操作都被缓冲。

  - 考虑在大型数据更改操作期间定期发出 `COMMIT` 语句，可能将单个删除或更新操作分成多个操作，针对较少的行进行操作。

  要摆脱已经发生的失控回滚，可以增加缓冲池，使回滚成为 CPU 绑定并快速运行，或者杀死服务器并使用 `innodb_force_recovery=3` 重启，如第 17.18.2 节，“`InnoDB Recovery`”所述。

  使用默认设置 `innodb_change_buffering=all`，预计这种问题发生的频率很低，因为此设置允许在内存中缓存更新和删除操作，使它们的执行速度更快，如果需要回滚也更快。确保在处理包含大量插入、更新或删除操作的长时间运行事务的服务器上使用此参数设置。

- 如果您能承受在意外退出时丢失一些最新提交的事务，可以将 `innodb_flush_log_at_trx_commit` 参数设置为 `0`。InnoDB 会尝试每秒钟刷新一次日志，尽管此刷新不保证执行。


- 当行被修改或删除时，这些行及其相关的撤销日志不会立即物理删除，甚至在事务提交后也不会立即删除。旧数据会被保留，直到先前或并发启动的事务完成，以便这些事务可以访问已修改或删除行的先前状态。因此，长时间运行的事务可以阻止 InnoDB 清除由不同事务更改的数据。


- 当长时间运行的事务修改或删除行时，使用 `READ COMMITTED` 和 `REPEATABLE READ` 隔离级别的其他事务在读取这些行时需要做更多的工作来重构旧数据。


- 当长时间运行的事务修改表时，其他事务对该表的查询无法利用覆盖索引技术。通常可以从二级索引中检索所有结果列的查询，改为从表数据中查找适当的值。

  如果发现二级索引页有一个 `PAGE_MAX_TRX_622424198204195214` 太新，或二级索引中的记录被删除标记，InnoDB 可能需要使用聚簇索引查找记录。