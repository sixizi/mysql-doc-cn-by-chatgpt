### 10.5.1 优化 InnoDB 表的存储布局

- 当数据达到稳定大小，或表的增长达到几十或几百兆字节时，考虑使用 `OPTIMIZE TABLE` 语句来重新组织表并压缩任何浪费的空间。重新组织的表在执行全表扫描时需要较少的磁盘 I/O。这是一种简单直接的技术，当其他技术（如改进索引使用或调优应用程序代码）不可行时，可以提高性能。

- `OPTIMIZE TABLE` 复制表的数据部分并重建索引。其好处在于提高数据在索引中的打包效率，并减少表空间和磁盘上的碎片。收益取决于每个表中的数据，某些表可能会有显著的收益，而其他表则可能没有，或者收益会随着时间的推移减少，直到下次优化该表。如果表很大或重建的索引不适合缓冲池，此操作可能会很慢。添加大量数据后首次运行通常比之后的运行要慢得多。

- 在 InnoDB 中，长 `PRIMARY KEY`（无论是单列包含较长值，还是几列形成的长复合值）会浪费大量磁盘空间。指向同一行的所有二级索引记录中都会重复主键值。（参见第 17.6.2.1 节，“`Clustered and Secondary Indexes`”。）如果主键较长，创建一个 `AUTO_INCREMENT` 列作为主键，或索引长 `VARCHAR` 列的前缀而不是整个列。

- 使用 `VARCHAR` 数据类型而不是 `CHAR` 来存储可变长度的字符串或包含许多 `NULL` 值的列。`CHAR(N)` 列总是需要 N 个字符来存储数据，即使字符串较短或其值为 `NULL`。较小的表更适合缓冲池并减少磁盘 I/O。

- 使用 `COMPACT` 行格式（默认的 InnoDB 格式）和可变长度字符集（如 `utf8mb4` 或 `sjis`）时，`CHAR(N)` 列占用可变数量的空间，但仍至少占用 N 字节。

- 对于大表或包含大量重复文本或数字数据的表，考虑使用 `COMPRESSED` 行格式。这样将数据带入缓冲池或执行全表扫描所需的磁盘 I/O 更少。在做出永久决定之前，使用 `COMPRESSED` 与 `COMPACT` 行格式进行比较，测量可以实现的压缩量。