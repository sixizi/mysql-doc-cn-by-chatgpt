### 10.6.1 优化 MyISAM 查询

一些加速 MyISAM 表查询的一般提示：

- **使用 `ANALYZE TABLE` 或运行 `myisamchk --analyze`**：在表加载数据后运行这些命令，可以帮助 MySQL 更好地优化查询。这会更新每个索引部分的值，指示具有相同值的平均行数。（对于唯一索引，这始终为 1。）MySQL 使用这些值来决定在基于非常量表达式联接两个表时选择哪个索引。您可以使用 `SHOW INDEX FROM tbl_name` 并检查基数值来检查表分析的结果。`myisamchk --description --verbose` 显示索引分布信息。

- **对索引和数据进行排序**：使用 `myisamchk --sort-index --sort-records=1`（假设要按索引 1 排序）。如果有一个唯一索引并希望按索引顺序读取所有行，这是一种加快查询速度的好方法。首次以这种方式对大表进行排序可能会花费很长时间。

- **避免对频繁更新的 MyISAM 表进行复杂的 SELECT 查询**：以避免由于读写争用导致的表锁定问题。

- **支持并发插入**：如果表的数据文件中间没有空闲块，您可以在其他线程读取表的同时向表中插入新行。如果需要这样做，请考虑使用避免删除行的方式使用表。另一种可能性是在删除大量行后运行 `OPTIMIZE TABLE` 以整理表。可以通过设置 `concurrent_insert` 变量来改变此行为。即使在有已删除行的表中，也可以强制新行追加（从而允许并发插入）。详见第 10.11.3 节，“`并发插入`”。

- **避免使用可变长度列**：对于经常变化的 MyISAM 表，避免使用可变长度列（`VARCHAR`、`BLOB` 和 `TEXT`）。如果表包含一个可变长度列，则使用动态行格式。详见第 18 章，“`替代存储引擎`”。

- **不要仅因为行变大而拆分表**：访问行时，最大的性能影响是找到行的第一个字节所需的磁盘查找。在找到数据后，大多数现代磁盘可以快速读取整个行以满足大多数应用需求。只有在以下情况下，拆分表才有显著差异：如果是使用动态行格式的 MyISAM 表，可以更改为固定行大小；或者如果经常需要扫描表但不需要大多数列。详见第 18 章，“`替代存储引擎`”。

- **使用 `ALTER TABLE ... ORDER BY expr1, expr2, ...`**：如果通常按 `expr1, expr2, ...` 顺序检索行，使用此选项在对表进行大量更改后，可以获得更高的性能。

- **引入新表进行实时计数更新**：如果经常需要根据大量行的信息计算结果（例如计数），可以引入新表并实时更新计数。以下形式的更新非常快：

  ```sql
  UPDATE tbl_name SET count_col=count_col+1 WHERE key_col=constant;
  ```

  当使用如 MyISAM 这样仅具有表级锁定（多读单写）的存储引擎时，这一点非常重要。这种方法也适用于大多数数据库系统，因为行锁管理器在这种情况下的工作量较小。

- **定期使用 `OPTIMIZE TABLE` 避免动态格式 MyISAM 表的碎片**：详见第 18.2.3 节，“`MyISAM 表存储格式`”。

- **声明 MyISAM 表使用 `DELAY_KEY_WRITE=1` 表选项**：这使得索引更新更快，因为它们不会在表关闭之前刷新到磁盘。缺点是，如果在这种表打开时服务器被终止，必须通过设置 `myisam_recover_options` 系统变量运行服务器，或者在重新启动服务器之前运行 `myisamchk` 来确保表正常。（但是，即使在这种情况下，使用 `DELAY_KEY_WRITE` 也不会丢失任何内容，因为可以从数据行生成键信息。）

- **MyISAM 索引中的字符串自动进行前缀和结尾空格压缩**：详见第 15.1.15 节，“`CREATE INDEX 语句`”。

- **通过缓存查询或答案增加性能**：然后一起执行多个插入或更新。在此操作期间锁定表可确保在所有更新之后仅刷新一次索引缓存。