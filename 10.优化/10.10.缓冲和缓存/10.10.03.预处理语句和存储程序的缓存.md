### 10.10.3 缓存预处理语句和存储程序

对于客户端在会话期间可能多次执行的某些语句，服务器将其转换为内部结构并缓存该结构以便执行时使用。缓存使服务器可以更高效地执行，因为它避免了在会话期间再次需要时重新转换语句的开销。转换和缓存适用于以下语句：

- 预处理语句，包括在 SQL 级别处理的语句（使用 `PREPARE` 语句）和使用二进制客户端/服务器协议处理的语句（使用 `mysql_stmt_prepare()` C API 函数）。`max_prepared_stmt_count` 系统变量控制服务器缓存的语句总数（所有会话中的预处理语句数量总和）。

- 存储程序（存储过程和函数、触发器和事件）。在这种情况下，服务器转换并缓存整个程序体。`stored_program_cache` 系统变量指示服务器每个会话缓存的存储程序的大致数量。

服务器为每个会话维护预处理语句和存储程序的缓存。为一个会话缓存的语句对其他会话不可见。当会话结束时，服务器会丢弃为其缓存的任何语句。

当服务器使用缓存的内部语句结构时，必须注意结构不应过时。对象的元数据可能会发生更改，从而导致当前对象定义与内部语句结构中的定义不匹配。元数据更改发生在 DDL 语句（例如创建、删除、修改、重命名或截断表，或者分析、优化或修复表）时。表内容更改（例如使用 `INSERT` 或 `UPDATE`）不会更改元数据，`SELECT` 语句也不会。

以下是一个问题的示例。假设客户端准备了如下语句：

```sql
PREPARE s1 FROM 'SELECT * FROM t1';
```

在内部结构中，`SELECT *` 扩展为表中的列列表。如果通过 `ALTER TABLE` 修改了表中的列集合，预处理语句将变得过时。如果服务器在客户端下次执行 `s1` 时未检测到此更改，则预处理语句会返回错误的结果。

为了避免预处理语句引用的表或视图的元数据更改引起的问题，服务器会检测这些更改并在下次执行时自动重新准备语句。也就是说，服务器会重新解析语句并重建内部结构。当引用的表或视图从表定义缓存中被清除（无论是为了给缓存中的新条目腾出空间还是通过 `FLUSH TABLES` 显式清除）后，服务器也会重新解析语句。

类似地，如果存储程序中使用的对象发生更改，服务器会重新解析程序中受影响的语句。

服务器还会检测表达式中对象的元数据更改。这些可能用于特定于存储程序的语句中，如 `DECLARE CURSOR` 或流程控制语句如 `IF`、`CASE` 和 `RETURN`。

为了避免重新解析整个存储程序，服务器仅在需要时重新解析程序中受影响的语句或表达式。例如：

假设表或视图的元数据发生更改。程序中访问该表或视图的 `SELECT *` 会被重新解析，但不访问该表或视图的 `SELECT *` 则不会重新解析。

当语句受到影响时，服务器尽可能部分重新解析。例如，考虑如下 `CASE` 语句：

```sql
CASE case_expr
  WHEN when_expr1 ...
  WHEN when_expr2 ...
  WHEN when_expr3 ...
  ...
END CASE
```

如果元数据更改仅影响 `WHEN when_expr3`，则仅重新解析该表达式。`case_expr` 和其他 `WHEN` 表达式不重新解析。

重新解析使用原始转换为内部形式时生效的默认数据库和 SQL 模式。

服务器最多尝试重新解析三次。如果所有尝试都失败，则会发生错误。

重新解析是自动进行的，但重新解析的频率越高，预处理语句和存储程序的性能就越低。

对于预处理语句，`Com_stmt_reprepare` 状态变量跟踪重新准备的次数。