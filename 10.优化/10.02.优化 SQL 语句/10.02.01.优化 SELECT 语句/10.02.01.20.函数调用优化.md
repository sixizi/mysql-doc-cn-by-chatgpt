#### 10.2.1.20 函数调用优化

MySQL内部将函数标记为确定性（deterministic）或非确定性（nondeterministic）。如果给定固定值的参数，函数可以在不同调用中返回不同结果，则该函数为非确定性函数。非确定性函数的例子包括：RAND()、UUID()。

如果函数被标记为非确定性，在`WHERE`子句中对它的引用需要在每一行（当从一个表选择时）或每种行的组合（当从多表连接选择时）上评估。

MySQL还根据参数的类型来决定何时评估函数，无论参数是表列还是常量值。需要每当该列值发生变化时就评估以表列作为参数的确定性函数。

非确定性函数可能影响查询性能。例如，某些优化可能无法使用，或者可能需要更多的锁定。下面的讨论使用`RAND()`，但也适用于其他非确定性函数。

假设有一个表t定义如下：

```sql
CREATE TABLE t (id INT NOT NULL PRIMARY KEY, col_a VARCHAR(100));
```

考虑以下两个查询：

```sql
SELECT * FROM t WHERE id = POW(1,2);
SELECT * FROM t WHERE id = FLOOR(1 + RAND() * 49);
```

这两个查询看起来都是因为与主键的等值比较而使用主键查找，但实际上只有第一个查询是这样：

- 第一个查询总是产生最多一行，因为带有常数参数的POW()是一个常数值，并用于索引查找。

- 第二个查询包含一个使用非确定性函数RAND()的表达式，该函数在查询中不是常数，实际上对表t的每一行都有一个新值。因此，该查询读取表的每一行，评估每一行的谓词，并输出主键匹配随机值的所有行。这可能是零行、一行或多行，这取决于id列的值和RAND()序列中的值。


非确定性的影响不限于`SELECT`语句。这个`UPDATE`语句使用非确定性函数来选择要修改的行：

```sql
UPDATE t SET col_a = some_expr WHERE id = FLOOR(1 + RAND() * 49);
```

这里的意图可能是更新至多一行，其中主键匹配表达式。然而，它可能更新零行、一行或多行，这取决于id列的值和`RAND()`序列中的值。

刚才描述的行为对性能和复制有以下含义：

- 由于非确定性函数不产生常数值，优化器不能使用可能适用的策略，如索引查找。结果可能是全表扫描。
- InnoDB可能会升级为范围键锁，而不是为一个匹配的行取单个行锁。
- 不确定性执行的更新对于复制是不安全的。

这些困难源于`RAND()`函数在表的每一行上都进行一次评估。为了避免多次函数评估，可以使用以下技术之一：

将包含非确定性函数的表达式移到一个单独的语句中，将值保存在一个变量中。在原始语句中，用变量的引用替换表达式，优化器可以将其视为常数值：

```sql
SET @keyval = FLOOR(1 + RAND() * 49);
UPDATE t SET col_a = some_expr WHERE id = @keyval;
```

在派生表中为随机值分配一个变量。这种技术使变量在用于WHERE子句中的比较之前被赋值一次：

```sql
UPDATE /*+ NO_MERGE(dt) */ t, (SELECT FLOOR(1 + RAND() * 49) AS r) AS dt
SET col_a = some_expr WHERE id = dt.r;
```

如前所述，`WHERE`子句中的非确定性表达式可能会阻止优化并导致全表扫描。然而，如果其他表达式是确定性的，可能部分优化`WHERE`子句。例如：

```sql
SELECT * FROM t WHERE partial_key=5 AND some_column=RAND();
```

如果优化器可以使用`partial_key`减少选择的行集，那么`RAND()`的执行次数就会减少，这减少了非确定性对优化的影响。

