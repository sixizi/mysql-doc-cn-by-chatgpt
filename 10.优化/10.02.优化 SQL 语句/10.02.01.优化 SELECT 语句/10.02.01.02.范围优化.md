10.2.1.2 范围优化

范围访问方法使用单个索引来检索包含在一个或多个索引值区间内的表行子集。它可以用于单部分或多部分索引。以下部分描述了优化器使用范围访问的条件。

- 单部分索引的范围访问方法
- 多部分索引的范围访问方法
- 多值比较的等值范围优化
- 跳跃扫描范围访问方法
- 行构造表达式的范围优化
- 限制范围优化的内存使用

### 单部分索引的范围访问方法

对于单部分索引，索引值区间可以通过 WHERE 子句中相应的条件方便地表示为范围条件，而不是“区间”。

单部分索引的范围条件定义如下：

- 对于 BTREE 和 HASH 索引，使用 `=`、`<=>`、`IN()`、`IS NULL` 或 `IS NOT NULL` 操作符将键部分与常量值比较时，为范围条件。
- 此外，对于 BTREE 索引，当使用 `>`、`<`、`>=`、`<=`、`BETWEEN`、`!=` 或 `<>` 操作符，或者 LIKE 比较且 LIKE 的参数是不以通配符开头的常量字符串时，键部分与常量值的比较也是范围条件。

对于所有索引类型，多个范围条件结合使用 OR 或 AND 形成一个范围条件。

前述描述中的“常量值”指以下之一：

- 查询字符串中的常量
- 同一联接中 const 或系统表的列
- 非相关子查询的结果
- 完全由前述类型的子表达式组成的任何表达式

这里有一些带有 WHERE 子句中范围条件的查询示例：

```sql
SELECT * FROM t1
WHERE key_col > 1
AND key_col < 10;

SELECT * FROM t1
WHERE key_col = 1
OR key_col IN (15,18,20);

SELECT * FROM t1
WHERE key_col LIKE 'ab%'
OR key_col BETWEEN 'bar' AND 'foo';
```

有些非常量值可能在优化器的常量传播阶段转换为常量。

MySQL 尝试从 WHERE 子句中为每个可能的索引提取范围条件。在提取过程中，无法用于构建范围条件的条件将被丢弃，产生重叠区间的条件将被合并，产生空区间的条件将被移除。

考虑以下语句，其中 key1 是索引列而 nonkey 不是索引列：

```sql
SELECT * FROM t1 WHERE
  (key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
  (key1 < 'bar' AND nonkey = 4) OR
  (key1 < 'uux' AND key1 > 'z');
```

为 key1 的提取过程如下：

从原始 WHERE 子句开始：

```sql
(key1 < 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
(key1 < 'bar' AND nonkey = 4) OR
(key1 < 'uux' AND key1 > 'z')
```

移除 nonkey = 4 和 key1 LIKE '%b' 因为它们不能用于范围扫描。正确的移除方式是将它们替换为 TRUE，以便在进行范围扫描时不遗漏任何匹配行。替换为 TRUE 后：

```sql
(key1 < 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
(key1 < 'bar' AND TRUE) OR
(key1 < 'uux' AND key1 > 'z')
```



折叠始终为真或假的条件：

`(key1 LIKE 'abcde%' OR TRUE)` 始终为真

`(key1 < 'uux' AND key1 > 'z')` 始终为假

将这些条件替换为常量得出：

```sql
(key1 < 'abc' AND TRUE) OR (key1 < 'bar' AND TRUE) OR (FALSE)
```

移除不必要的 TRUE 和 FALSE 常量得出：

```sql
(key1 < 'abc') OR (key1 < 'bar')
```

将重叠的区间合并为一个最终用于范围扫描的条件：

```sql
(key1 < 'bar')
```

一般来说（如前例所示），用于范围扫描的条件比 WHERE 子句的条件更宽松。MySQL 进行额外的检查以过滤满足范围条件但不满足完整 WHERE 子句的行。