### 10.11.4 元数据锁

MySQL 使用元数据锁定来管理对数据库对象的并发访问，并确保数据一致性。元数据锁定不仅适用于表，还适用于架构、存储程序（过程、函数、触发器、计划事件）、表空间、使用 `GET_LOCK()` 函数获取的用户锁（参见 [14.14节，锁定函数](#14.14)），以及 [7.6.9.1节，锁定服务](#7.6.9.1) 中描述的锁定服务获取的锁。

`Performance Schema` 的 `metadata_locks` 表公开了元数据锁的信息，这对于查看哪些会话持有锁、哪些会话因等待锁而被阻塞等非常有用。详情请参见 [29.12.13.3节，metadata_locks 表](#29.12.13.3)。

元数据锁定确实涉及一些开销，随着查询量的增加，开销也会增加。多个查询试图访问相同对象时，元数据争用也会增加。

元数据锁定不是表定义缓存的替代品，其互斥锁和锁与 `LOCK_open` 互斥锁不同。以下讨论提供了有关元数据锁定工作原理的一些信息。

[元数据锁获取](#元数据锁获取)

[元数据锁释放](#元数据锁释放)

#### 元数据锁获取

如果有多个等待者等待获取给定的锁，则最高优先级的锁请求首先满足，除了与 `max_write_lock_count` 系统变量相关的例外。写锁请求的优先级高于读锁请求。但是，如果 `max_write_lock_count` 设置为某个较低的值（例如 10），则读锁请求可能会优先于挂起的写锁请求，如果这些读锁请求已经因为 10 个写锁请求而被跳过。通常这种行为不会发生，因为 `max_write_lock_count` 默认有一个很大的值。

语句逐一获取元数据锁，而不是同时获取，并在此过程中执行死锁检测。

`DML` 语句通常按照语句中提到的表的顺序获取锁。

`DDL` 语句、`LOCK TABLES` 及其他类似语句通过按名称顺序获取显式命名的表的锁来减少并发 `DDL` 语句之间的死锁可能性。对于隐式使用的表（例如外键关系中的表，也必须锁定），可能会以不同的顺序获取锁。

例如，`RENAME TABLE` 是按名称顺序获取锁的 `DDL` 语句：

此 `RENAME TABLE` 语句将 `tbla` 重命名为其他名称，并将 `tblc` 重命名为 `tbla`：

```sql
RENAME TABLE tbla TO tbld, tblc TO tbla;
```

该语句按顺序获取 `tbla`、`tblc` 和 `tbld` 的元数据锁（因为 `tbld` 在名称顺序上排在 `tblc` 之后）。

这个稍有不同的语句也将 `tbla` 重命名为其他名称，并将 `tblc` 重命名为 `tbla`：

```sql
RENAME TABLE tbla TO tblb, tblc TO tbla;
```

在这种情况下，语句按顺序获取 `tbla`、`tblb` 和 `tblc` 的元数据锁（因为 `tblb` 在名称顺序上排在 `tblc` 之前）。

两个语句都按顺序获取 `tbla` 和 `tblc` 的锁，但在获取 `tblc` 之前或之后获取剩余表名称的锁有所不同。

元数据锁获取顺序在多个事务同时执行时可能会影响操作结果，如下例所示。

以两个具有相同结构的表 `x` 和 `x_new` 开始。三个客户端发出涉及这些表的语句：

客户端 1：

```sql
LOCK TABLE x WRITE, x_new WRITE;
```

该语句请求并按名称顺序获取 `x` 和 `x_new` 的写锁。

客户端 2：

```sql
INSERT INTO x VALUES(1);
```

该语句请求并等待获取 `x` 的写锁。

客户端 3：

```sql
RENAME TABLE x TO x_old, x_new TO x;
```

该语句按名称顺序请求 `x`、`x_new` 和 `x_old` 的独占锁，但等待获取 `x` 的锁。

客户端 1：

```sql
UNLOCK TABLES;
```

该语句释放 `x` 和 `x_new` 的写锁。客户端 3 对 `x` 的独占锁请求优先于客户端 2 的写锁请求，因此客户端 3 获取 `x` 的锁，然后获取 `x_new` 和 `x_old` 的锁，执行重命名并释放锁。然后客户端 2 获取 `x` 的锁，执行插入并释放锁。

锁获取顺序导致 `RENAME TABLE` 在 `INSERT` 之前执行。插入发生的 `x` 表是客户端 2 发出插入时命名为 `x_new` 的表，并由客户端 3 重命名为 `x`：

```sql
mysql> SELECT * FROM x;
+------+
| i    |
+------+
|    1 |
+------+
mysql> SELECT * FROM x_old;
Empty set (0.01 sec)
```

现在以具有相同结构的表 `x` 和 `new_x` 开始。同样，三个客户端发出涉及这些表的语句：

客户端 1：

```sql
LOCK TABLE x WRITE, new_x WRITE;
```

该语句请求并按名称顺序获取 `new_x` 和 `x` 的写锁。

客户端 2：

```sql
INSERT INTO x VALUES(1);
```

该语句请求并等待获取 `x` 的写锁。

客户端 3：

```sql
RENAME TABLE x TO old_x, new_x TO x;
```

该语句按名称顺序请求 `new_x`、`old_x` 和 `x` 的独占锁，但等待获取 `new_x` 的锁。

客户端 1：

```sql
UNLOCK TABLES;
```

该语句释放 `x` 和 `new_x` 的写锁。对于 `x`，唯一的挂起请求来自客户端 2，因此客户端 2 获取锁，执行插入并释放锁。对于 `new_x`，唯一的挂起请求来自客户端 3，因此允许其获取锁（以及 `old_x` 的锁）。重命名操作仍然等待获取 `x` 的锁，直到客户端 2 完成插入并释放锁。然后客户端 3 获取 `x` 的锁，执行重命名并释放锁。

在这种情况下，锁获取顺序导致 `INSERT` 在 `RENAME TABLE` 之前执行。插入发生的 `x` 表是最初的 `x`，后来由重命名操作重命名为 `old_x`：

```sql
mysql> SELECT * FROM x;
Empty set (0.01 sec)
mysql> SELECT * FROM old_x;
+------+
| i    |
+------+
|    1 |
+------+
```

如果并发语句的锁获取顺序会对应用程序的操作结果产生影响，如上例所示，您可以调整表名以影响锁获取顺序。

元数据锁根据需要扩展到通过外键约束相关的表，以防止在相关表上同时执行冲突的 `DML` 和 `DDL` 操作。当更新父表时，在更新外键元数据时会在子表上获取元数据锁。外键元数据由子表拥有。

#### 元数据锁释放

为了确保事务的可串行化，服务器不得允许一个会话在另一个会话中未完成的显式或隐式开始的事务中使用的表上执行数据定义语言（`DDL`）语句。服务器通过获取事务中使用的表上的元数据锁并推迟这些锁的释放直到事务结束来实现这一点。表上的元数据锁防止表结构的更改。这种锁定方法意味着在一个会话内被事务使用的表不能在该事务结束之前被其他会话用于 `DDL` 语句。

这一原则不仅适用于事务表，还适用于非事务表。假设一个会话开始一个使用事务表 `t` 和非事务表 `nt` 的事务，如下所示：

```sql
START TRANSACTION;
SELECT * FROM t;
SELECT * FROM nt;
```

服务器在事务结束之前持有 `t` 和 `nt` 的元数据锁。如果另一个会话尝试在任一表上进行 `DDL` 或写锁操作，它会阻塞，直到事务结束时释放元数据锁。例如，第二个会话在尝试以下任何操作时会阻塞：

```sql
DROP TABLE t;
ALTER TABLE t ...;
DROP TABLE nt;
ALTER TABLE nt ...;
LOCK TABLE t ... WRITE;
```

同样的行为适用于 `LOCK TABLES ... READ`。即，显式或隐式开始的更新任何表（事务或非事务）的事务会阻塞，并被 `LOCK TABLES ... READ` 阻塞。

如果服务器为语法上有效但在执行期间失败的语句获取元数据锁，则不会提前释放锁。锁释放仍然推迟到事务结束，因为失败的语句会写入二进制日志，而锁保护日志一致性。

在自动提交模式下，每个语句实际上都是一个完整的事务，因此为语句获取的元数据锁只保留到语句结束。

在 `PREPARE` 语句期间获取的元数据锁在语句准备好后释放，即使准备发生在多语句事务中。

从 MySQL 8.0.13 开始，对于处于 `PREPARED` 状态的 `XA` 事务，元数据锁在客户端断开连接和服务器重启后仍然保留，直到执行 `XA COMMIT` 或 `XA ROLLBACK`。