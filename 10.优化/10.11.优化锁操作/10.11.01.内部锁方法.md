### 10.11.1 内部锁方法

本节讨论的是内部锁定，即在 MySQL 服务器内部执行的锁定，用于管理多个会话对表内容的争用。这种类型的锁定是内部的，因为它完全由服务器执行，不涉及其他程序。有关其他程序对 MySQL 文件执行的锁定，请参见10.11.5 节，“外部锁”。

[行级锁](#行级锁)

[表级锁](#表级锁)

[选择锁类型](#选择锁类型)

#### 行级锁

MySQL 对 InnoDB 表使用行级锁定，以支持多个会话同时进行写访问，使其适用于多用户、高并发和 OLTP 应用程序。

在对单个 InnoDB 表执行多个并发写操作时，为避免死锁，应在事务开始时获取必要的锁，通过对每组预期要修改的行发出 `SELECT ... FOR UPDATE` 语句，即使数据更改语句在事务后期才出现。如果事务修改或锁定多个表，应在每个事务中以相同的顺序发出适用的语句。死锁会影响性能，但并不代表严重错误，因为 InnoDB 默认会自动检测到死锁条件并回滚其中一个受影响的事务。

在高并发系统中，当大量线程等待同一个锁时，死锁检测可能会导致性能下降。有时，禁用死锁检测并依赖 `innodb_lock_wait_timeout` 设置来在发生死锁时回滚事务可能更为有效。可以使用 `innodb_deadlock_detect` 配置选项禁用死锁检测。

行级锁定的优点：

- 当不同会话访问不同的行时，锁冲突较少。
- 回滚的更改较少。
- 可能长时间锁定单行。

#### 表级锁定

MySQL 对 MyISAM、MEMORY 和 MERGE 表使用表级锁定，一次只允许一个会话更新这些表。此锁定级别使这些存储引擎更适合只读、主要读或单用户应用程序。

这些存储引擎通过始终在查询开始时一次请求所有需要的锁并始终按相同顺序锁定表来避免死锁。代价是这种策略降低了并发性；其他想要修改表的会话必须等到当前数据更改语句完成。

表级锁定的优点：

- 所需内存相对较少（行锁定需要每行或每组行锁定的内存）。
- 在使用表的大部分时速度快，因为只涉及一个锁。
- 如果你经常对大部分数据进行 `GROUP BY` 操作或必须频繁扫描整个表，速度快。

MySQL 授予表写锁如下：

- 如果表上没有锁，则对其加写锁。
- 否则，将锁请求放入写锁队列。

MySQL 授予表读锁如下：

- 如果表上没有写锁，则对其加读锁。
- 否则，将锁请求放入读锁队列。

表更新的优先级高于表检索。因此，当一个锁被释放时，锁首先被提供给写锁队列中的请求，然后提供给读锁队列中的请求。这确保了对表的更新即使在有大量 `SELECT` 活动时也不会被“饿死”。但是，如果对表有很多更新，则 `SELECT` 语句必须等到没有更多的更新。

有关更改读写优先级的信息，请参见10.11.2 节，“表锁定问题”。

你可以通过检查 `Table_locks_immediate` 和 `Table_locks_waited` 状态变量来分析系统上的表锁争用情况，这些变量分别指示可以立即授予的表锁请求次数和必须等待的次数：

```sql
mysql> SHOW STATUS LIKE 'Table%';
+-----------------------+---------+
| Variable_name         | Value   |
+-----------------------+---------+
| Table_locks_immediate | 1151552 |
| Table_locks_waited    | 15324   |
+-----------------------+---------+
```

性能模式锁表也提供锁定信息。请参见29.12.13 节，“性能模式锁表”。

MyISAM 存储引擎支持并发插入，以减少读者和写者对给定表的争用：如果一个 MyISAM 表在数据文件中间没有空闲块，则总是在数据文件末尾插入行。在这种情况下，可以在没有锁的情况下自由地将并发的 `INSERT` 和 `SELECT` 语句混合用于 MyISAM 表。也就是说，可以在其他客户端从 MyISAM 表读取时插入行。由于删除或更新表中间的行可能会产生空洞。如果有空洞，并发插入将被禁用，但在所有空洞都填入新数据后会自动重新启用。要控制此行为，请使用 `concurrent_insert` 系统变量。请参见10.11.3 节，“并发插入”。

如果你通过 `LOCK TABLES` 显式获取表锁，可以请求 `READ LOCAL` 锁而不是 `READ` 锁，以便在你锁定表时允许其他会话执行并发插入。

要在并发插入不可能的情况下对表 `t1` 执行许多 `INSERT` 和 `SELECT` 操作，可以将行插入临时表 `temp_t1`，然后用临时表中的行更新实际表：

```sql
mysql> LOCK TABLES t1 WRITE, temp_t1 WRITE;
mysql> INSERT INTO t1 SELECT * FROM temp_t1;
mysql> DELETE FROM temp_t1;
mysql> UNLOCK TABLES;
```

#### 选择锁类型

一般来说，在以下情况下表锁定优于行级锁：

- 表的大多数语句是读取。
- 表的语句是读取和写入的混合，其中写入是可以通过一次键读取来获取的单行更新或删除：
  ```sql
  UPDATE tbl_name SET column=value WHERE unique_key_col=key_value;
  DELETE FROM tbl_name WHERE unique_key_col=key_value;
  ```
- `SELECT` 与并发 `INSERT` 语句混合使用，且几乎没有 `UPDATE` 或 `DELETE` 语句。
- 没有写入者时，对整个表进行许多扫描或 `GROUP BY` 操作。

使用高级锁，可以更轻松地通过支持不同类型的锁来调优应用程序，因为锁开销比行级锁定少。

行级锁定以外的其他选项：

- 版本控制（如 MySQL 中的并发插入）允许一个写入者同时有多个读取者。这意味着数据库或表支持不同的数据视图，取决于访问何时开始。其他常见术语有“时间旅行”、“写时复制”或“按需复制”。
- 在许多情况下，按需复制优于行级锁定。但是在最坏的情况下，它可能比使用普通锁消耗更多的内存。
- 你可以使用应用级别的锁定，而不是使用行级锁定，例如 MySQL 中的 `GET_LOCK()` 和 `RELEASE_LOCK()` 提供的锁。这些是建议性锁定，因此它们仅与彼此配合的应用程序一起工作。请参见[14.14 节，“锁定函数”](#)。