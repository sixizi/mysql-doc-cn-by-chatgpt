### 10.11.2 表锁问题

`InnoDB` 表使用行级锁定，这样多个会话和应用程序可以同时读取和写入同一个表，而不会相互等待或产生不一致的结果。对于这种存储引擎，避免使用 `LOCK TABLES` 语句，因为它不会提供任何额外的保护，反而会降低并发性。自动行级锁定使这些表适合于您最繁忙的数据库和最重要的数据，同时简化了应用程序逻辑，因为您不需要锁定和解锁表。因此，`InnoDB` 存储引擎是 MySQL 的默认引擎。

除了 `InnoDB` 之外，MySQL 对所有存储引擎使用表锁定（而不是页、行或列锁定）。锁定操作本身没有太多开销。但由于在同一时间只有一个会话可以写入一个表，因此对于这些其他存储引擎，为了获得最佳性能，主要将它们用于查询频繁且很少插入或更新的表。

[性能考虑 - 倾向于 InnoDB](#性能考虑 - 倾向于 InnoDB)

[锁定性能问题的解决方法](#锁定性能问题的解决方法)

#### 性能考虑 - 倾向于 InnoDB

在选择使用 `InnoDB` 或其他存储引擎创建表时，请记住表锁定的以下缺点：

- 表锁定允许许多会话同时从表中读取，但如果一个会话想要写入表，则必须首先获得独占访问权限，这意味着它可能必须等待其他会话先完成对表的操作。在更新期间，所有其他想要访问该表的会话都必须等待，直到更新完成。
  
- 当会话因磁盘已满而等待时，表锁定会导致问题，必须在有可用空间之前才能继续。在这种情况下，所有想要访问问题表的会话也会进入等待状态，直到有更多的磁盘空间可用。

- 一个长时间运行的 `SELECT` 语句会阻止其他会话在此期间更新表，使得其他会话看起来很慢或无响应。当一个会话等待获得表的独占访问权以进行更新时，其他发出 `SELECT` 语句的会话会排队等待，减少了即使是只读会话的并发性。

#### 锁定性能问题的解决方法

以下项目描述了一些避免或减少表锁定引起的争用的方法：

- 考虑将表切换到 `InnoDB` 存储引擎，可以在设置时使用 `CREATE TABLE ... ENGINE=INNODB`，或对现有表使用 `ALTER TABLE ... ENGINE=INNODB`。详情请参见第17章，《InnoDB存储引擎》。

- 优化 `SELECT` 语句以加速运行，从而使它们锁定表的时间更短。为此，您可能需要创建一些汇总表。

- 启动 `mysqld` 时使用 `--low-priority-updates`。对于仅使用表级锁定的存储引擎（如 `MyISAM`、`MEMORY` 和 `MERGE`），这会使所有更新（修改）表的语句优先级低于 `SELECT` 语句。在这种情况下，上述场景中的第二个 `SELECT` 语句会在 `UPDATE` 语句之前执行，并且不会等待第一个 `SELECT` 完成。

- 要指定在特定连接中发出的所有更新都应以低优先级进行，请将 `low_priority_updates` 服务器系统变量设置为 `1`。

- 要为特定的 `INSERT`、`UPDATE` 或 `DELETE` 语句赋予较低的优先级，请使用 `LOW_PRIORITY` 属性。

- 要为特定的 `SELECT` 语句赋予更高的优先级，请使用 `HIGH_PRIORITY` 属性。请参见 15.2.13节，`SELECT` 语句。

- 启动 `mysqld` 时为 `max_write_lock_count` 系统变量设置较低的值，以迫使 MySQL 在特定数量的写锁发生后暂时提高所有等待表的 `SELECT` 语句的优先级（例如，对于插入操作）。这允许在一定数量的写锁之后进行读锁。

- 如果您遇到 `SELECT` 和 `DELETE` 语句混合使用的问题，`DELETE` 的 `LIMIT` 选项可能会有所帮助。请参见 15.2.2节，`DELETE` 语句。

- 使用 `SQL_BUFFER_RESULT` 和 `SELECT` 语句可以帮助缩短表锁的持续时间。请参见 15.2.13节，`SELECT` 语句。

- 将表内容拆分到不同的表中可能会有所帮助，因为这样查询可以在一个表的列上运行，而更新则限制在不同表的列上。

- 您可以更改 `mysys/thr_lock.c` 中的锁定代码以使用单一队列。在这种情况下，写锁和读锁将具有相同的优先级，这可能对某些应用程序有所帮助。