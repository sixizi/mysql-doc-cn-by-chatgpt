### 1.3 MySQL 8.0中的新功能

本节概述了MySQL 8.0中新增、弃用和删除的内容。附带的一节列出了MySQL 8.0中已添加、已弃用或已删除的MySQL服务器选项和变量；请参阅第1.4节“MySQL 8.0中添加、弃用或删除的服务器和状态变量和选项”。

- [MySQL 8.0中新增的功能](#MySQL 8.0中新增的功能)
- [MySQL 8.0中弃用的功能](#MySQL 8.0中弃用的功能)
- [MySQL 8.0中删除的功能](#MySQL 8.0中删除的功能)

#### MySQL 8.0中新增的功能

以下是MySQL 8.0中新增的功能：

- **数据字典**。MySQL现在包含一个事务性数据字典，用于存储有关数据库对象的信息。在之前的MySQL版本中，字典数据存储在元数据文件和非事务性表中。有关更多信息，请参阅第14章《MySQL数据字典》。

- **原子数据定义语句（Atomic DDL）**。原子DDL语句将与DDL操作相关的数据字典更新、存储引擎操作和二进制日志写入合并为一个原子事务。有关更多信息，请参阅第13.1.1节《原子数据定义语句支持》。

- **升级过程**。以前，在安装新版本的MySQL后，MySQL服务器会在下次启动时自动升级数据字典表，然后DBA需要手动调用mysql_upgrade来升级mysql模式下的系统表，以及其他模式中的对象，如sys模式和用户模式。

  从MySQL 8.0.16开始，服务器执行了以前由mysql_upgrade处理的任务。安装新的MySQL版本后，服务器现在会在下次启动时自动执行所有必要的升级任务，不再依赖于DBA调用mysql_upgrade。此外，服务器还会更新帮助表的内容（mysql_upgrade不会执行此操作）。一个新的--upgrade服务器选项提供了对服务器执行自动数据字典和服务器升级操作的控制。有关更多信息，请参阅第2.10.3节《MySQL升级过程升级的内容》。

- **会话复用**。MySQL服务器现在默认支持SSL会话复用，并设置了超时时间来控制服务器维护会话缓存的时期，该缓存建立了客户端允许为新连接请求会话复用的时间段。所有MySQL客户端程序都支持会话复用。有关服务器端和客户端配置信息，请参阅第6.3.5节《重用SSL会话》。

  此外，C应用程序现在可以使用C API功能来启用加密连接的会话复用（请参阅SSL会话复用）。

- **安全和帐户管理**。这些增强功能旨在提高安全性，并在帐户管理方面提供更大的DBA灵活性：

  - MySQL企业审计现在支持使用调度程序组件配置和执行定期任务以刷新内存中的缓存。有关设置说明，请参阅《启用审计日志刷新任务》。

  - 新的密码验证系统变量允许配置和强制要求用户在尝试替换自己的MySQL帐户密码时更改最低字符数。这个新的验证设置是当前密码中字符总数的百分比。例如，如果validate_password.changed_characters_percentage的值为50，替换帐户密码中至少一半的字符不能出现在当前密码中，否则密码将被拒绝。有关更多信息，请参阅第6.4.3节《密码验证组件》。

  - MySQL企业版现在提供基于组件的数据掩码和去标识化功能，而不是基于MySQL 8.0.13中引入的插件库。MySQL企业数据掩码和去标识化组件支持多字节字符，在数据库表中存储掩码字典，并提供了几个新的函数。有关更多信息，请参阅第6.5.1节《数据掩码组件与数据掩码插件》。

  - 在MySQL 8.0.33之前，mysql系统数据库用于MySQL企业审计的过滤器和用户帐户数据的持久存储。为了增强灵活性，新的audit_log_database服务器系统变量现在允许在服务器启动时指定全局模式命名空间中的其他数据库。mysql系统数据库是表存储的默认设置。

  - mysql系统数据库中的授权表现在是InnoDB（事务性）表请注意，上述功能列表是基于MySQL 8.0的知识截止日期为2021年9月。MySQL可能已经有了新的版本和功能。建议查阅MySQL官方文档，以获取最新的功能和更新信息。

  - 现在有一个新的caching_sha2_password身份验证插件可用。与sha256_password插件类似，caching_sha2_password实现了SHA-256密码哈希，但使用缓存来解决连接时的延迟问题。它还支持更多的传输协议，并且不需要与OpenSSL链接以实现基于RSA密钥对的密码交换功能。请参阅“6.4.1.2节：缓存SHA-2可插拔身份验证”。

    caching_sha2_password和sha256_password身份验证插件提供比mysql_native_password插件更安全的密码加密，并且caching_sha2_password比sha256_password具有更好的性能。由于caching_sha2_password具有这些更高的安全性和性能特点，它现在是首选的身份验证插件，并且也是默认的身份验证插件，而不是mysql_native_password。有关默认插件更改对服务器操作和与客户端和连接器的兼容性的影响的信息，请参阅“caching_sha2_password作为首选身份验证插件”。

  - MySQL Enterprise Edition SASL LDAP身份验证插件现在支持GSSAPI / Kerberos作为Linux上MySQL客户端和服务器的身份验证方法。这在Linux环境中非常有用，应用程序可以使用Microsoft Active Directory访问LDAP，并且默认启用了Kerberos。请参阅LDAP身份验证方法。

  - MySQL Enterprise Edition现在支持一种身份验证方法，允许用户使用Kerberos对MySQL Server进行身份验证，前提是有适当的Kerberos票据可用或可以获取。有关详细信息，请参阅“6.4.1.8节：Kerberos可插拔身份验证”。

  - MySQL现在支持角色，这是一组命名的特权集合。可以创建和删除角色。可以向角色授予权限并从中撤销权限。可以将角色授予并从用户帐户中撤销角色。可以从授予给帐户的角色中选择活动的适用角色，并且可以在会话过程中更改该帐户的角色。有关更多信息，请参阅“6.2.10节：使用角色”。

  - MySQL现在引入了用户帐户类别的概念，根据是否具有SYSTEM_USER特权来区分系统用户和普通用户。请参阅“6.2.11节：帐户类别”。

  - 以前，无法授予适用于某些模式的全局权限。如果启用了partial_revokes系统变量，现在可以实现此功能。请参阅“6.2.12节：使用部分撤销限制特权”。

  - GRANT语句具有AS user [WITH ROLE]子句，用于指定有关用于语句执行的特权上下文的附加信息。此语法在SQL级别可见，尽管其主要目的是通过在二进制日志中显示这些限制，从而使授予者对特权限制在所有节点上进行统一复制。请参阅“13.7.1.6节：GRANT语句”。

  - MySQL现在维护有关密码历史的信息，可以限制重用先前密码。DBA可以要求新密码不是从先前密码中选择的一些密码更改或一段时间内的密码。可以在全局范围内以及按帐户设置密码重用策略。

    现在可以要求验证尝试更改帐户密码时通过指定要替换的当前密码来进行验证。这使得DBA可以防止用户在不证明他们知道当前密码的情况下更改密码。可以在全局范围内以及按帐户设置密码验证策略。

    现在允许帐户具有双重密码，这使得在复杂的多服务器系统中可以无缝执行分阶段密码更改，而无需停机。

    MySQL现在允许管理员配置用户帐户，以便如果由于密码错误导致太多连续登录失败，会导致临时锁定帐户。每个帐户的所需失败次数和锁定时间可以进行配置。

    这些新功能为DBA提供了更完整的密码管理控制。有关更多信息，请参阅“6.2.15节：密码管理”。

  - 如果使用OpenSSL编译，并且运行时可用OpenSSL库和FIPS对象模块，MySQL现在支持FIPS模式。FIPS模式对密码操作施加了条件，例如对可接受的加密算法的限制或对更长密钥长度的要求。请参阅“6.8节：FIPS支持”。

  - 服务器用于新连接的TLS上下文现在可以在运行时重新配置。这个功能可能很有用，例如，可以避免重新启动运行时间很长的MySQL服务器，导致SSL证书过期。请参阅Server-Side Runtime Configuration and Monitoring for Encrypted Connections。

  - OpenSSL 1.1.1支持用于加密连接的TLS v1.3协议，MySQL 8.0.16及更高版本也支持TLS v1.3，如果服务器和客户端都使用了OpenSSL 1.1.1或更高版本。请参阅“6.3.2节：加密连接TLS协议和密码”。

  - MySQL现在将授予客户端的对命名管道的访问控制设置为在Windows上成功通信所必需的最低权限。新的MySQL客户端软件可以在不需要任何其他配置的情况下打开命名管道连接。如果不能立即升级旧的客户端软件，则可以使用新的named_pipe_full_access_group系统变量来给予Windows组打开命名管道连接所需的权限。对完全访问组的成员资格应受到限制且是临时的。

  - 以前，MySQL用户帐户使用单个身份验证方法进行服务器身份验证。从MySQL 8.0.27开始，MySQL支持多因素身份验证（MFA），可以创建具有多达三种身份验证方法的帐户。MFA支持包括以下更改：

    - CREATE USER和ALTER USER语法已扩展，允许指定多个身份验证方法。
    - authentication_policy系统变量可以通过控制可使用的因素数量和每个因素允许的身份验证类型来建立MFA策略。这对于如何使用CREATE USER和ALTER USER语句中与身份验证相关的子句施加了约束。
    - 客户端程序具有新的--password1，--password2和--password3命令行选项，用于指定多个密码。对于使用C API的应用程序，mysql_options4（）C API函数的新MYSQL_OPT_USER_PASSWORD选项可以实现相同的功能。

    此外，MySQL Enterprise Edition现在支持使用智能卡、安全密钥和生物识别读卡器等设备对MySQL Server进行身份验证。该身份验证方法基于Fast Identity Online（FIDO）标准，并使用一对插件，在服务器端使用authentication_fido，在客户端端使用authentication_fido_client。服务器端FIDO身份验证插件仅包含在MySQL Enterprise Edition发行版中。它不包含在MySQL社区发行版中。但是，客户端端插件包含在所有发行版中，包括社区发行版。这使得来自任何发行版的客户端都可以连接到加载有服务器端插件的服务器。

    多因素身份验证可以使用现有的MySQL身份验证方法、新的FIDO身份验证方法或两者的组合。有关更多信息，请参阅“6.2.18节：多因素身份验证”和“6.4.1.11节：FIDO可插拔身份验证”。

- **资源管理**。MySQL现在支持创建和管理资源组，并允许将在服务器内运行的线程分配给特定的组，以便线程根据组可用的资源执行。组属性可以控制其资源，以启用或限制组中线程的资源消耗。DBA可以根据不同的工作负载修改这些属性。目前，CPU时间是一种可管理的资源，表示为“虚拟CPU”的概念，包括CPU核心、超线程、硬件线程等等。服务器在启动时确定有多少个虚拟CPU可用，具有适当权限的数据库管理员可以将这些CPU与资源组关联，并将线程分配给组。有关更多信息，请参见第5.1.16节“资源组”。

- **表加密管理**。现在可以通过定义和强制执行加密默认值来全局管理表加密。default_table_encryption变量定义了新创建的模式和通用表空间的加密默认值。还可以使用DEFAULT ENCRYPTION子句在创建模式时定义模式的加密默认值。默认情况下，表继承所在模式或通用表空间的加密。通过启用table_encryption_privilege_check变量来强制执行加密默认值。在创建或更改模式或通用表空间时，如果加密设置与default_table_encryption设置不同，或者在创建或更改与默认模式加密不同的加密设置的表时，将进行权限检查。当启用table_encryption_privilege_check时，TABLE_ENCRYPTION_ADMIN权限允许覆盖默认的加密设置。有关更多信息，请参见为模式和通用表空间定义加密默认值。

- **InnoDB增强功能**。添加了以下InnoDB增强功能：

  - 当前最大自增计数器值在每次更改时写入重做日志，并在每次检查点时保存到引擎专用系统表中。这些更改使当前最大自增计数器值在服务器重新启动后保持持久性。此外：

    - 服务器重新启动不再取消AUTO_INCREMENT = N表选项的效果。如果将自增计数器初始化为特定值，或者将自增计数器值更改为较大值，则新值将在服务器重新启动后保持持久性。
    - 在回滚操作后立即重新启动服务器不再导致重新使用为回滚事务分配的自增值。
    - 如果将AUTO_INCREMENT列值修改为大于当前最大自增值的值（例如，在UPDATE操作中），则新值将保持持久性，并且随后的INSERT操作将从新的较大值开始分配自增值。

    有关更多信息，请参见第15.6.1.6节“在InnoDB中处理AUTO_INCREMENT”和InnoDB AUTO_INCREMENT计数器初始化。

  - 在遇到索引树损坏时，InnoDB将损坏标志写入重做日志，使损坏标志具有崩溃安全性。InnoDB还将内存中的损坏标志数据写入引擎专用系统表中的每个检查点。在恢复过程中，InnoDB从两个位置读取损坏标志，并在标记内存表和索引对象为损坏之前合并结果。

  - InnoDB memcached插件支持多个get操作（在单个memcached查询中获取多个键值对）和范围查询。请参见第15.20.4节“InnoDB memcached多个get和范围查询支持”。

  - 新的动态变量innodb_deadlock_detect可以用于禁用死锁检测。在高并发系统中，死锁检测可能导致大量线程等待同一个锁时减慢速度。有时，禁用死锁检测并依赖innodb_lock_wait_timeout设置在发生死锁时进行事务回滚可能更有效。


  - 新的Information Schema INNODB_CACHED_INDEXES表报告每个索引在InnoDB缓冲池中缓存的索引页数。


  - InnoDB临时表现在在共享临时表空间ibtmp1中创建。


  - InnoDB表空间加密功能支持对重做日志和撤销日志数据的加密。请参见重做日志加密和撤销日志加密。


  - InnoDB支持SELECT ... FOR SHARE和SELECT ... FOR UPDATE的NOWAIT和SKIP LOCKED选项。NOWAIT使语句在另一个事务锁定所请求的行时立即返回。SKIP LOCKED从结果集中删除被锁定的行。请参见使用NOWAIT和SKIP LOCKED进行锁定读并发。

    SELECT ... FOR SHARE替代了SELECT ... LOCK IN SHARE MODE，但LOCK IN SHARE MODE仍然可用以保持向后兼容性。这两个语句是等效的。不过，FOR UPDATE和FOR SHARE支持NOWAIT、SKIP LOCKED和OF tbl_name选项。请参见第13.2.13节“SELECT语句”。

    OF tbl_name将锁定查询应用于指定的表。


  - 在本地分区API中，原生分区支持ADD PARTITION、DROP PARTITION、COALESCE PARTITION、REORGANIZE PARTITION和REBUILD PARTITION ALTER TABLE选项，并且可以与ALGORITHM={COPY|INPLACE}和LOCK子句一起使用。

    使用ALGORITHM=INPLACE的DROP PARTITION删除存储在分区中的数据并且删除分区。但是，使用ALGORITHM=COPY或old_alter_table=ON的DROP PARTITION将重建分区表，并尝试将数据从删除的分区移动到具有兼容PARTITION ... VALUES定义的另一个分区。无法移动到另一个分区的数据将被删除。


  - InnoDB存储引擎现在使用MySQL数据字典而不是其自己的存储引擎特定数据字典。有关数据字典的信息，请参见第14章“MySQL数据字典”。


  - mysql系统表和数据字典表现在在MySQL数据目录中的一个名为mysql.ibd的单个InnoDB表空间文件中创建。以前，这些表是在mysql数据库目录中创建的单独的InnoDB表空间文件中创建的。

  - 在MySQL 8.0中引入了以下撤销表空间的更改：


    - 默认情况下，撤销日志现在位于两个撤销表空间中，这些表空间在初始化MySQL实例时创建。不再在系统表空间中创建撤销日志。

    - 从MySQL 8.0.14开始，可以使用CREATE UNDO TABLESPACE语法在运行时在指定位置创建其他撤销表空间。

      ```
      CREATE UNDO TABLESPACE tablespace_name ADD DATAFILE 'file_name.ibu';
      ```

      使用CREATE UNDO TABLESPACE语法创建的撤销表空间可以使用DROP UNDO TABLESPACE语法在运行时删除。

      ```
      DROP UNDO TABLESPACE tablespace_name;
      ```

      可以使用ALTER UNDO TABLESPACE语法将撤销表空间标记为活动或非活动状态。

      ```
      ALTER UNDO TABLESPACE tablespace_name SET {ACTIVE|INACTIVE};
      ```

      在Information Schema INNODB_TABLESPACES表中添加了一个显示表空间状态的STATE列。在删除撤销表空间之前，撤销表空间必须处于空状态。

  - innodb_undo_log_truncate变量默认启用。

  - innodb_rollback_segments变量定义了每个撤销表空间的回滚段数。以前，innodb_rollback_segments指定了MySQL实例的回滚段总数。此更改增加了可用于并发事务的回滚段数。回滚段越多，越有可能并发事务使用单独的回滚段进行撤销日志，减少资源争用。

  - 影响缓冲池预刷和刷新行为的变量的默认值已修改：


    - innodb_max_dirty_pages_pct_lwm的默认值现在为10。以前的默认值为0，禁用了缓冲池预刷。当缓冲池中脏页的百分比超过10％时，值为10将启用预刷。启用预刷可以提高性能一致性。
    - innodb_max_dirty_pages_pct的默认值从75增加到90。InnoDB尝试从缓冲池中刷新数据，以使脏页的百分比不超过此值。增加的默认值允许缓冲池中有更高比例的脏页。

  - 默认的innodb_autoinc_lock_mode设置现在为2（交错模式）。交错锁模式允许并行执行多行插入，提高并发性和可扩展性。新的innodb_autoinc_lock_mode默认设置反映了从基于语句的复制更改为基于行的复制作为MySQL 5.7中默认复制类型的变化。基于语句的复制需要连续的自增锁模式（先前的默认值）以确保为给定的SQL语句序列分配自增值的顺序是可预测和可重复的，而基于行的复制不受SQL语句的执行顺序的影响。有关更多信息，请参见InnoDB AUTO_INCREMENT锁模式。

    对于使用基于语句的复制的系统，新的innodb_autoinc_lock_mode默认设置可能会破坏依赖于顺序自增值的应用程序。要恢复先前的默认设置，请将innodb_autoinc_lock_mode设置为1。

  - 通过ALTER TABLESPACE ... RENAME TO语法支持重命名通用表空间。

  - 新的innodb_dedicated_server变量，默认禁用，可用于根据服务器上检测到的内存量自动配置以下选项：


    - innodb_buffer_pool_size
    - innodb_log_file_size
    - innodb_flush_method

    此选项适用于运行在专用服务器上的MySQL服务器实例。有关更多信息，请参见第15.8.12节“启用专用MySQL服务器的自动配置”。

  - 新的Information Schema INNODB_TABLESPACES_BRIEF视图提供了InnoDB表空间的空间、名称、路径、标志和空间类型数据。

  - MySQL捆绑的zlib库版本从1.2.3提升到1.2.11。MySQL使用zlib库实现压缩功能。

    如果使用InnoDB压缩表，请参阅第2.10.4节“MySQL 8.0中的更改”以了解相关升级影响。

  - 序列化字典信息（SDI）存在于除全局临时表空间和撤销表空间文件之外的所有InnoDB表空间文件中。SDI是表和表空间对象的序列化元数据。存在SDI数据可以提供元数据冗余。例如，如果数据字典不可用，可以从表空间文件中提取字典对象元数据。使用ibd2sdi工具执行SDI提取。SDI数据以JSON格式存储。

    在表空间文件中包含SDI数据会增加表空间文件的大小。一个SDI记录需要一个索引页，默认大小为16KB。但是，存储时会对SDI数据进行压缩，以减少存储占用空间。

  - InnoDB存储引擎现在支持原子DDL，这确保了DDL操作无论服务器在操作过程中是否停止，都要么完全提交，要么完全回滚。有关更多信息，请参见第13.1.1节“原子数据定义语句支持”。

  - 在服务器离线状态下，可以使用innodb_directories选项将表空间文件移动或还原到新位置。有关更多信息，请参见第15.6.3.6节“在服务器离线状态下移动表空间文件”。

  - 以下的重做日志优化已经实施：


    - 用户线程现在可以在不同步写入的情况下并发地写入日志缓冲区。
    - 用户线程现在可以以放松的顺序将脏页添加到刷新列表中。
    - 现在有一个专用的日志线程负责将日志缓冲区写入系统缓冲区，将系统缓冲区刷新到磁盘，通知用户线程已写入和刷新的重做，维护放松刷新列表顺序所需的滞后，并写入检查点。
    - 添加了系统变量来配置用户线程等待刷新的重做时使用自旋延迟的情况：

      - innodb_log_wait_for_flush_spin_hwm：定义超过该值的平均日志刷新时间，用户线程在等待刷新的重做时不再自旋。
      - innodb_log_spin_cpu_abs_lwm：定义低于该值的CPU使用率，用户线程在等待刷新的重做时不再自旋。
      - innodb_log_spin_cpu_pct_hwm：定义高于该值的CPU使用率，用户线程在等待刷新的重做时不再自旋。
      - innodb_log_buffer_size变量现在是动态的，允许在服务器运行时调整日志缓冲区的大小。


    有关更多信息，请参阅8.5.4节，“优化InnoDB重做日志”。

  - 从MySQL 8.0.12开始，支持对大对象（LOB）数据进行小更新的撤消日志记录，从而提高了100字节大小或更小的LOB更新的性能。以前，LOB更新的最小大小为一个LOB页，这对于可能只修改几个字节的更新来说不太理想。此增强功能建立在MySQL 8.0.4中对LOB数据的部分更新支持之上。

  - 从MySQL 8.0.12开始，ALGORITHM=INSTANT支持以下ALTER TABLE操作：


    - 添加列。此功能也称为“Instant ADD COLUMN”。有限制条件。请参阅15.12.1节，“在线DDL操作”。
    - 添加或删除虚拟列。
    - 添加或删除列的默认值。
    - 修改ENUM或SET列的定义。
    - 更改索引类型。
    - 重命名表。

    只有支持ALGORITHM=INSTANT的操作才会修改数据字典中的元数据。表上不会获取元数据锁，表数据也不会受到影响，因此操作是瞬时的。如果未明确指定，支持ALGORITHM=INSTANT的操作默认使用ALGORITHM=INSTANT。如果指定了ALGORITHM=INSTANT但不支持，操作将立即失败并显示错误。

    有关支持ALGORITHM=INSTANT的操作的更多信息，请参阅15.12.1节，“在线DDL操作”。

  - 从MySQL 8.0.13开始，TempTable存储引擎支持存储二进制大对象（BLOB）类型列。此增强功能改善了使用包含BLOB数据的临时表的查询性能。以前，包含BLOB数据的临时表存储在由internal_tmp_disk_storage_engine定义的磁盘存储引擎中。有关更多信息，请参阅8.4.4节，“MySQL中的内部临时表使用”。

  - 从MySQL 8.0.13开始，InnoDB的数据静止加密功能支持通用表空间。以前，只能对每个表的表空间进行加密。为了支持通用表空间的加密，扩展了CREATE TABLESPACE和ALTER TABLESPACE语法，包括一个ENCRYPTION子句。

    Information Schema INNODB_TABLESPACES表现在包括一个ENCRYPTION列，指示表空间是否加密。

    添加了stage/innodb/alter tablespace (encryption)性能模式阶段仪器，以监视通用表空间加密操作。

  - 禁用innodb_buffer_pool_in_core_file变量可以通过排除InnoDB缓冲池页面来减小核心文件的大小。要使用此变量，必须启用core_file变量，并且操作系统必须支持MADV_DONTDUMP非POSIX扩展到madvise()，该扩展在Linux 3.4及更高版本中受支持。有关更多信息，请参见第15.8.3.7节“从核心文件中排除缓冲池页面”。

  - 从MySQL 8.0.13开始，用户创建的临时表和优化器创建的内部临时表存储在为会话分配的临时表空间中，该临时表空间从临时表空间池中分配。当会话断开连接时，其临时表空间被截断并释放回池中。在以前的版本中，临时表是在全局临时表空间（ibtmp1）中创建的，在临时表被删除后，不会将磁盘空间返回给操作系统。

    innodb_temp_tablespaces_dir变量定义了会话临时表空间的创建位置。默认位置是数据目录中的#innodb_temp目录。

    INNODB_SESSION_TEMP_TABLESPACES表提供有关会话临时表空间的元数据。

    全局临时表空间（ibtmp1）现在存储对用户创建的临时表所做的更改的回滚段。

  - 从MySQL 8.0.14开始，InnoDB支持并行聚簇索引读取，可以提高CHECK TABLE性能。此功能不适用于辅助索引扫描。innodb_parallel_read_threads会话变量必须设置为大于1的值，才能进行并行聚簇索引读取。默认值为4。执行并行聚簇索引读取所使用的线程数取决于innodb_parallel_read_threads设置或要扫描的索引子树的数量，以较小者为准。

  - 从8.0.14开始，当启用innodb_dedicated_server变量时，根据自动配置的缓冲池大小配置日志文件的大小和数量。以前，日志文件的大小是根据服务器上检测到的内存量进行配置的，并且日志文件的数量不是自动配置的。

  - 从8.0.14开始，CREATE TABLESPACE语句的ADD DATAFILE子句是可选的，这允许没有FILE权限的用户创建表空间。执行不带ADD DATAFILE子句的CREATE TABLESPACE语句会隐式创建一个带有唯一文件名的表空间数据文件。

  - 默认情况下，当TempTable存储引擎占用的内存量超过temptable_max_ram变量定义的内存限制时，TempTable存储引擎开始从磁盘分配内存映射临时文件。从MySQL 8.0.16开始，此行为由temptable_use_mmap变量控制。禁用temptable_use_mmap会导致TempTable存储引擎使用InnoDB磁盘上的内部临时表，而不是内存映射文件作为其溢出机制。有关更多信息，请参见内部临时表存储引擎。

  - 从MySQL 8.0.16开始，InnoDB数据静止加密功能支持对mysql系统表空间进行加密。mysql系统表空间包含mysql系统数据库和MySQL数据字典表。有关更多信息，请参见第15.13节“InnoDB数据静止加密”。

  - innodb_spin_wait_pause_multiplier变量在MySQL 8.0.16中引入，可更好地控制当线程等待获取互斥锁或读写锁时发生的自旋锁轮询延迟的持续时间。延迟可以更精细地调整，以考虑不同处理器架构上的PAUSE指令持续时间的差异。有关更多信息，请参见第15.8.8节“配置自旋锁轮询”。

  - 通过在MySQL 8.0.17中改进对大数据集的InnoDB并行读取线程性能，可以更好地利用读取线程，通过减少并行扫描期间的预取活动的读取线程I/O，并支持对分区的并行扫描。

    并行读取线程功能由innodb_parallel_read_threads变量控制。最大设置现在为256，即所有客户端连接的总线程数。如果达到线程限制，连接将回退到使用单个线程。

  - innodb_idle_flush_pct变量在MySQL 8.0.18中引入，允许在空闲期间限制页面刷新，从而可以延长固态存储设备的使用寿命。请参见限制空闲期间的缓冲刷新。

  - 从MySQL 8.0.19开始，支持对InnoDB数据进行高效采样，以生成直方图统计信息。请参见直方图统计分析。

  - 从MySQL 8.0.20开始，双写缓冲区存储区域位于双写文件中。在以前的版本中，存储区域位于系统表空间中。将存储区域移出系统表空间可以减少写入延迟，增加吞吐量，并提供关于双写缓冲区页面放置的灵活性。以下系统变量用于高级双写缓冲区配置：

    - innodb_doublewrite_dir

      定义双写缓冲区文件目录。

    - innodb_doublewrite_files

      定义双写文件的数量。

    - innodb_doublewrite_pages

      定义批量写入的每个线程的最大双写页面数。

    - innodb_doublewrite_batch_size

      定义一批写入的双写页面数。

    有关更多信息，请参见第15.6.4节“双写缓冲区”。

  - 在MySQL 8.0.20中改进了优先处理等待锁的事务的CATS（Contention-Aware Transaction Scheduling）算法。现在，事务调度权重计算完全在一个单独的线程中进行，提高了计算性能和准确性。

    先进先出（FIFO）算法也用于事务调度，但已被移除。由于CATS算法的改进，FIFO算法变得多余。之前由FIFO算法执行的事务调度现在由CATS算法执行。

    在INFORMATION_SCHEMA.INNODB_TRX表中添加了一个TRX_SCHEDULE_WEIGHT列，允许查询CATS算法分配的事务调度权重。

    为了监控代码级别的事务调度事件，添加了以下INNODB_METRICS计数器：

    - lock_rec_release_attempts：释放记录锁的尝试次数。
    - lock_rec_grant_attempts：授予记录锁的尝试次数。
    - lock_schedule_refreshes：分析等待图以更新事务调度权重的次数。

    有关更多信息，请参见第15.7.6节“事务调度”。

  - 从MySQL 8.0.21开始，为了提高需要访问表和行资源的锁队列的并发性能，锁系统互斥锁（lock_sys->mutex）被分片锁取代，并且锁队列被分组为表和页锁队列分片，并由专用的互斥锁保护。之前，单个锁系统互斥锁保护所有锁队列，在高并发系统中成为争用点。新的分片实现允许更精细地访问锁队列。

    锁系统互斥锁（lock_sys->mutex）被以下分片锁取代：

    - 全局锁（lock_sys->latches.global_latch），由64个读写锁对象（rw_lock_t）组成。访问单个锁队列需要共享的全局锁和锁队列分片上的锁。需要访问所有锁队列的操作会获取一个独占的全局锁，该锁会锁定所有表和页锁队列分片。
    - 表分片锁（lock_sys->latches.table_shards.mutexes），由512个互斥锁组成的数组，每个互斥锁专用于512个表锁队列分片之一。
    - 页分片锁（lock_sys->latches.page_shards.mutexes），由512个互斥锁组成的数组，每个互斥锁专用于512个页锁队列分片之一。

    用于监视单个锁系统互斥锁的Performance Schema wait/synch/mutex/innodb/lock_mutex工具被用于监视新的全局锁、表分片锁和页分片锁：

    - wait/synch/sxlock/innodb/lock_sys_global_rw_lock
    - wait/synch/mutex/innodb/lock_sys_table_mutex
    - wait/synch/mutex/innodb/lock_sys_page_mutex

  - 从MySQL 8.0.21开始，使用DATA DIRECTORY子句在数据目录之外创建的表和表分区数据文件将被限制在InnoDB已知的目录中。这个改变允许数据库管理员控制表空间数据文件的创建位置，并确保在恢复期间可以找到数据文件。

    通用表空间和每个表的表空间数据文件（.ibd文件）不再可以在undo表空间目录（innodb_undo_directory）中创建，除非该目录已被InnoDB知道。

    已知的目录包括由datadir、innodb_data_home_dir和innodb_directories变量定义的目录。

    在文件-表空间中的InnoDB表进行截断操作会删除现有的表空间并创建一个新的表空间。从MySQL 8.0.21开始，InnoDB会在默认位置创建新的表空间，并在错误日志中写入警告，如果当前表空间目录未知。要让TRUNCATE TABLE在其当前位置创建表空间，在运行TRUNCATE TABLE之前，将目录添加到innodb_directories设置中。

  - 从MySQL 8.0.21开始，可以使用ALTER INSTANCE {ENABLE|DISABLE} INNODB REDO_LOG语法来启用和禁用重做日志记录。此功能旨在用于将数据加载到新的MySQL实例中。禁用重做日志记录可以通过避免重做日志写入来加快数据加载速度。

    新的INNODB_REDO_LOG_ENABLE权限允许启用和禁用重做日志记录。

    新的Innodb_redo_log_enabled状态变量允许监视重做日志记录状态。

    请参见禁用重做日志记录。

  - 在启动时，InnoDB会根据数据字典中存储的表空间文件路径验证已知表空间文件的路径，以防止表空间文件被移动到不同的位置。在MySQL 8.0.21中引入的新变量innodb_validate_tablespace_paths允许禁用表空间路径验证。此功能适用于不移动表空间文件的环境。禁用表空间路径验证可以提高具有大量表空间文件的系统的启动时间。

    有关更多信息，请参见禁用表空间路径验证。

  - 从MySQL 8.0.21开始，在使用基于行的复制时，支持原子DDL的存储引擎将CREATE TABLE ... SELECT语句作为一个事务记录到二进制日志中。以前，它被记录为两个事务，一个用于创建表，另一个用于插入数据。通过这个改变，CREATE TABLE ... SELECT语句现在可以安全地用于基于行的复制，并允许与基于GTID的复制一起使用。有关更多信息，请参见原子数据定义语句支持。

  - 在繁忙的系统上截断撤消表空间可能会影响性能，因为相关的刷新操作会从缓冲池中删除旧的撤消表空间页面，并将新的撤消表空间的初始页面刷新到磁盘。为了解决这个问题，从MySQL 8.0.21开始，刷新操作被移除。

    旧的撤消表空间页面会在变得最不常使用时被被动释放，或者在下一个完整检查点时被删除。现在，截断操作期间新的撤消表空间的初始页面会被记录到重做日志中，而不是刷新到磁盘，这也提高了撤消表空间截断操作的持久性。

    为了防止过多的撤消表空间截断操作可能引起的潜在问题，同一撤消表空间在检查点之间的截断操作现在被限制为64次。如果超过了这个限制，撤消表空间仍然可以被设置为非活动状态，但直到下一个检查点之后才会被截断。

    与已弃用的撤消截断刷新操作相关的INNODB_METRICS计数器被移除。移除的计数器包括：undo_truncate_sweep_count、undo_truncate_sweep_usec、undo_truncate_flush_count和undo_truncate_flush_usec。

    请参见撤消表空间。

  - 从MySQL 8.0.22开始，新的innodb_extend_and_initialize变量允许配置InnoDB在Linux上如何为文件-表空间和通用表空间分配空间。默认情况下，当操作需要在表空间中分配额外的空间时，InnoDB会为表空间分配页面并在这些页面上物理写入NULL值。如果频繁分配新页面，这种行为会影响性能。您可以在Linux系统上禁用innodb_extend_and_initialize，以避免对新分配的表空间页面进行物理写入NULL值的操作。当禁用innodb_extend_and_initialize时，使用posix_fallocate()调用来分配空间，该调用可以在不物理写入NULL值的情况下保留空间。

    posix_fallocate()操作不是原子操作，这意味着在将空间分配给表空间文件并更新文件元数据之间可能会发生故障。这种故障可能会导致新分配的页面处于未初始化状态，当InnoDB尝试访问这些页面时会导致失败。为了防止这种情况发生，InnoDB在分配新的表空间页面之前写入重做日志记录。如果页面分配操作被中断，将在恢复期间从重做日志记录中重新执行该操作。

  - 从MySQL 8.0.23开始，InnoDB支持对属于加密表空间的双写文件页面进行加密。页面使用关联表空间的加密密钥进行加密。有关更多信息，请参见InnoDB数据静态加密。

  - 在MySQL 8.0.23中引入的temptable_max_mmap变量定义了TempTable存储引擎在开始将内部临时表数据存储到磁盘之前，允许从内存映射（MMAP）文件中分配的最大内存量。将设置为0将禁止从MMAP文件进行分配。有关更多信息，请参见MySQL中的内部临时表使用。

  - 在MySQL 8.0.23中引入的AUTOEXTEND_SIZE选项定义了当表空间满时，InnoDB扩展表空间大小的量，从而可以以更大的增量扩展表空间大小。AUTOEXTEND_SIZE选项与CREATE TABLE、ALTER TABLE、CREATE TABLESPACE和ALTER TABLESPACE语句一起使用。有关更多信息，请参见表空间AUTOEXTEND_SIZE配置。

    在Information Schema INNODB_TABLESPACES表中添加了一个AUTOEXTEND_SIZE大小列。

  - 在MySQL 8.0.26中引入的innodb_segment_reserve_factor系统变量允许配置保留为空页面的表空间文件段页面的百分比。有关更多信息，请参见配置保留文件段页面百分比。

  - 在支持fdatasync()系统调用的平台上，innodb_use_fdatasync变量允许在操作系统刷新时使用fdatasync()而不是fsync()。fdatasync()系统调用不会刷新文件元数据，除非需要进行后续数据检索，从而提供潜在的性能优势。

  - 从MySQL 8.0.28开始，tmp_table_size变量定义了TempTable存储引擎创建的任何单个内存中内部临时表的最大大小。适当的大小限制可以防止单个查询消耗过多的全局TempTable资源。请参见内部临时表存储引擎。

  - 从MySQL 8.0.28开始，innodb_open_files变量定义了InnoDB可以同时打开的文件数，可以使用SELECT innodb_set_open_files_limit(N)语句在运行时设置该变量。该语句执行一个存储过程来设置新的限制。

    为了防止非LRU管理的文件占用整个innodb_open_files限制，非LRU管理的文件被限制为innodb_open_files限制的90%，这将为LRU管理的文件保留10%的innodb_open_files限制。

    innodb_open_files限制现在包括临时表空间文件，之前不计入限制。

  - 从MySQL 8.0.28开始，InnoDB支持使用ALGORITHM=INSTANT进行ALTER TABLE ... RENAME COLUMN操作。

    有关此功能以及其他支持ALGORITHM=INSTANT的DDL操作的更多信息，请参见第15.12.1节“在线DDL操作”。

  - 从MySQL 8.0.29开始，InnoDB支持使用ALGORITHM=INSTANT的ALTER TABLE ... DROP COLUMN操作。

    在MySQL 8.0.29之前，一个立即添加的列只能添加为表的最后一列。从MySQL 8.0.29开始，一个立即添加的列可以添加到表的任何位置。

    立即添加或删除的列会创建受影响行的新版本。最多允许64个行版本。在Information Schema INNODB_TABLES表中添加了一个新的TOTAL_ROW_VERSIONS列，用于跟踪行版本的数量。

    有关支持ALGORITHM=INSTANT的DDL操作的更多信息，请参见第15.12.1节“在线DDL操作”。

  - 从MySQL 8.0.30开始，innodb_doublewrite系统变量支持DETECT_ONLY和DETECT_AND_RECOVER设置。使用DETECT_ONLY设置，数据库页面内容不会写入双写缓冲区，并且恢复不会使用双写缓冲区来修复不完整的页面写入。这个轻量级设置仅用于检测不完整的页面写入。DETECT_AND_RECOVER设置等效于现有的ON设置。有关更多信息，请参见第15.6.4节“双写缓冲区”。

  - 从MySQL 8.0.30开始，InnoDB支持动态配置重做日志容量。innodb_redo_log_capacity系统变量可以在运行时设置，以增加或减少重做日志文件占用的总磁盘空间。

    随着这个变化，重做日志文件的数量和默认位置也发生了变化。从MySQL 8.0.30开始，InnoDB在数据目录中的#innodb_redo目录中维护32个重做日志文件。以前，默认情况下，InnoDB在数据目录中创建两个重做日志文件，并且重做日志文件的数量和大小由innodb_log_files_in_group和innodb_log_file_size变量控制。这两个变量现在已被弃用。

    当定义了innodb_redo_log_capacity设置时，innodb_log_files_in_group和innodb_log_file_size设置将被忽略；否则，这些设置将用于计算innodb_redo_log_capacity设置（innodb_log_files_in_group * innodb_log_file_size = innodb_redo_log_capacity）。如果没有设置这些变量中的任何一个，重做日志容量将设置为innodb_redo_log_capacity的默认值，即104857600字节（100MB）。

    提供了几个用于监视重做日志和重做日志调整操作的状态变量。

    有关更多信息，请参见第15.6.5节“重做日志”。

  - 从MySQL 8.0.31开始，有两个新的状态变量用于监视在线缓冲池调整操作。Innodb_buffer_pool_resize_status_code状态变量报告一个状态码，指示在线缓冲池调整操作的阶段。Innodb_buffer_pool_resize_status_progress状态变量报告一个百分比值，指示每个阶段的进度。

    有关更多信息，请参见第15.8.3.1节“配置InnoDB缓冲池大小”。

- **字符集支持。**默认字符集已从latin1更改为utf8mb4。utf8mb4字符集具有几个新的排序规则，包括utf8mb4_ja_0900_as_cs，这是MySQL中首个用于Unicode的日语特定排序规则。有关更多信息，请参见第10.10.1节“Unicode字符集”。

- **JSON增强功能**。MySQL的JSON功能进行了以下增强或添加：

  - 添加了->>（内联路径）运算符，它等同于对JSON_EXTRACT()的结果调用JSON_UNQUOTE()。

    这是在MySQL 5.7中引入的列路径运算符->的改进；col->>"$.path"等同于JSON_UNQUOTE(col->"$.path")。内联路径运算符可在可以使用JSON_UNQUOTE(JSON_EXTRACT())的任何地方使用，如选择列列表、WHERE和HAVING子句以及ORDER BY和GROUP BY子句。有关运算符的详细信息，请参见运算符的描述，以及JSON路径语法。

  - 添加了两个JSON聚合函数JSON_ARRAYAGG()和JSON_OBJECTAGG()。JSON_ARRAYAGG()以列或表达式作为参数，并将结果作为单个JSON数组聚合。表达式可以评估为任何MySQL数据类型；它不必是JSON值。JSON_OBJECTAGG()接受两个列或表达式，它将它们解释为键和值；它将结果作为单个JSON对象返回。有关更多信息和示例，请参阅第12.19节“聚合函数”。

  - 添加了JSON实用函数JSON_PRETTY()，它以易读的格式输出现有的JSON值；每个JSON对象成员或数组值在单独的行上打印，子对象或数组相对于其父对象缩进2个空格。

    此函数还适用于可以解析为JSON值的字符串。

    有关更详细的信息和示例，请参见第12.17.8节“JSON实用函数”。

  - 在使用ORDER BY对查询中的JSON值进行排序时，每个值现在由排序键的可变长度部分表示，而不是固定大小的部分。在许多情况下，这可以减少过度使用。例如，标量INT甚至BIGINT值实际上只需要很少的字节，因此该空间的其余部分（高达90%或更多）被填充。这个改变对性能有以下好处：

    - 排序缓冲区空间现在被更有效地使用，因此文件排序不需要像使用固定长度排序键时那样早期或经常刷新到磁盘。这意味着可以在内存中排序更多的数据，避免不必要的磁盘访问。
    - 较短的键比较比较快，提供了明显的性能改进。这对于完全在内存中执行的排序以及需要写入和读取磁盘的排序都是如此。

  - 在MySQL 8.0.2中添加了对JSON列值的部分、原地更新的支持，这比在更新任何JSON列时以前所做的完全删除现有的JSON值并写入新值的方式更高效。为了应用这种优化，必须使用JSON_SET()、JSON_REPLACE()或JSON_REMOVE()应用更新。无法向正在更新的JSON文档中添加新元素；文档中的值不能比更新之前占用更多的空间。有关要求的详细讨论，请参见JSON值的部分更新。

    部分更新的JSON文档可以写入二进制日志，占用的空间比记录完整的JSON文档要少。当使用基于语句的复制时，部分更新始终被作为这样的日志记录。要使其与基于行的复制配合使用，必须首先设置binlog_row_value_options=PARTIAL_JSON；有关更多信息，请参阅此变量的描述。

  - 添加了JSON实用函数JSON_STORAGE_SIZE()和JSON_STORAGE_FREE()。JSON_STORAGE_SIZE()返回在部分更新之前用于JSON文档的二进制表示的存储空间（请参见前面的项目）。JSON_STORAGE_FREE()显示类型为JSON的表列在使用JSON_SET()或JSON_REPLACE()进行部分更新后剩余的空间；如果新值的二进制表示比先前的值少，则该值大于零。

    这些函数中的每一个还接受JSON文档的有效字符串表示。对于这样的值，JSON_STORAGE_SIZE()返回其转换为JSON文档后的二进制表示所使用的空间。对于包含JSON文档的字符串表示的变量，JSON_STORAGE_FREE()返回零。如果其（非空）参数无法解析为有效的JSON文档，则任一函数将产生错误，并且如果参数为NULL，则返回NULL。

    有关更多信息和示例，请参见第12.17.8节“JSON实用函数”。

    JSON_STORAGE_SIZE()和JSON_STORAGE_FREE()在MySQL 8.0.2中实现。

  - 在XPath表达式中，添加了对范围（例如$[1 to 5]）的支持。在此版本中还添加了对last关键字和相对寻址的支持，因此$[last]始终选择数组中的最后一个（最高编号）元素，$[last-1]选择倒数第二个元素。last和使用它的表达式也可以包含在范围定义中。例如，$[last-2 to last-1]返回数组中的最后两个元素除一个。有关更多信息和示例，请参见第12.17.8节“搜索和修改JSON值”。

  - 添加了一个符合RFC 7396的JSON合并函数。JSON_MERGE_PATCH()在2个JSON对象上使用时，将它们合并为一个单独的JSON对象，其中的成员是以下集合的并集：

    - 第一个对象的每个成员，在第二个对象中没有具有相同键的成员。
    - 第二个对象的每个成员，在第一个对象中没有具有相同键的成员，并且其值不是JSON null字面值。
    - 具有在两个对象中都存在的键的每个成员，其在第二个对象中的值不是JSON null字面值。

    在此工作的一部分，JSON_MERGE()函数已更名为JSON_MERGE_PRESERVE()。JSON_MERGE()在MySQL 8.0中仍然被识别为JSON_MERGE_PRESERVE()的别名，但现在已被弃用，并可能在将来的MySQL版本中被删除。

    有关更多信息和示例，请参见第12.17.4节“修改JSON值的函数”。

  - 实现了“最后重复键优胜”的重复键的规范化，与RFC 7159和大多数JavaScript解析器一致。这里显示了此行为的示例，只保留具有键x的最右边的成员：

    ```mysql
    mysql> SELECT JSON_OBJECT('x', '32', 'y', '[true, false]',
         >                     'x', '"abc"', 'x', '100') AS Result; 
    +------------------------------------+ 
    | Result                             | 
    +------------------------------------+ 
    | {"x": "100", "y": "[true, false]"} | 
    +------------------------------------+ 
    1 row in set (0.00 sec)
    ```

    这是与MySQL先前版本不兼容的更改，在这些版本中，在这种情况下使用“首个重复键优胜”算法。

    有关更多信息和示例，请参阅《规范化、合并和自动包装JSON值》。

  - 在MySQL 8.0.4中添加了JSON_TABLE()函数。该函数接受JSON数据并将其作为具有指定列的关系表返回。

    此函数的语法为JSON_TABLE(expr, path COLUMNS column_list) [AS] alias)，其中expr是返回JSON数据的表达式，path是应用于源数据的JSON路径，column_list是列定义的列表。下面是一个示例：

    ```mysql
    mysql> SELECT *
        -> FROM
        ->   JSON_TABLE(
        ->     '[{"a":3,"b":"0"},{"a":"3","b":"1"},{"a":2,"b":1},{"a":0},{"b":[1,2]}]',
        ->     "$[*]" COLUMNS(
        ->       rowid FOR ORDINALITY,
        ->
        ->       xa INT EXISTS PATH "$.a",
        ->       xb INT EXISTS PATH "$.b",
        ->
        ->       sa VARCHAR(100) PATH "$.a",
        ->       sb VARCHAR(100) PATH "$.b",
        ->
        ->       ja JSON PATH "$.a",
        ->       jb JSON PATH "$.b"
        ->     )
        ->   ) AS  jt1;
    +-------+------+------+------+------+------+--------+
    | rowid | xa   | xb   | sa   | sb   | ja   | jb     |
    +-------+------+------+------+------+------+--------+
    |     1 |    1 |    1 | 3    | 0    | 3    | "0"    |
    |     2 |    1 |    1 | 3    | 1    | "3"  | "1"    |
    |     3 |    1 |    1 | 2    | 1    | 2    | 1      |
    |     4 |    1 |    0 | 0    | NULL | 0    | NULL   |
    |     5 |    0 |    1 | NULL | NULL | NULL | [1, 2] |
    +-------+------+------+------+------+------+--------+
    ```

    JSON源表达式可以是任何生成有效JSON文档的表达式，包括JSON文字、表列或返回JSON的函数调用，例如JSON_EXTRACT(t1, data, '$.post.comments')。有关更多信息，请参见第12.17.6节“JSON表函数”。

- 数据类型支持。MySQL现在支持在数据类型规范中使用表达式作为默认值。这包括以前无法为BLOB、TEXT、GEOMETRY和JSON数据类型分配默认值的情况。有关详细信息，请参见第11.6节“数据类型默认值”。

- 优化器。增加了以下优化器增强功能：

  - MySQL现在支持不可见索引。不可见索引根本不被优化器使用，但是仍然以正常方式进行维护。索引默认是可见的。不可见索引使得可以在不进行破坏性更改的情况下测试删除索引对查询性能的影响，如果索引确实被需要，就无需撤销更改。请参见第8.3.12节“不可见索引”。

  - MySQL现在支持降序索引：索引定义中的DESC不再被忽略，而是导致键值以降序存储。以前，索引可以以相反的顺序进行扫描，但会带来性能损失。降序索引可以以正序进行扫描，这更高效。降序索引还使得优化器可以在最高效的扫描顺序中使用多列索引，其中一些列按升序排列，其他列按降序排列。请参见第8.3.13节“降序索引”。

  - MySQL现在支持创建函数索引键部分，此类部分索引表达式值而不是列值。函数键部分使得可以索引无法用其他方式索引的值，例如JSON值。有关详细信息，请参见第13.1.15节“CREATE INDEX语句”。

  - 在MySQL 8.0.14及更高版本中，常量文字表达式引起的琐碎WHERE条件将在准备阶段删除，而不是在优化阶段删除。在进程的早期删除条件使得可以简化具有琐碎条件的外连接查询的连接操作，例如以下查询：

    ```mysql
    SELECT * FROM t1 LEFT JOIN t2 ON *condition_1* WHERE *condition_2* OR 0 = 1
    ```

    优化器在准备阶段现在可以看到0 = 1始终为假，因此OR 0 = 1是多余的，并将其删除，留下以下内容：

    ```mysql
    SELECT * FROM t1 LEFT JOIN t2 ON condition_1 where condition_2
    ```

    现在，优化器可以将查询重写为内连接，如下所示：

    ```mysql
    SELECT * FROM t1 LEFT JOIN t2 WHERE condition_1 AND condition_2
    ```

    有关更多信息，请参见第8.2.1.9节“外连接优化”。

  - 在MySQL 8.0.16及更高版本中，MySQL可以在优化时使用常数折叠来处理列与常数值之间的比较，其中常数超出范围或位于与列类型相关的范围边界上，而不是在执行时针对每一行进行处理。例如，给定一个具有TINYINT UNSIGNED列c的表t，优化器可以将条件重写为WHERE c < 256为WHERE 1（完全优化掉条件），或者将WHERE c >= 255重写为WHERE c = 255。

    有关更多信息，请参见“8.2.1.14节，常数折叠优化”。

  - 从MySQL 8.0.16开始，与IN子查询一起使用的半连接优化现在也可以应用于EXISTS子查询。此外，优化器现在解开与子查询附加的WHERE条件中的无关联的等式谓识别，使其可以像IN子查询中的表达式一样处理。这适用于EXISTS和IN子查询。\

    有关更多信息，请参见“8.2.2.1节，使用半连接转换优化IN和EXISTS子查询谓识别”。

  - 从MySQL 8.0.17开始，服务器在上下文化阶段内部将任何不完整的SQL谓识别（即具有形式WHERE value的谓识别，其中value是列名或常数表达式并且没有使用比较运算符）重写为WHERE value <> 0，以便查询解析器，查询优化器和查询执行器仅需要处理完整的谓识别。

    此更改的一个可见影响是，对于布尔值，EXPLAIN输出现在显示true和false，而不是1和0。

    此更改的另一个影响是，在SQL布尔上下文中评估JSON值时，会对JSON整数0进行隐式比较。考虑以下创建和填充的表：

    ```mysql
    mysql> CREATE TABLE test (id INT, col JSON);
    
    mysql> INSERT INTO test VALUES (1, '{"val":true}'), (2, '{"val":false}');
    ```

    以前，当在SQL布尔上下文中比较提取的true或false值时，服务器会尝试将其转换为SQL布尔，如下面使用IS TRUE的查询所示：

    ```mysql
    mysql> SELECT id, col, col->"$.val" FROM test WHERE col->"$.val" IS TRUE;
    
    +------+---------------+--------------+
    | id   | col           | col->"$.val" |
    +------+---------------+--------------+
    |    1 | {"val": true} | true         |
    +------+---------------+--------------+
    ```

    在MySQL 8.0.17及更高版本中，提取的值与JSON整数0的隐式比较导致不同的结果：

    ```
    mysql> SELECT id, col, col->"$.val" FROM test WHERE col->"$.val" IS TRUE;
    +------+----------------+--------------+
    | id   | col            | col->"$.val" |
    +------+----------------+--------------+
    |    1 | {"val": true}  | true         |
    |    2 | {"val": false} | false        |
    +------+----------------+--------------+
    
    ```

    从MySQL 8.0.21开始，您可以在执行测试之前使用JSON_VALUE()对提取的值进行类型转换，如下所示：

    ```
    mysql> SELECT id, col, col->"$.val" FROM test
        ->     WHERE JSON_VALUE(col, "$.val" RETURNING UNSIGNED) IS TRUE;
    +------+---------------+--------------+
    | id   | col           | col->"$.val" |
    +------+---------------+--------------+
    |    1 | {"val": true} | true         |
    +------+---------------+--------------+
    
    ```

    从MySQL 8.0.21开始，服务器提供警告“在SQL布尔上下文中评估JSON值会隐式与JSON整数0进行比较；如果这不是您想要的，请考虑在以这种方式在SQL布尔上下文中比较提取的值时，使用JSON_VALUE RETURNING将JSON转换为SQL数值类型”。

    在MySQL 8.0.17及更高版本中，具有NOT IN（子查询）或NOT EXISTS（子查询）的WHERE条件在MySQL 8.0.17及更高版本中被内部转换为反连接（antijoin）。反连接返回表中没有与连接条件匹配的行的所有行。这样可以删除子查询，从而加快查询执行速度，因为子查询的表现在在顶层进行处理。

    这类似于外连接的IS NULL（不存在）优化，详见EXPLAIN附加信息。

    从MySQL 8.0.21开始，许多情况下，单表UPDATE或DELETE语句现在可以使用半连接转换或子查询材料化。适用于以下形式的语句：

    - UPDATE t1 SET t1.a=value WHERE t1.a IN (SELECT t2.a FROM t2)
    - DELETE FROM t1 WHERE t1.a IN (SELECT t2.a FROM t2)

    可以为满足以下条件的单表UPDATE或DELETE执行此操作：

    - UPDATE或DELETE语句使用具有[NOT] IN或[NOT] EXISTS谓识别的子查询。

    - 语句没有ORDER BY子句，也没有LIMIT子句。

      （多表版本的UPDATE和DELETE不支持ORDER BY或LIMIT。）

    - 目标表不支持读取前写入删除（仅与NDB表相关）。

    - 半连接或子查询材料化是允许的，基于子查询中的任何提示以及optimizer_switch的值。

    当对合格的单表DELETE或UPDATE使用半连接优化时，这在优化器跟踪中可见：对于多表语句，跟踪中有一个join_optimization对象，而对于单表语句则没有。转换还可在EXPLAIN FORMAT=TREE或EXPLAIN ANALYZE的输出中可见；单表语句显示<not executable by iterator executor>，而多表语句报告完整计划。

    从MySQL 8.0.21开始，使用InnoDB表的多表UPDATE语句支持半一致性读取，事务隔离级别低于REPEATABLE READ。

  - **改进的哈希连接性能。**MySQL 8.0.23重新实现了用于哈希连接的哈希表，从而改善了哈希连接的性能。此工作包括修复了一个问题（Bug #31516149，Bug #99933），即哈希连接只能使用连接缓冲区（join_buffer_size）分配的大约2/3的内存。

    新的哈希表通常比旧的哈希表更快，并且在对齐、键/值以及存在许多相等键的情况下使用更少的内存。此外，当哈希表的大小增加时，服务器现在可以释放旧的内存。

- **通用表达式（CTE）**。MySQL现在支持通用表达式，包括非递归和递归的。通用表达式允许使用命名的临时结果集，通过在SELECT语句和某些其他语句之前允许使用WITH子句来实现。有关更多信息，请参见“13.2.20节，WITH（通用表达式）”。

  从MySQL 8.0.19开始，递归通用表达式（CTE）的递归SELECT部分支持LIMIT子句。还支持带有OFFSET的LIMIT。有关更多信息，请参见递归通用表达式。

- **窗口函数**。MySQL现在支持窗口函数，它们对于查询的每一行都使用与该行相关的行进行计算。这些函数包括RANK()、LAG()和NTILE()等函数。此外，现在可以将几个现有的聚合函数用作窗口函数（例如SUM()和AVG()）。有关更多信息，请参见“12.20节，窗口函数”。

- 侧向派生表。派生表现在可以在之前加上LATERAL关键字，以指定它可以引用（依赖于）同一FROM子句中之前表的列。侧向派生表使得可能进行某些不能使用非侧向派生表完成的SQL操作，或者需要使用效率较低的解决方法。请参见“13.2.15.9节，侧向派生表”。

- **单表DELETE语句中的别名**。在MySQL 8.0.16及更高版本中，单表DELETE语句支持使用表别名。

- **正则表达式支持**。以前，MySQL使用Henry Spencer正则表达式库来支持正则表达式运算符（REGEXP，RLIKE）。现在，使用国际组件Unicode（ICU）重新实现了正则表达式支持，它提供了完整的Unicode支持，并且是多字节安全的。REGEXP_LIKE()函数以REGEXP和RLIKE运算符的方式执行正则表达式匹配，这两个运算符现在是该函数的同义词。此外，还提供了REGEXP_INSTR()、REGEXP_REPLACE()和REGEXP_SUBSTR()函数，用于查找匹配位置、执行子字符串替换和提取。regexp_stack_limit和regexp_time_limit系统变量可控制匹配引擎的资源消耗。有关更多信息，请参见“12.8.2节，正则表达式”。有关使用正则表达式的应用程序可能受到实现更改影响的方式，请参见正则表达式兼容性注意事项。

- **内部临时表**。TempTable存储引擎取代了MEMORY存储引擎，成为内存中内部临时表的默认引擎。TempTable存储引擎为VARCHAR和VARBINARY列提供了高效的存储。internal_tmp_mem_storage_engine会话变量定义了内存中内部临时表的存储引擎。允许的值为TempTable（默认值）和MEMORY。temptable_max_ram变量定义了TempTable存储引擎在数据存储到磁盘之前可以使用的最大内存量。

日志记录。这些增强功能是为了改进日志记录而添加的：

错误日志记录已重写为使用MySQL组件架构。传统的错误日志记录是使用内置组件实现的，并且使用系统日志进行的日志记录是作为可加载组件实现的。此外，还提供了可加载的JSON日志写入器。有关更多信息，请参见“5.4.2节，错误日志”。

从MySQL 8.0.30开始，在InnoDB存储引擎可用之前可以隐式加载错误日志组件。通过这种新的加载错误日志组件的方法，可以加载和启用由log_error_services变量定义的组件。

以前，必须首先使用INSTALL COMPONENT安装错误日志组件，并且只能在InnoDB完全可用后加载，因为要加载的组件列表是从mysql.components表中读取的，该表是一个InnoDB表。

隐式加载错误日志组件具有以下优点：

日志组件在启动序列中较早加载，使得日志信息更早可用。

它有助于避免在启动过程中发生故障时丢失缓冲的日志信息。

不需要使用INSTALL COMPONENT加载日志组件，简化了错误日志配置。

仍然支持使用INSTALL COMPONENT显式加载日志组件的方法，以实现向后兼容。

有关更多信息，请参见“5.4.2.1节，错误日志配置”。

备份锁定。一种新类型的备份锁定允许在线备份期间进行DML操作，同时防止可能导致不一致快照的操作。新的备份锁定由LOCK INSTANCE FOR BACKUP和UNLOCK INSTANCE语法支持。使用这些语句需要BACKUP_ADMIN权限。

复制。对MySQL复制进行了以下增强：

MySQL复制现在支持对JSON文档的部分更新进行二进制日志记录，使用紧凑的二进制格式，在日志中节省了空间，而不是对完整的JSON文档进行日志记录。当使用基于语句的日志记录时，自动进行紧凑日志记录，并且可以通过将新的binlog_row_value_options系统变量设置为PARTIAL_JSON来启用。有关更多信息，请参见Partial Updates of JSON Values，以及binlog_row_value_options的描述。

连接管理。MySQL服务器现在允许为管理连接专门配置TCP/IP端口。这为普通连接使用的网络接口上允许的单个管理连接提供了一种替代方法，即使已经建立了max_connections个连接。请参见“5.1.12.1节，连接接口”。

MySQL现在提供了更多对使用压缩来减少发送到服务器的字节数的控制。以前，给定的连接要么是未压缩的，要么使用zlib压缩算法。现在，还可以使用zstd算法，并为zstd连接选择压缩级别。可以在服务器端进行配置允许的压缩算法，以及在连接的发起端进行配置，用于客户端程序连接和参与源/副本复制或组复制的服务器。有关更多信息，请参见“4.2.8节，连接压缩控制”。

配置。MySQL中主机名的最大允许长度已从先前的60个字符增加到255个ASCII字符。这适用于数据字典、mysql系统模式、性能模式、INFORMATION_SCHEMA和sys模式中的主机名相关列；CHANGE MASTER TO语句的MASTER_HOST值；SHOW PROCESSLIST语句输出中的Host列；帐户名称中的主机名（例如在帐户管理语句和DEFINER属性中使用）；以及主机名相关的命令选项和系统变量。

注意事项：

允许主机名长度的增加可能会影响在主机名列上具有索引的表。例如，在mysql系统模式中索引主机名的表现在具有显式的ROW_FORMAT属性为DYNAMIC，以适应更长的索引值。

一些文件名值的配置设置可能是基于服务器主机名构建的。允许的值受底层操作系统的限制，该操作系统可能不允许文件名足够长以包括255个字符的主机名。这会影响general_log_file、log_error、pid_file、relay_log和slow_query_log_file系统变量和相应选项。如果基于主机名的值对于操作系统来说太长，则必须提供显式更短的值。

虽然服务器现在支持255个字符的主机名，但使用--ssl-mode=VERIFY_IDENTITY选项建立的与服务器的连接受到OpenSSL支持的最大主机名长度的限制。主机名匹配涉及SSL证书的两个字段，其最大长度如下：Common Name：最大长度64；Subject Alternative Name：根据RFC#1034的最大长度。

插件。以前，MySQL插件可以用C或C++编写。现在，插件使用的MySQL头文件包含了C++代码，这意味着插件必须用C++而不是C编写。

C API。MySQL C API现在支持用于与MySQL服务器进行非阻塞通信的异步函数。每个函数是现有同步函数的异步对应函数。如果从服务器连接读取或写入必须等待，同步函数会阻塞。异步函数使应用程序能够检查服务器连接上的工作是否准备好进行。如果没有准备好，应用程序可以在稍后再次检查之前执行其他工作。请参见C API Asynchronous Interface。

类型转换的其他目标类型。函数CAST()和CONVERT()现在支持转换为DOUBLE、FLOAT和REAL类型。在MySQL 8.0.17中添加。请参见“12.10节，转换函数和运算符”。

JSON模式验证。MySQL 8.0.17添加了两个函数JSON_SCHEMA_VALID()和JSON_SCHEMA_VALIDATION_REPORT()，用于根据JSON模式验证JSON文档。JSON_SCHEMA_VALID()如果文档符合模式，则返回TRUE（1），如果不符合，则返回FALSE（0）。JSON_SCHEMA_VALIDATION_REPORT()返回包含验证结果详细信息的JSON文档。以下语句适用于这两个函数：

模式必须符合JSON模式规范的Draft 4。

支持required属性。

不支持外部资源和$ref关键字。

支持正则表达式模式；无效的模式将被静默忽略。

有关更多信息和示例，请参见“12.17.7节，JSON模式验证函数”。
