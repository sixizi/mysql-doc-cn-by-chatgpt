### 15.7.4 幻影行

所谓的幻影问题是指在事务中，同一查询在不同时间产生不同的行集合的情况。例如，如果一个SELECT查询被执行了两次，但第二次返回了第一次未返回的行，这个新出现的行就是“幻影”行。

假设child表的id列上有一个索引，您想读取并锁定表中所有标识符值大于100的行，以便稍后更新所选行中的某些列：

```sql
SELECT * FROM child WHERE id > 100 FOR UPDATE;
```

该查询从id大于100的第一条记录开始扫描索引。假设表中包含id值为90和102的行。如果在扫描范围内设置的索引记录上的锁没有锁定在间隙中进行的插入（在这种情况下，是90和102之间的间隙），另一个会话可以在表中插入一个id为101的新行。如果您在同一事务中执行相同的SELECT，您会在查询返回的结果集中看到一个id为101的新行（一个“幻影”）。如果我们将一组行视为一个数据项，那么新的幻影子行会违反事务的隔离原则，即事务应该能够运行，以便在事务期间读取的数据不会更改。

为了防止幻影，InnoDB使用一种称为下一个键锁定的算法，该算法结合了索引行锁定和间隙锁定。InnoDB执行行级锁定，以便在搜索或扫描表索引时，对其遇到的索引记录设置共享或排他锁。因此，行级锁实际上是索引记录锁。此外，索引记录上的下一个键锁还会影响该索引记录之前的“间隙”。也就是说，下一个键锁是索引记录锁加上在索引记录之前的间隙上的间隙锁。如果一个会话在索引中的记录R上有共享或排他锁，另一个会话不能在索引顺序中R之前的间隙中插入新的索引记录。

当InnoDB扫描索引时，它还可以锁定索引中最后一条记录后的间隙。就像前面的例子一样：为了防止任何插入到表中id大于100的行，InnoDB设置的锁包括锁定id值102之后的间隙。

您可以使用下一个键锁定在应用程序中实现唯一性检查：如果您在共享模式下读取数据并且在准备插入的行中没有看到重复项，那么您可以安全地插入您的行，并知道在读取期间设置在您行的后继上的下一个键锁阻止了其他人同时插入您行的重复项。因此，下一个键锁定使您能够“锁定”表中某物的不存在。

正如第15.7.1节“InnoDB锁定”中讨论的，可以禁用间隙锁定。这可能会导致幻影问题，因为当禁用间隙锁定时，其他会话可以在间隙中插入新行。