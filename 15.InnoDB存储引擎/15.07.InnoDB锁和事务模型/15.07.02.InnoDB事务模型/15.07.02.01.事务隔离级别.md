#### 15.7.2.1 事务隔离级别

事务隔离是数据库处理的基础之一。隔离是ACID（原子性、一致性、隔离性、持久性）首字母缩写中的"I"；隔离级别是调整性能与当多个事务同时进行更改和执行查询时结果的可靠性、一致性和可复现性之间平衡的设置。

InnoDB 提供了SQL:1992标准描述的所有四种事务隔离级别：未提交读（READ UNCOMMITTED）、已提交读（READ COMMITTED）、可重复读（REPEATABLE READ）和可串行化（SERIALIZABLE）。InnoDB的默认隔离级别是可重复读。

用户可以通过 `SET TRANSACTION` 语句更改单个会话或所有后续连接的隔离级别。要设置服务器所有连接的默认隔离级别，请在命令行或选项文件中使用 `--transaction-isolation` 选项。有关隔离级别和设置语法的详细信息，请参阅第13.3.7节，“SET TRANSACTION语句”。

InnoDB使用不同的锁定策略支持这里描述的每个事务隔离级别。您可以使用默认的可重复读级别强制执行高度一致性，这对于关键数据操作非常重要，因为需要符合ACID。或者，在像批量报告这样的情况下，您可以使用已提交读甚至未提交读放松一致性规则，在这些情况下，精确的一致性和可重复结果不如最小化锁定开销重要。可串行化实施比可重复读更严格的规则，主要用于特殊情况，如XA事务和处理并发和死锁问题。

以下列表描述了MySQL如何支持不同的事务级别。该列表从最常用的级别到最不常用的级别排列。

##### 可重复读

这是InnoDB的默认隔离级别。同一事务内的一致读取读取由第一次读取建立的快照。这意味着，如果您在同一事务中发出多个普通（非锁定）SELECT语句，这些SELECT语句也相互一致。请参见第15.7.2.3节，“一致的非锁定读取”。

对于锁定读取（带有FOR UPDATE或FOR SHARE的SELECT）、UPDATE和DELETE语句，锁定取决于语句是否使用具有唯一搜索条件的唯一索引，或范围类型搜索条件。

对于具有唯一搜索条件的唯一索引，InnoDB只锁定找到的索引记录，而不是它之前的间隙。

对于其他搜索条件，InnoDB锁定扫描的索引范围，使用间隙锁或下一个键锁阻止其他会话向范围覆盖的间隙中插入。有关间隙锁和下一个键锁的信息，请参阅第15.7.1节，“InnoDB锁定”。

##### 已提交读

即使在同一事务中，每次一致读取也会设置并读取自己的新快照。有关一致读取的信息，请参见第15.7.2.3节，“一致的非锁定读取”。

对于锁定读取（带有FOR UPDATE或FOR SHARE的SELECT）、UPDATE语句和DELETE语句，InnoDB只锁定索引记录，而不是它们之前的间隙，因此允许在锁定记录旁边自由插入新记录。间隙锁定仅用于外键约束检查和重复键检查。

由于间隙锁定被禁用，可能会出现幻影行问题，因为其他会话可以向间隙中插入新行。有关幻影行的信息，请参见第15.7.4节，“幻影行”。

只有在已提交读隔离级别下，才支持基于行的二进制日志记录。如果您在binlog_format=MIXED下使用已提交读，服务器会自动使用基于行的日志记录。

使用已提交读还有额外的影响：

- 对于UPDATE或DELETE语句，InnoDB只为其更新或删除的行保持锁定。在MySQL评估WHERE条件后，非匹配行的记录锁被释放。这大大减少了死锁的可能性，但仍然可能发生。

- 对于UPDATE语句，如果某行已被锁定，InnoDB执行“半一致”读取，将最新的提交版本返回给MySQL，以便MySQL可以确定该行是否符合UPDATE的WHERE条件。如果行匹配（必须更新），MySQL再次读取该行，这次InnoDB要么锁定它，要么等待对其加锁。


考虑以下示例，从这个表开始：

```sql
CREATE TABLE t (a INT NOT NULL, b INT) ENGINE = InnoDB;
INSERT INTO t VALUES (1,2),(2,3),(3,2),(4,3),(5,2);
COMMIT;
```

在这种情况下，表没有索引，因此搜索和索引扫描使用隐藏的聚簇索引进行记录锁定（请参阅第15.6.2.1节，“聚簇和辅助索引”），而不是索引列。

假设一个会话使用以下语句执行UPDATE：

```sql
# 会话 A
START TRANSACTION;
UPDATE t SET b = 5 WHERE b = 3;
```

假设另一个会话在第一个会话之后执行这些语句进行UPDATE：

```sql
# 会话 B
UPDATE t SET b = 4 WHERE b = 2;
```

当InnoDB执行每个UPDATE时，它首先为每行获取一个排他锁，然后决定是否修改它。如果InnoDB不修改该行，它会释放锁。否则，InnoDB会保留锁直到事务结束。这对事务处理有以下影响。

使用默认的可重复读隔离级别时，第一个UPDATE为它读取的每一行获取一个x-lock，并且不释放任何锁：

```sql
x-lock(1,2); 保留 x-lock
x-lock(2,3); 将 (2,3) 更新为 (2,5); 保留 x-lock
x-lock(3,2); 保留 x-lock
x-lock(4,3); 将 (4,3) 更新为 (4,5); 保留 x-lock
x-lock(5,2); 保留 x-lock
```

第二个UPDATE一旦尝试获取任何锁（因为第一个更新保留了所有行的锁），就会被阻塞，直到第一个UPDATE提交或回滚：

```sql
x-lock(1,2); 阻塞并等待第一个UPDATE提交或回滚
```

如果改用已提交读，则第一个UPDATE会为它读取的每一行获取一个x-lock，并释放那些未修改的行的锁：

```sql
x-lock(1,2); 解锁(1,2)
x-lock(2,3); 将 (2,3) 更新为 (2,5); 保留 x-lock
x-lock(3,2); 解锁(3,2)
x-lock(4,3); 将 (4,3) 更新为 (4,5); 保留 x-lock
x-lock(5,2); 解锁(5,2)
```

对于第二个UPDATE，InnoDB执行“半一致”读取，将每一行的最新提交版本返回给MySQL，以便MySQL可以确定该行是否符合UPDATE的WHERE条件：

```sql
x-lock(1,2
```

```markdown
); 更新 (1,2) 为 (1,4); 保留 x-lock
x-lock(2,3); 解锁(2,3)
x-lock(3,2); 更新 (3,2) 为 (3,4); 保留 x-lock
x-lock(4,3); 解锁(4,3)
x-lock(5,2); 更新 (5,2) 为 (5,4); 保留 x-lock
```

然而，如果 WHERE 条件包含一个索引列，并且 InnoDB 使用该索引，那么只有在获取和保留记录锁时才考虑索引列。在下面的示例中，第一个 UPDATE 获取并保留 b = 2 的每一行的 x-lock。当第二个 UPDATE 尝试获取相同记录的 x-lock 时，它会被阻塞，因为它也使用了定义在列 b 上的索引。

```sql
CREATE TABLE t (a INT NOT NULL, b INT, c INT, INDEX (b)) ENGINE = InnoDB;
INSERT INTO t VALUES (1,2,3),(2,2,4);
COMMIT;

# 会话 A
START TRANSACTION;
UPDATE t SET b = 3 WHERE b = 2 AND c = 3;

# 会话 B
UPDATE t SET b = 4 WHERE b = 2 AND c = 4;
```

已提交读隔离级别可以在启动时设置或在运行时更改。在运行时，它可以为所有会话全局设置，或者为每个会话单独设置。

##### 未提交读

SELECT 语句以非锁定方式执行，但可能使用行的早期版本。因此，使用此隔离级别时，此类读取是不一致的。这也称为脏读。在其他方面，此隔离级别的工作方式类似于已提交读。

##### 可串行化

这个级别类似于可重复读，但如果禁用了自动提交，InnoDB 隐式地将所有普通的 SELECT 语句转换为 SELECT ... FOR SHARE。如果启用了自动提交，SELECT 是它自己的事务。因此它被认为是只读的，并且如果以一致的（非锁定）读方式执行，可以被串行化，无需阻塞其他事务。 （要强制普通 SELECT 在其他事务修改了所选行时阻塞，请禁用自动提交。）

> **注意**
>
> 从 MySQL 8.0.22 开始，从 MySQL 授权表中读取数据（通过连接列表或子查询）但不修改它们的 DML 操作不会获取 MySQL 授权表上的读锁，无论隔离级别如何。有关更多信息，请参阅授权表并发。