#### 15.7.2.3 一致的非锁定读取

一致读表示InnoDB使用多版本控制为查询提供数据库在某一时间点的快照。查询可以看到在该时间点之前提交的事务所做的更改，但看不到之后或未提交的事务所做的更改。这个规则的例外是，查询可以看到同一事务中较早语句所做的更改。这个例外导致以下异常：如果您在表中更新了一些行，SELECT语句可以看到更新行的最新版本，但它可能也看到任何行的旧版本。如果其他会话同时更新同一表，这种异常意味着您可能看到数据库中从未存在过的表状态。

如果事务隔离级别为可重复读（默认级别），同一事务内的所有一致读取都读取该事务中第一次此类读取建立的快照。通过提交当前事务然后发出新查询，您可以为查询获取更新的快照。

在已提交读隔离级别下，事务中的每次一致读取都设置并读取自己的新快照。

在已提交读和可重复读隔离级别下，一致读是InnoDB处理SELECT语句的默认模式。一致读不对其访问的表设置任何锁，因此其他会话可以在对表执行一致读时同时修改这些表。

假设您正在默认的可重复读隔离级别中运行。当您发出一致读（即普通的SELECT语句）时，InnoDB会根据您的查询看到数据库的时间点给您的事务分配一个时间点。如果另一个事务在分配给您的时间点之后删除一行并提交，您不会看到该行被删除。插入和更新的处理方式类似。

> **注意**
>
> 数据库状态的快照适用于事务中的SELECT语句，不一定适用于DML语句。如果您插入或修改了一些行然后提交该事务，另一个并发的可重复读事务发出的DELETE或UPDATE语句可能会影响那些刚刚提交的行，即使该会话无法查询它们。如果一个事务确实更新或删除了由不同事务提交的行，这些更改确实会对当前事务可见。例如，您可能遇到以下情况：
>
> ```sql
> SELECT COUNT(c1) FROM t1 WHERE c1 = 'xyz';
> -- 返回 0：没有行匹配。
> DELETE FROM t1 WHERE c1 = 'xyz';
> -- 删除了其他事务最近提交的几行。
> 
> SELECT COUNT(c2) FROM t1 WHERE c2 = 'abc';
> -- 返回 0：没有行匹配。
> UPDATE t1 SET c2 = 'cba' WHERE c2 = 'abc';
> -- 影响了 10 行：另一个事务刚刚提交了带有 'abc' 值的 10 行。
> SELECT COUNT(c2) FROM t1 WHERE c2 = 'cba';
> -- 返回 10：这个事务现在可以看到它刚刚更新的行。
> ```
>
> 您可以通过提交事务然后进行另一个SELECT或START TRANSACTION WITH CONSISTENT SNAPSHOT来推进您的时间点。
>

这被称为多版本并发控制。

在以下示例中，会话A只有在B提交插入并且A也提交后，才能看到B插入的行，这样时间点就超过了B的提交。

```mysql
             会话 A              会话 B

           SET autocommit=0;      SET autocommit=0;
时间
|          SELECT * FROM t;
|          空集
|                                 INSERT INTO t VALUES (1, 2);
|
v          SELECT * FROM t;
           空集
                                  COMMIT;

           SELECT * FROM t;
           空集

           COMMIT;

           SELECT * FROM t;
           ---------------------
           |    1    |    2    |
           ---------------------
```

如果您想看到数据库的“最新”状态，请使用已提交读隔离级别或锁定读取：

```sql
SELECT * FROM t FOR SHARE;
```

在已提交读隔离级别下，事务中的每次一致读取都设置并读取自己的新快照。使用FOR SHARE时，发生锁定读取：SELECT会阻塞，直到包含最新行的事务结束（参见第15.7.2.4节，“锁定读取”）。

一致读不适用于某些DDL语句：

- 一致读不适用于`DROP TABLE`，因为MySQL无法使用已被删除的表，而InnoDB销毁该表。
- 一致读不适用于进行了临时复制原始表并在临时副本建立时删除原始表的ALTER TABLE操作。当您在事务中重新发出一致读时，新表中的行不可见，因为那些行在事务快照拍摄时不存在。在这种情况下，事务返回一个错误：`ER_TABLE_DEF_CHANGED`，“表定义已更改，请重试事务”。

对于像INSERT INTO ... SELECT、UPDATE ... (SELECT)和CREATE TABLE ... SELECT这样的子句中的选择，如果没有指定FOR UPDATE或FOR SHARE，则读取类型不同：

- 默认情况下，InnoDB对这些语句使用更强的锁，SELECT部分的行为类似于已提交读，即使在同一事务中，每次一致读取也都设置并读取自己的新快照。
- 为了在这些情况下执行非锁定读取，设置事务的隔离级别为未提交读或已提交读，以避免在从所选表中读取的行上设置锁。