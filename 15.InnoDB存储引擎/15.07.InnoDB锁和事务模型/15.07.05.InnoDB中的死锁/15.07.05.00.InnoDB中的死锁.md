### 15.7.5 InnoDB中的死锁

- [15.7.5.1 InnoDB死锁示例](./15.07.05.01.InnoDB死锁示例.md)
- [15.7.5.2 死锁检测](./15.07.05.02.死锁检测.md)
- [15.7.5.3 如何最小化和处理死锁](./15.07.05.03.如何最小化和处理死锁.md)

死锁是指不同事务无法继续执行的情况，因为每个事务都持有另一个事务所需的锁。由于两个事务都在等待资源变得可用，它们都不会释放所持有的锁。

当事务在多个表中锁定行（通过如`UPDATE`或SELECT ... FOR UPDATE之类的语句）但以相反的顺序时，可能会发生死锁。当此类语句锁定索引记录和间隙的范围时，也可能发生死锁，每个事务由于时间问题获取一些锁但不获取其他锁。有关死锁的示例，请参阅第15.7.5.1节，“InnoDB死锁示例”。

为了减少死锁的可能性，请使用事务而不是`LOCK TABLES`语句；保持插入或更新数据的事务足够小，以便它们不会长时间保持打开状态；当不同的事务更新多个表或大量行时，使用相同的操作顺序（例如SELECT ... FOR UPDATE）；在`SELECT ... FOR UPDATE`和UPDATE ... WHERE语句中使用的列上创建索引。死锁的可能性不受隔离级别的影响，因为隔离级别改变了读操作的行为，而死锁发生是因为写操作。有关避免和从死锁状态中恢复的更多信息，请参阅第15.7.5.3节，“如何最小化和处理死锁”。

当启用死锁检测（默认情况）并且发生死锁时，InnoDB会检测到这种情况并回滚其中一个事务（受害者）。如果使用`innodb_deadlock_detect`变量禁用死锁检测，InnoDB依赖于`innodb_lock_wait_timeout`设置在发生死锁的情况下回滚事务。因此，即使您的应用程序逻辑是正确的，您仍然必须处理必须重试事务的情况。要查看InnoDB用户事务中的最后一个死锁，请使用`SHOW ENGINE INNODB STATUS`。如果频繁发生死锁突出显示了事务结构或应用程序错误处理的问题，请启用innodb_print_all_deadlocks将有关所有死锁的信息打印到mysqld错误日志。有关如何自动检测和处理死锁的更多信息，请参阅第15.7.5.2节，“死锁检测”。