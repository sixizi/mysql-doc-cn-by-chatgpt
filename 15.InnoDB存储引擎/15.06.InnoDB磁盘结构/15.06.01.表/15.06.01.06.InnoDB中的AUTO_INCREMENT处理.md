#### 15.6.1.6 InnoDB中的AUTO_INCREMENT处理

InnoDB提供了一个可配置的锁定机制，可以显著提高向带有AUTO_INCREMENT列的表中添加行的SQL语句的可伸缩性和性能。要在InnoDB表中使用AUTO_INCREMENT机制，必须将AUTO_INCREMENT列定义为某些索引的第一个或唯一列，以便能够执行相当于对表进行索引的SELECT MAX(ai_col)查找以获得最大列值。该索引不必是PRIMARY KEY或UNIQUE，但为避免AUTO_INCREMENT列中的重复值，建议使用这些索引类型。

本节描述了AUTO_INCREMENT锁定模式、不同AUTO_INCREMENT锁定模式设置的使用含义，以及InnoDB如何初始化AUTO_INCREMENT计数器。

##### InnoDB AUTO_INCREMENT锁定模式

这部分描述了用于生成自增值的AUTO_INCREMENT锁定模式，以及每种锁定模式对复制的影响。自增锁定模式在启动时使用`innodb_autoinc_lock_mode`变量配置。

描述`innodb_autoinc_lock_mode`设置时使用以下术语：

- “INSERT-like”语句

  所有在表中生成新行的语句，包括INSERT, INSERT ... SELECT, REPLACE, REPLACE ... SELECT和LOAD DATA。包括“简单插入”，“批量插入”和“混合模式”插入。

- “简单插入”

  那些可以提前确定要插入的行数的语句（在语句最初处理时）。这包括单行和多行INSERT和REPLACE语句，但不包括嵌套子查询的INSERT ... ON DUPLICATE KEY UPDATE。

- “批量插入”

  那些无法提前知道要插入的行数（和所需的自增值数量）的语句。这包括INSERT ... SELECT, REPLACE ... SELECT和LOAD DATA语句，但不包括普通INSERT。InnoDB在处理每行时逐个分配AUTO_INCREMENT列的新值。

- “混合模式插入”

  这些是为新行的一部分（但不是全部）指定自增值的“简单插入”语句。以下是一个示例，其中c1是表t1的AUTO_INCREMENT列：

  ```sql
  INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
  ```

  另一种“混合模式插入”是INSERT ... ON DUPLICATE KEY UPDATE，其在最坏情况下相当于一个INSERT后跟一个UPDATE，其中分配的AUTO_INCREMENT列的值在更新阶段可能会也可能不会被使用。

`innodb_autoinc_lock_mode`变量有三种可能的设置：0、1或2，分别代表“传统”、“连续”或“交错”锁定模式。在MySQL 8.0中，默认设置为交错锁定模式（`innodb_autoinc_lock_mode=2`）。在MySQL 8.0之前，默认为连续锁定模式（`innodb_autoinc_lock_mode=1`）。

MySQL 8.0中交错锁定模式的默认设置反映了从基于语句的复制到基于行的复制作为默认复制类型的变化。基于语句的复制需要连续的自增锁定模式，以确保自增值以可预测和可重复的顺序分配给一系列SQL语句，而基于行的复制对SQL语句的执行顺序不敏感。

- `innodb_autoinc_lock_mode = 0`（“传统”锁定模式）

  传统锁定模式提供与引入`innodb_autoinc_lock_mode`变量之前存在的相同行为。传统锁定模式选项用于向后兼容、性能测试，以及解决由于可能的语义差异而导致的“混合模式插入”问题。

  在此锁定模式下，所有“INSERT-like”语句都会为插入到带有AUTO_INCREMENT列的表中的行获取特殊的表级AUTO-INC锁。这个锁通常保持到语句结束（而不是事务结束），以确保自增值以可预测和可重复的顺序分配给给定序列的INSERT语句，并确保由任何给定语句分配的自增值是连续的。

  在基于语句的复制的情况下，这意味着当SQL语句在复制服务器上复制时，自增列使用与源服务器相同的值。多个INSERT语句执行的结果是确定的，复制服务器复制与源服务器相同的数据。如果由多个INSERT语句生成的自增值是交错的，则两个并发INSERT语句的结果是不确定的，无法使用基于语句的复制可靠地传播到复制服务器。

  为了说明这一点，请考虑使用此表的示例：

  ```sql
  CREATE TABLE t1 (
    c1 INT(11) NOT NULL AUTO_INCREMENT,
    c2 VARCHAR(10) DEFAULT NULL,
    PRIMARY KEY (c1)
  ) ENGINE=InnoDB;
  ```
  
  假设有两个事务正在运行，每个事务都向带有AUTO_INCREMENT列的表中插入行。一个事务使用INSERT ... SELECT语句插入1000行，另一个使用简单的INSERT语句插入一行：

  ```sql
  Tx1: INSERT INTO t1 (c2) SELECT 1000 rows from another table ...
  Tx2: INSERT INTO t1 (c2) VALUES ('xxx');
  ```

  InnoDB无法提前知道在Tx1的INSERT语句中的SELECT中检索到的行数，它在语句进行时逐个分配自增值。使用表级锁，保持到语句结束，一次只能执行一个引用表t1的INSERT语句，并且不同语句生成的自增数不会交错。Tx1的INSERT ... SELECT语句生成的自增值是连续的，Tx2中的INSERT语句使用的（单个）自增值要么小于要么大于Tx1使用的所有值，这取决于哪个语句先执行。
  
  只要SQL语句在从二进制日志重放时按相同顺序执行（在基于语句的复制或恢复场景中使用时），结果与Tx1和Tx2首次运行时相同。因此，保持到语句结束的表级锁使得使用自增的INSERT语句可安全用于基于语句的复制。然而，这些表级锁限制了同时执行插入语句的多个事务的并发性和可伸缩性。
  
  在前面的示例中，如果没有表级锁，Tx2中的INSERT的自增列值取决于语句执行的确切时间。如果Tx2的INSERT在Tx1的INSERT运行时执行（而不是在它开始之前或完成之后），两个INSERT语句分配的具体自增值是不确定的，并且可能会有所不同。
  
  在连续锁定模式下，InnoDB可以避免对“简单插入”语句使用表级AUTO-INC锁，这些语句的插入行数可以提前知道，并且仍然保留确定性执行和对基于语句的复制的安全性。
  
  如果您没有使用二进制日志来重放SQL语句作为恢复或复制的一部分，交错锁定模式可以用来消除所有使用表级AUTO-INC锁，从而实现更大的并发性和性能，但代价是允许由语句分配的自增数中出现间隙，并且可能让同时执行的语句分配的数字交错。

- `innodb_autoinc_lock_mode = 1`（“连续”锁定模式）

  在此模式下，“批量插入”使用特殊的AUTO-INC表级锁并持有它直到语句结束。这适用于所有的INSERT ... SELECT、REPLACE ... SELECT和LOAD DATA语句。只有一个持有AUTO-INC锁的语句可以一次执行。如果批量插入操作的源表与目标表不同，则在从源表选择的第一行上取得共享锁之后，才会在目标表上取得AUTO-INC锁。如果批量插入操作的源和目标是同一张表，则在选择的所有行上取得共享锁之后，才会取得AUTO-INC锁。
  
  对于已知要插入的行数的“简单插入”（提前知道），通过在分配过程中控制互斥锁（一种轻量级锁）来避免使用表级AUTO-INC锁，而不是等到语句完成。除非另一个事务持有AUTO-INC锁，否则不使用表级AUTO-INC锁。如果另一个事务持有AUTO-INC锁，那么“简单插入”就会等待AUTO-INC锁，就好像它是一个“批量插入”。
  
  这种锁定模式确保，在存在提前不知道要插入的行数的INSERT语句（在语句进行时分配自增数）的情况下，任何“INSERT-like”语句分配的所有自增值都是连续的，并且操作对于基于语句的复制是安全的。
  
  简而言之，这种锁定模式在保持对基于语句复制安全使用的同时，显著提高了可伸缩性。此外，与“传统”锁定模式一样，任何给定语句分配的自增数都是连续的。与“传统”模式相比，对于使用自增的任何语句，语义上没有变化，除了一个重要的例外。
  
  这个例外是对于“混合模式插入”，用户为多行“简单插入”的一些（但不是全部）行提供了AUTO_INCREMENT列的显式值。对于这样的插入，InnoDB分配的自增值多于要插入的行数。然而，所有自动分配的值都是连续生成的（因此高于）最近执行的前一个语句生成的自增值。"多余"的数字会丢失。

- `innodb_autoinc_lock_mode = 2`（“交错”锁定模式）

  在这种锁定模式下，没有任何“INSERT-like”语句使用表级AUTO-INC锁，多个语句可以同时执行。这是最快速且最具可伸缩性的锁定模式，但在使用基于语句的复制或恢复场景时，从二进制日志重放SQL语句时不安全。
  
  在这种锁定模式下，自增值对于所有并发执行的“INSERT-like”语句都保证是唯一且单调递增的。然而，由于多个语句可能同时生成数字（即数字的分配在语句之间是交错的），任何给定语句插入的行的值可能不是连续的。
  
  如果仅执行的语句是“简单插入”，其中提前知道要插入的行数，则对于单个语句生成的数字没有间隙，除了“混合模式插入”。然而，当执行“批量插入”时，任何给定语句分配的自增值可能存在间隙。
  
  对于锁定模式1或2，由于对于批量插入，每个语句所需的自增值的确切数量可能无法知道，且可能过高估计，因此在连续的语句之间可能会出现间隙。

##### InnoDB AUTO_INCREMENT 锁模式的使用影响

- 使用自增（AUTO_INCREMENT）与复制

  如果您使用的是基于语句的复制，请将 `innodb_autoinc_lock_mode` 设置为 0 或 1，并在源头和其副本上使用相同的值。如果使用 `innodb_autoinc_lock_mode = 2`（“交错”）或源头和副本使用不同锁模式的配置，无法确保副本上的自增值与源头上的相同。

  如果您使用的是基于行的或混合格式复制，所有的自增锁模式都是安全的，因为基于行的复制不会受到 SQL 语句执行顺序的影响（混合格式对于基于语句复制不安全的语句使用基于行的复制）。

- “丢失”的自增值和序列间隙

  在所有锁模式（0、1 和 2）中，如果生成自增值的事务回滚，那些自增值就会“丢失”。一旦为自增列生成了一个值，无论“INSERT-like”语句是否完成，无论包含的事务是否回滚，该值都不能回滚。这些丢失的值不会被重用。因此，表的 AUTO_INCREMENT 列中的值可能会有间隙。

- 为 AUTO_INCREMENT 列指定 NULL 或 0

  在所有锁模式（0、1 和 2）中，如果用户在 INSERT 语句中为 AUTO_INCREMENT 列指定 NULL 或 0，InnoDB 会像未指定值一样处理该行并为其生成新值。

- 为 AUTO_INCREMENT 列赋负值

  在所有锁模式（0、1 和 2）中，如果为 AUTO_INCREMENT 列赋予负值，自增机制的行为是未定义的。

- 如果 AUTO_INCREMENT 值超过了指定整型的最大整数

  在所有锁模式（0、1 和 2）中，如果值超过了可存储在指定整型中的最大整数，自增机制的行为是未定义的。

- “批量插入”中的自增值间隙

  当 `innodb_autoinc_lock_mode` 设置为 0（“传统”）或 1（“连续”）时，由任何给定语句生成的自增值是连续的，没有间隙，因为表级 AUTO-INC 锁会一直持有到语句结束，且一次只能执行一个这样的语句。

  当 `innodb_autoinc_lock_mode` 设置为 2（“交错”）时，“批量插入”生成的自增值可能会有间隙，但仅当有并发执行的“INSERT-like”语句时。

  对于锁模式 1 或 2，连续语句之间可能出现间隙，因为对于批量插入，每个语句所需的确切自增值数量可能无法知晓，可能会有估计过高的情况。

- “混合模式插入”分配的自增值

  考虑一个“混合模式插入”，其中“简单插入”为一些（但不是全部）结果行指定了自增值。这样的语句在锁模式 0、1 和 2 中的行为不同。例如，假设 c1 是表 t1 的 AUTO_INCREMENT 列，最近自动生成的序列号为 100。

  ```sql
  mysql> CREATE TABLE t1 (
      -> c1 INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, 
      -> c2 CHAR(1)
      -> ) ENGINE = INNODB;
  ```

  现在，考虑以下“混合模式插入”语句：

    ```sql
    mysql> INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
    ```

    当 `innodb_autoinc_lock_mode` 设置为 0（“传统”）时，四个新行为：

  ```sql
  mysql> SELECT c1, c2 FROM t1 ORDER BY c2;
  +-----+------+
  | c1  | c2   |
  +-----+------+
  |   1 | a    |
  | 101 | b    |
  |   5 | c    |
  | 102 | d    |
  +-----+------+
  ```
  下一个可用的自增值是 103，因为自增值是逐个分配的，而不是在语句执行开始时一次性分配。无论是否有并发执行的任何类型的“INSERT-like”语句，结果都是这样。
  
  当 `innodb_autoinc_lock_mode` 设置为 1（“连续”）时，四个新行也是：

  ```sql
  mysql> SELECT c1, c2 FROM t1 ORDER BY c2;
  +-----+------+
  | c1  | c2   |
  +-----+------+
  |   1 | a    |
  | 101 | b    |
  |   5 | c    |
  | 102 | d    |
  +-----+------+
  ```

  然而，在这种情况下，下一个可用的自增值是 105，而不是 103，因为在处理语句时分配了四个自增值，但只使用了两个。无论是否有并发执行的任何类型的“INSERT-like”语句，结果都是这样。
  
  当 `innodb_autoinc_lock_mode` 设置为 2（“交错”）时，四个新行为：

  ```sql
  mysql> SELECT c1, c2 FROM t1 ORDER BY c2;
  +-----+------+
  | c1  | c2   |
  +-----+------+
  |   1 | a    |
  |   x | b    |
  |   5 | c    |
  |   y | d    |
  +-----+------+
  ```

  x 和 y 的值是唯一的，且比任何先前生成的行都大。然而，x 和 y 的具体值取决于并发执行的语句生成的自增值数量。
  
  最后，考虑以下语句，当最近生成的序列号为 100 时发出：

  ```sql
  mysql> INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (101,'c'), (NULL,'d');
  ```

  对于任何 `innodb_autoinc_lock_mode` 设置，这条语句都会生成重复键错误 23000（无法写入；表中的重复键），因为 101 被分配给行(NULL, 'b')，而插入行 (101, 'c') 失败。

- 在一系列 INSERT 语句中间修改 AUTO_INCREMENT 列的值

  在 MySQL 5.7 及更早版本中，如果在一系列 INSERT 语句的中间修改 AUTO_INCREMENT 列的值，可能导致“Duplicate entry”错误。例如，如果您执行了一个 UPDATE 操作，将 AUTO_INCREMENT 列的值更改为大于当前最大自增值的值，则后续未指定未使用自增值的 INSERT 操作可能遇到“Duplicate entry”错误。在 MySQL 8.0 及以后版本中，如果您将 AUTO_INCREMENT 列的值修改为大于当前最大自增值的值，新值将被持久化，随后的 INSERT 操作将从新的、更大的值开始分配自增值。以下示例演示了这种行为。

  ```sql
  mysql> CREATE TABLE t1 (
      -> c1 INT NOT NULL AUTO_INCREMENT,
      -> PRIMARY KEY (c1)
      ->  ) ENGINE = InnoDB;
  
  mysql> INSERT INTO t1 VALUES(0), (0), (3);
  
  mysql> SELECT c1 FROM t1;
  +----+
  | c1 |
  +----+
  |  1 |
  |  2 |
  |  3 |
  +----+
  
  mysql> UPDATE t1 SET c1 = 4 WHERE c1 = 1;
  
  mysql> SELECT c1 FROM t1;
  +----+
  | c1 |
  +----+
  |  2 |
  |  3 |
  |  4 |
  +----+
  
  mysql> INSERT INTO t1 VALUES(0);
  
  mysql> SELECT c1 FROM t1;
  +----+
  | c1 |
  +----+
  |  2 |
  |  3 |
  |  4 |
  |  5 |
  +----+
  ```

##### InnoDB AUTO_INCREMENT 计数器初始化

本节描述了 InnoDB 如何初始化 AUTO_INCREMENT 计数器。

如果您为 InnoDB 表指定了 AUTO_INCREMENT 列，内存中的表对象包含一个特殊的计数器，称为自增计数器，用于为该列分配新值。

在 MySQL 5.7 及更早版本中，自增计数器存储在主内存中，而不是磁盘上。为了在服务器重启后初始化自增计数器，InnoDB 会在首次向包含 AUTO_INCREMENT 列的表中插入数据时，执行类似于以下语句：

```sql
SELECT MAX(ai_col) FROM table_name FOR UPDATE;
```

在 MySQL 8.0 中，这种行为发生了变化。每当自增计数器的当前最大值发生变化时，该值会被写入重做日志，并在每个检查点保存到数据字典中。这些更改使得自增计数器的当前最大值能够在服务器重启后持久化。

在正常关闭后的服务器重启中，InnoDB 使用存储在数据字典中的当前最大自增值来初始化内存中的自增计数器。

在崩溃恢复期间的服务器重启中，InnoDB 使用数据字典中存储的当前最大自增值初始化内存中的自增计数器，并扫描自上一个检查点以来写入重做日志的自增计数器值。如果重做日志中的值大于内存中的计数器值，则应用重做日志中的值。然而，在意外服务器退出的情况下，不能保证之前分配的自增值不被重用。每次由于 INSERT 或 UPDATE 操作而改变当前最大自增值时，新值会被写入重做日志，但如果意外退出发生在重做日志刷新到磁盘之前，重启服务器后初始化自增计数器时，之前分配的值可能会被重用。

InnoDB 使用类似于 `SELECT MAX(ai_col) FROM table_name FOR UPDATE` 语句来初始化自增计数器的唯一情况是在导入没有 .cfg 元数据文件的表时。否则，如果存在 .cfg 元数据文件，当前最大自增计数器值将从该文件读取。除了计数器值初始化外，当尝试使用 `ALTER TABLE ... AUTO_INCREMENT = N` 语句将计数器值设置为小于或等于持久化计数器值时，也会使用类似于 `SELECT MAX(ai_col) FROMtable_name` 语句来确定表的当前最大自增计数器值。例如，删除一些记录后，您可能会尝试将计数器值设置为更小的值。在这种情况下，必须搜索表以确保新的计数器值不小于或等于实际的当前最大计数器值。

在 MySQL 5.7 及更早版本中，服务器重启会取消 `AUTO_INCREMENT = N` 表选项的效果，该选项可用于 `CREATE TABLE` 或 `ALTER TABLE` 语句中，分别用于设置初始计数器值或修改现有计数器值。在 MySQL 8.0 中，服务器重启不会取消 `AUTO_INCREMENT = N` 表选项的效果。如果您将自增计数器初始化为特定值，或者将自增计数器值更改为更大的值，则新值在服务器重启后将保持不变。

> **注意**
>
> `ALTER TABLE ... AUTO_INCREMENT = N` 只能将自增计数器值更改为大于当前最大值的值。

在 MySQL 5.7 及更早版本中，紧跟在 `ROLLBACK` 操作之后的服务器重启可能导致先前分配给回滚事务的自增值被重用，实际上回滚了当前最大自增值。在 MySQL 8.0 中，当前最大自增值会持久化，防止之前分配的值被重用。

如果 `SHOW TABLE STATUS` 语句在自增计数器初始化之前检查表，InnoDB 将打开表并使用存储在数据字典中的当前最大自增值来初始化计数器值。然后，该值存储在内存中，供后续插入或更新操作使用。计数器值的初始化使用普通的独占锁定读取操作，持续到事务结束。InnoDB 在初始化新创建的表的自增计数器时也遵循相同的程序，前提是该表有一个大于 0 的用户指定的自增值。

自增计数器初始化后，如果在插入行时未明确指定自增值，InnoDB 会隐式地增加计数器并将新值分配给该列。如果您插入的行明确指定了自增列的值，并且该值大于当前的最大计数器值，则计数器将被设置为指定的值。

只要服务器运行，InnoDB 就会使用内存中的自增计数器。当服务器停止并重启时，InnoDB 会重新初始化自增计数器，如前所述。

`auto_increment_offset` 变量决定了 AUTO_INCREMENT 列值的起始点。默认设置是 1。

`auto_increment_increment` 变量控制连续列值之间的间隔。默认设置是 1。

##### 注意事项

当 AUTO_INCREMENT 整数列耗尽值时，后续的 INSERT 操作将返回重复键错误。这是 MySQL 的一般行为。